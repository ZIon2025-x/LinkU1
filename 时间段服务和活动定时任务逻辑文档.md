# 时间段服务和相关活动的定时任务逻辑文档

## 目录
1. [概述](#概述)
2. [时间段服务定时任务](#时间段服务定时任务)
3. [活动相关定时任务](#活动相关定时任务)
4. [定时任务调度配置](#定时任务调度配置)
5. [数据模型关系](#数据模型关系)
6. [时间处理规范](#时间处理规范)

---

## 概述

本系统实现了完整的时间段服务和活动管理机制，通过定时任务自动维护时间段的生命周期，并管理活动与时间段的关联关系。主要包含以下功能：

- **时间段自动生成**：每天自动为启用了时间段功能的服务生成未来一个月的时间段
- **时间段自动清理**：每天清理过期的时间段（昨天及之前的）
- **时间段自动关联**：新创建的时间段自动匹配并添加到符合重复规则的活动
- **活动自动结束**：检查活动是否应该结束（最后一个时间段结束或达到截至日期）
- **任务自动完成**：自动完成已过期时间段的任务

---

## 时间段服务定时任务

### 1. 自动生成未来时间段 (`auto_generate_future_time_slots`)

**位置**：`backend/app/crud.py`

**执行频率**：每天执行一次（通过 `CleanupTasks` 类调用）

**功能说明**：
- 为所有启用了时间段功能（`has_time_slots == True`）且状态为 `active` 的服务生成时间段
- 每天只生成下个月的今天的时间段（保持从今天到下个月的今天，共一个月的时间段）
- 支持两种配置模式：
  - **旧模式**：统一配置（`time_slot_start_time`、`time_slot_end_time`）
  - **新模式**：按周几配置（`weekly_time_slot_config`）

**核心逻辑**：

```python
# 1. 查询所有启用了时间段功能的服务
services = db.query(models.TaskExpertService).filter(
    models.TaskExpertService.has_time_slots == True,
    models.TaskExpertService.status == 'active',
).all()

# 2. 计算目标日期（下个月的今天）
today = date.today()
target_date = today + relativedelta(months=1)

# 3. 为每个服务生成目标日期的时间段
for service in services:
    # 根据配置模式获取时间段配置
    if has_weekly_config:
        # 使用按周几配置
        day_config = service.weekly_time_slot_config.get(weekday_name, {})
    else:
        # 使用统一配置
        slot_start_time = service.time_slot_start_time
        slot_end_time = service.time_slot_end_time
    
    # 生成该日期的时间段
    # 时间段间隔由 time_slot_duration_minutes 决定
    # 每个时间段的价格使用服务的 base_price
```

**关键特性**：
- 跳过已被手动删除的日期（`is_manually_deleted == True`）
- 避免重复创建已存在的时间段
- 时间段时间使用英国时区（Europe/London），存储时转换为UTC

**调用位置**：
- `backend/app/cleanup_tasks.py` - `CleanupTasks._auto_generate_future_time_slots()`
- 每天检查一次，确保今天已生成过则跳过

---

### 2. 清理过期时间段 (`cleanup_expired_time_slots`)

**位置**：`backend/app/crud.py`

**执行频率**：每天执行一次（通过 `CleanupTasks` 类调用）

**功能说明**：
- 清理昨天及之前的所有过期时间段
- 保持从今天到下个月的今天的时间段（一个月）
- 删除所有过期的时间段，无论是否有参与者

**核心逻辑**：

```python
# 1. 计算截止时间（昨天23:59:59，英国时间）
current_utc = get_utc_time()
yesterday = current_utc.date() - timedelta(days=1)
yesterday_end_local = dt_datetime.combine(yesterday, dt_time(23, 59, 59))
cutoff_time = parse_local_as_utc(yesterday_end_local, LONDON)

# 2. 查找所有过期的时间段
expired_slots = db.query(models.ServiceTimeSlot).filter(
    models.ServiceTimeSlot.slot_start_datetime < cutoff_time,
    models.ServiceTimeSlot.is_manually_deleted == False,  # 不删除手动删除的
).all()

# 3. 删除过期时间段
for slot in expired_slots:
    db.delete(slot)
```

**关键特性**：
- 不删除手动删除的时间段（`is_manually_deleted == True`）
- 记录有参与者的时间段数量（用于日志）
- 时间段删除会级联删除相关的关联记录（通过外键约束）

**调用位置**：
- `backend/app/cleanup_tasks.py` - `CleanupTasks._cleanup_expired_time_slots()`
- 每天检查一次，确保今天已清理过则跳过

---

### 3. 自动添加时间段到活动 (`auto_add_time_slots_to_activities`)

**位置**：`backend/app/task_expert_routes.py`

**执行时机**：在创建新时间段时自动调用（非定时任务，实时触发）

**功能说明**：
- 当新创建时间段时，自动检查是否有活动的重复规则匹配该时间段
- 如果匹配，自动将时间段添加到活动中
- 支持两种重复模式：
  - **每天重复**（`daily`）：匹配指定时间范围的时间段
  - **每周重复**（`weekly`）：匹配指定星期几和时间范围的时间段

**核心逻辑**：

```python
# 1. 查询该服务的所有活动的重复规则
recurring_relations = await db.execute(
    select(models.ActivityTimeSlotRelation)
    .join(models.Activity)
    .where(models.Activity.expert_service_id == service_id)
    .where(models.ActivityTimeSlotRelation.relation_mode == "recurring")
    .where(models.ActivityTimeSlotRelation.auto_add_new_slots == True)
    .where(models.Activity.status == "open")  # 只处理开放中的活动
)

# 2. 对每个新时间段，检查是否匹配重复规则
for slot in new_slots:
    for relation in recurring_relations:
        recurring_rule = relation.recurring_rule
        
        if rule_type == "daily":
            # 检查时间段是否在指定的时间范围内
            # 时间段开始时间在范围内，或时间段包含范围
            if (range_start <= slot_start_time < range_end) or 
               (slot_start_time <= range_start < slot_end_time):
                matched = True
        
        elif rule_type == "weekly":
            # 检查星期几和时间范围是否都匹配
            if slot_weekday in weekdays and time_range_matched:
                matched = True
        
        # 如果匹配，创建固定关联
        if matched:
            fixed_relation = models.ActivityTimeSlotRelation(
                activity_id=relation.activity_id,
                time_slot_id=slot.id,
                relation_mode="fixed",
                auto_add_new_slots=False,
                slot_start_datetime=slot.slot_start_datetime,
                slot_end_datetime=slot.slot_end_datetime,
            )
            db.add(fixed_relation)
```

**关键特性**：
- 只处理开放中的活动（`status == "open"`）
- 只处理启用了自动添加的活动（`auto_add_new_slots == True`）
- 检查时间段是否超过活动截至日期（`activity_end_date`）
- 避免重复添加已存在的时间段
- 避免添加已被其他活动使用的时间段（固定模式）

**调用位置**：
- 在批量创建时间段时调用：`batch_create_service_time_slots`
- 在自动生成时间段后调用（如果实现了的话）

---

## 活动相关定时任务

### 1. 检查并结束活动 (`check_and_end_activities`)

**位置**：`backend/app/task_expert_routes.py`（异步版本）
**同步包装**：`backend/app/scheduled_tasks.py` - `check_and_end_activities_sync`

**执行频率**：每5分钟执行一次

**功能说明**：
- 检查所有开放中的活动是否应该结束
- 结束条件：
  1. 达到活动截至日期（`activity_end_date`）
  2. 最后一个时间段已结束，且没有未来的匹配时间段

**核心逻辑**：

```python
# 1. 查询所有开放中的活动
open_activities = await db.execute(
    select(models.Activity)
    .where(models.Activity.status == "open")
)

# 2. 对每个活动检查是否应该结束
for activity in open_activities:
    should_end = False
    end_reason = ""
    
    # 检查是否达到截至日期
    if recurring_relation and recurring_relation.activity_end_date:
        today = date.today()
        if today > recurring_relation.activity_end_date:
            should_end = True
            end_reason = f"已达到活动截至日期 {recurring_relation.activity_end_date}"
    
    # 检查最后一个时间段是否已结束
    if not should_end and fixed_relations:
        last_slot = time_slots[0]  # 按结束时间降序排列的第一个
        
        if last_slot.slot_end_datetime < current_time:
            # 如果活动有重复规则且auto_add_new_slots为True
            if recurring_relation and recurring_relation.auto_add_new_slots:
                # 检查是否还有未到期的匹配时间段（未来30天内）
                future_slots = await db.execute(
                    select(models.ServiceTimeSlot)
                    .where(models.ServiceTimeSlot.service_id == service.id)
                    .where(models.ServiceTimeSlot.slot_start_datetime > current_time)
                    .where(models.ServiceTimeSlot.slot_start_datetime <= future_utc)
                    .where(models.ServiceTimeSlot.is_manually_deleted == False)
                    .limit(1)
                )
                
                if not future_slots.scalar_one_or_none():
                    # 没有未来的时间段，结束活动
                    should_end = True
                    end_reason = "最后一个时间段已结束，且没有未来的匹配时间段"
            else:
                # 没有重复规则或auto_add_new_slots为False
                should_end = True
                end_reason = f"最后一个时间段已结束（{last_slot.slot_end_datetime}）"
    
    # 如果应该结束，更新活动状态
    if should_end:
        activity.status = "ended"
        activity.ended_at = current_time
        ended_count += 1
```

**关键特性**：
- 支持两种关联模式：
  - **固定模式**（`fixed`）：直接关联具体时间段
  - **重复模式**（`recurring`）：通过规则匹配时间段
- 对于有重复规则且启用了自动添加的活动，会检查未来30天内是否还有匹配的时间段
- 如果没有未来的匹配时间段，才会结束活动
- 使用异步实现，通过 `run_coroutine_threadsafe` 在同步定时任务中调用

**调用位置**：
- `backend/app/scheduled_tasks.py` - `check_and_end_activities_sync()`
- `backend/app/task_scheduler.py` - 注册为每5分钟执行一次
- `backend/app/celery_app.py` - Celery Beat 配置为每5分钟执行一次

---

### 2. 自动完成已过期时间段的任务 (`auto_complete_expired_time_slot_tasks`)

**位置**：`backend/app/scheduled_tasks.py`

**执行频率**：每1分钟执行一次

**功能说明**：
- 自动完成已过期时间段的任务
- 只处理达人类型的任务（`expert_service_id` 不为空）
- 只处理状态为 `in_progress`、`taken` 或 `pending_confirmation` 的任务
- 支持两种情况：
  1. 单个任务：通过 `TaskTimeSlotRelation` 直接关联时间段
  2. 多人任务：通过父活动（`Activity`）的 `ActivityTimeSlotRelation` 关联时间段

**核心逻辑**：

```python
# 1. 查询所有状态为 in_progress、taken 或 pending_confirmation 的达人类型任务
tasks_query = db.query(models.Task).filter(
    models.Task.status.in_(["in_progress", "taken", "pending_confirmation"]),
    models.Task.expert_service_id.isnot(None)  # 只处理达人类型的任务
).options(
    selectinload(models.Task.time_slot_relations).selectinload(models.TaskTimeSlotRelation.time_slot),
    selectinload(models.Task.parent_activity).selectinload(models.Activity.time_slot_relations)
    .selectinload(models.ActivityTimeSlotRelation.time_slot)
)

# 2. 对每个任务，查找其关联的时间段结束时间
for task in tasks:
    max_end_time = None
    
    # 优先检查：任务直接关联的时间段
    if task.time_slot_relations and len(task.time_slot_relations) > 0:
        for relation in task.time_slot_relations:
            # 优先使用冗余字段 slot_end_datetime
            if relation.slot_end_datetime:
                end_time = relation.slot_end_datetime
            # 如果冗余字段为空，从关联的 ServiceTimeSlot 获取
            elif relation.time_slot_id and relation.time_slot:
                end_time = relation.time_slot.slot_end_datetime
            
            if end_time and (max_end_time is None or end_time > max_end_time):
                max_end_time = end_time
    
    # 备用检查：父活动关联的时间段（只有在任务直接关联不存在时）
    if max_end_time is None and task.parent_activity:
        for relation in task.parent_activity.time_slot_relations:
            # 同样优先使用冗余字段
            if relation.slot_end_datetime:
                end_time = relation.slot_end_datetime
            elif relation.time_slot_id and relation.time_slot:
                end_time = relation.time_slot.slot_end_datetime
            
            if end_time and (max_end_time is None or end_time > max_end_time):
                max_end_time = end_time
    
    # 3. 如果时间段已过期，自动完成任务
    if max_end_time and max_end_time < current_time:
        task.status = "completed"
        task.completed_at = current_time
        completed_count += 1
```

**关键特性**：
- 优先使用任务直接关联的时间段，而不是父活动的时间段
- 优先使用冗余字段 `slot_end_datetime`，避免关联查询
- 只处理达人类型的任务（`expert_service_id` 不为空）
- 自动设置 `completed_at` 时间戳

**调用位置**：
- `backend/app/task_scheduler.py` - 注册为每1分钟执行一次
- `backend/app/celery_app.py` - Celery Beat 配置为每1分钟执行一次

---

## 定时任务调度配置

### 任务调度器（TaskScheduler）

**位置**：`backend/app/task_scheduler.py`

**配置的任务**：

| 任务名称 | 执行频率 | 描述 |
|---------|---------|------|
| `auto_complete_expired_time_slot_tasks` | 每1分钟 | 自动完成已过期时间段的任务 |
| `check_and_end_activities` | 每5分钟 | 检查并结束活动 |
| `cancel_expired_tasks` | 每1分钟 | 取消过期任务 |
| `check_expired_coupons` | 每5分钟 | 检查过期优惠券 |
| `check_expired_invitation_codes` | 每5分钟 | 检查过期邀请码 |
| `check_expired_points` | 每5分钟 | 检查过期积分 |

### Celery Beat 配置

**位置**：`backend/app/celery_app.py`

**配置的任务**：

```python
celery_app.conf.beat_schedule = {
    # 自动完成已过期时间段的任务 - 每1分钟执行一次
    'auto-complete-expired-time-slot-tasks': {
        'task': 'app.celery_tasks.auto_complete_expired_time_slot_tasks_task',
        'schedule': 60.0,  # 1分钟
    },
    
    # 检查并结束活动 - 每5分钟执行一次
    'check-and-end-activities': {
        'task': 'app.celery_tasks.check_and_end_activities_task',
        'schedule': 300.0,  # 5分钟
    },
}
```

### 清理任务（CleanupTasks）

**位置**：`backend/app/cleanup_tasks.py`

**配置的任务**：

| 任务名称 | 执行频率 | 描述 |
|---------|---------|------|
| `_auto_generate_future_time_slots` | 每天一次 | 自动生成未来时间段 |
| `_cleanup_expired_time_slots` | 每天一次 | 清理过期时间段 |

**实现方式**：
- 使用类属性记录最后执行日期，确保每天只执行一次
- 在 `CleanupTasks` 的循环中定期检查并执行

---

## 数据模型关系

### 核心数据模型

1. **TaskExpertService**（达人服务）
   - `has_time_slots`: 是否启用时间段功能
   - `time_slot_start_time`: 时间段开始时间（旧模式）
   - `time_slot_end_time`: 时间段结束时间（旧模式）
   - `weekly_time_slot_config`: 按周几配置（新模式）
   - `time_slot_duration_minutes`: 时间段时长（分钟）
   - `participants_per_slot`: 每个时间段的最大参与者数

2. **ServiceTimeSlot**（服务时间段）
   - `service_id`: 关联的服务ID
   - `slot_start_datetime`: 时间段开始时间（UTC）
   - `slot_end_datetime`: 时间段结束时间（UTC）
   - `price_per_participant`: 每个参与者的价格
   - `max_participants`: 最大参与者数
   - `current_participants`: 当前参与者数
   - `is_available`: 是否可用
   - `is_manually_deleted`: 是否手动删除

3. **Activity**（活动）
   - `expert_service_id`: 关联的服务ID
   - `status`: 活动状态（`open`、`ended`）
   - `ended_at`: 结束时间

4. **ActivityTimeSlotRelation**（活动与时间段关联）
   - `activity_id`: 活动ID
   - `time_slot_id`: 时间段ID（固定模式）
   - `relation_mode`: 关联模式（`fixed` 或 `recurring`）
   - `recurring_rule`: 重复规则（JSON格式，仅用于重复模式）
   - `auto_add_new_slots`: 是否自动添加新匹配的时间段
   - `activity_end_date`: 活动截至日期
   - `slot_start_datetime`: 时间段开始时间（冗余字段）
   - `slot_end_datetime`: 时间段结束时间（冗余字段）

5. **Task**（任务）
   - `expert_service_id`: 关联的服务ID（达人类型任务）
   - `parent_activity_id`: 父活动ID（多人任务）
   - `status`: 任务状态

6. **TaskTimeSlotRelation**（任务与时间段关联）
   - `task_id`: 任务ID
   - `time_slot_id`: 时间段ID
   - `relation_mode`: 关联模式（`fixed` 或 `recurring`）
   - `slot_start_datetime`: 时间段开始时间（冗余字段）
   - `slot_end_datetime`: 时间段结束时间（冗余字段）

### 关系图

```
TaskExpertService (达人服务)
    ├── has_time_slots: bool
    ├── time_slot_start_time / weekly_time_slot_config
    └── 1:N ──> ServiceTimeSlot (服务时间段)
            ├── slot_start_datetime (UTC)
            ├── slot_end_datetime (UTC)
            └── is_manually_deleted: bool

Activity (活动)
    ├── expert_service_id
    ├── status: 'open' | 'ended'
    └── 1:N ──> ActivityTimeSlotRelation (活动时间段关联)
            ├── relation_mode: 'fixed' | 'recurring'
            ├── recurring_rule: JSON
            ├── auto_add_new_slots: bool
            └── activity_end_date: Date

Task (任务)
    ├── expert_service_id
    ├── parent_activity_id
    └── 1:N ──> TaskTimeSlotRelation (任务时间段关联)
            └── slot_end_datetime (冗余字段)
```

---

## 时间处理规范

### 时区处理

**核心原则**（来自 `backend/app/utils/time_utils.py`）：

1. **存储与计算一律UTC**（带时区）
2. **展示与解析只在入/出边界使用Europe/London**
3. **禁止naive时间自动假设为UTC**
4. **全局统一使用zoneinfo，禁止pytz**

### 关键函数

- `get_utc_time()`: 获取当前UTC时间（带时区信息）
- `parse_local_as_utc(naive_local, tz=LONDON)`: 将本地时间解析为UTC
- `to_user_timezone(dt_utc, tz=LONDON)`: 将UTC时间转换为用户时区（仅用于显示）

### 时间段时间处理

- 时间段配置使用英国时区（Europe/London）
- 存储到数据库时转换为UTC
- 时间段开始/结束时间使用 `DateTime(timezone=True)` 类型
- 冗余字段 `slot_start_datetime` 和 `slot_end_datetime` 也存储UTC时间

---

## 总结

本系统通过定时任务实现了完整的时间段服务和活动管理生命周期：

1. **时间段生成**：每天自动生成未来一个月的时间段
2. **时间段清理**：每天清理过期的时间段
3. **时间段关联**：新时间段自动匹配并添加到符合规则的活动
4. **活动结束**：每5分钟检查活动是否应该结束
5. **任务完成**：每1分钟自动完成已过期时间段的任务

所有时间处理统一使用UTC，在边界处转换为英国时区（Europe/London），确保时区处理的一致性和正确性。

