# 英国留学生认证系统 - 企业级技术文档

## 文档版本信息

- **文档版本**: v1.0.0
- **创建日期**: 2024年
- **最后更新**: 2024年
- **文档状态**: 正式版
- **维护团队**: LinkU开发团队

---

## 目录

1. [系统概述](#1-系统概述)
2. [业务需求](#2-业务需求)
3. [系统架构](#3-系统架构)
4. [数据库设计](#4-数据库设计)
5. [认证流程](#5-认证流程)
6. [API接口设计](#6-api接口设计)
7. [邮箱后缀管理](#7-邮箱后缀管理)
8. [有效期管理](#8-有效期管理)
9. [安全机制](#9-安全机制)
10. [错误处理](#10-错误处理)
11. [监控与日志](#11-监控与日志)
12. [测试策略](#12-测试策略)
13. [部署指南](#13-部署指南)
14. [运维手册](#14-运维手册)
15. [附录](#15-附录)

---

## 1. 系统概述

### 1.1 系统简介

英国留学生认证系统是一个基于学生邮箱验证的身份认证系统，用于验证用户是否为英国大学的在校学生。系统通过验证学生邮箱后缀来确定用户所属的大学，并管理学生身份的有效期。

### 1.2 核心功能

- **邮箱验证**: 通过发送验证邮件到学生邮箱进行身份验证
- **大学识别**: 根据邮箱后缀自动识别用户所属大学
- **有效期管理**: 每年10月1日统一过期，需要重新验证
- **自动提醒**: 在过期前自动发送提醒邮件
- **状态管理**: 实时跟踪和管理学生认证状态

### 1.3 技术栈

- **后端框架**: FastAPI (Python 3.9+)
- **数据库**: PostgreSQL 14+
- **缓存**: Redis 6+
- **邮件服务**: Resend / SMTP
- **任务队列**: Celery (用于异步邮件发送)
- **日志系统**: Python logging + ELK Stack (可选)

---

## 2. 业务需求

### 2.1 功能需求

#### 2.1.1 邮箱验证
- 用户输入学生邮箱地址
- **重要约束：只有以 `.ac.uk` 结尾的邮箱才能验证学生身份**
  - 原因：`.ac.uk` 是英国学术机构的标准域名后缀
  - 非 `.ac.uk` 结尾的邮箱（如 `@gmail.com`、`@outlook.com` 等）无法验证学生身份
- **重要约束：同一个学生邮箱在同一时间只能被一个用户验证**（全局唯一性）
- **过期释放规则：认证过期后，邮箱立即可以被其他用户重新验证**
  - 原因：学生可能毕业、转学，邮箱可能被回收或重新分配
  - 释放时机：过期后立即释放
- **待验证状态规则：邮箱处于pending状态时，其他用户不能使用该邮箱**
  - 原因：防止邮箱被恶意占用，防止多个用户同时验证同一邮箱造成混乱
  - 例外：如果pending状态超过15分钟（验证令牌过期），可以覆盖旧记录
- 系统首先检查邮箱是否以 `.ac.uk` 结尾
- 系统检查邮箱是否已被其他用户验证（仅检查有效、未过期和pending未超过15分钟的记录）
- 如果邮箱未被使用、已过期或pending超过15分钟，系统发送验证邮件到该邮箱
- 用户点击邮件中的验证链接完成验证
- 验证成功后，系统根据邮箱后缀识别大学

#### 2.1.2 大学识别
- **前提条件：邮箱必须以 `.ac.uk` 结尾**
- 系统维护英国大学邮箱后缀白名单（所有大学邮箱都以 `.ac.uk` 结尾）
- 根据邮箱后缀自动匹配大学
- 支持多级域名匹配（如 `@student.gla.ac.uk`）
- 支持通配符匹配（如 `@*.ac.uk`）

#### 2.1.3 有效期管理
- 所有学生认证统一在每年10月1日过期
- 过期前30天、7天、1天发送提醒邮件
- 过期后用户失去学生身份，需要重新验证
- 支持手动提前验证（续期）

#### 2.1.4 状态管理
- **待验证** (pending): 已提交邮箱，等待验证
  - 邮箱被占用，其他用户不能使用
  - 如果超过15分钟未验证，记录可以被覆盖
- **已验证** (verified): 已验证，认证有效
- **已过期** (expired): 认证已过期
  - 邮箱立即释放，可以被其他用户使用
- **已撤销** (revoked): 管理员手动撤销
  - **重要**：撤销后邮箱立即释放，可以被其他用户使用（与过期释放机制一致）
  - 原因：撤销操作通常表示用户不再需要该认证，应尽快释放邮箱资源

### 2.2 非功能需求

#### 2.2.1 性能要求
- 邮箱验证响应时间 < 2秒
- 邮件发送成功率 > 99%
- 支持并发验证请求 > 1000/秒
- 数据库查询响应时间 < 100ms

#### 2.2.2 安全要求
- 验证令牌有效期15分钟
- 验证令牌一次性使用
- 防止暴力破解（限流：5次/分钟）
- 防止邮箱枚举攻击
- 所有敏感操作记录审计日志

#### 2.2.3 可用性要求
- 系统可用性 > 99.9%
- 邮件服务故障时降级处理
- 数据库故障时自动切换
- 支持灰度发布和回滚

---

## 3. 系统架构

### 3.1 架构图

```
┌─────────────┐
│  前端应用   │
│  (React)    │
└──────┬──────┘
       │ HTTPS
       ▼
┌─────────────────────────────────────┐
│         API Gateway                 │
│      (FastAPI + Nginx)              │
└──────┬──────────────────┬───────────┘
       │                  │
       ▼                  ▼
┌─────────────┐    ┌─────────────┐
│  业务逻辑层  │    │  邮件服务层  │
│  (Routers)  │    │  (Celery)   │
└──────┬──────┘    └─────────────┘
       │
       ▼
┌─────────────────────────────────────┐
│         数据访问层                   │
│    (SQLAlchemy ORM)                 │
└──────┬──────────────────┬───────────┘
       │                  │
       ▼                  ▼
┌─────────────┐    ┌─────────────┐
│  PostgreSQL │    │    Redis    │
│  (主数据库)  │    │   (缓存)    │
└─────────────┘    └─────────────┘
```

### 3.2 模块划分

#### 3.2.1 认证模块 (`student_verification`)
- 邮箱验证逻辑
- 令牌生成和验证
- 大学识别逻辑

#### 3.2.2 邮件模块 (`email_service`)
- 验证邮件发送
- 提醒邮件发送
- 邮件模板管理
- **邮件送达优化**：配置 SPF/DKIM/DMARC 记录，使用可信域名发件人，提高邮件送达率

#### 3.2.3 任务模块 (`celery_tasks`)
- 异步邮件发送
  - 支持自动重试（最多3次）
  - 失败后进入死信队列，支持人工审核和手动重试
- 批量过期处理
- 定时提醒任务

#### 3.2.4 管理模块 (`admin`)
- 大学邮箱后缀管理
- 认证状态查询
- 手动操作（撤销、续期等）

---

## 4. 数据库设计

### 4.1 数据表设计

#### 4.1.1 大学表 (`universities`)

```sql
CREATE TABLE universities (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL UNIQUE,
    name_cn VARCHAR(255),
    email_domain VARCHAR(255) NOT NULL UNIQUE,
    domain_pattern VARCHAR(255) NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 添加字段注释
COMMENT ON COLUMN universities.name IS '大学名称（英文）';
COMMENT ON COLUMN universities.name_cn IS '大学名称（中文）';
COMMENT ON COLUMN universities.email_domain IS '邮箱域名（如 bristol.ac.uk）';
COMMENT ON COLUMN universities.domain_pattern IS '匹配模式（支持通配符）';
COMMENT ON COLUMN universities.is_active IS '是否启用';

-- 创建索引
CREATE INDEX idx_email_domain ON universities(email_domain);
CREATE INDEX idx_is_active ON universities(is_active);
```

**示例数据**:
```sql
INSERT INTO universities (name, name_cn, email_domain, domain_pattern) VALUES
('University of Bristol', '布里斯托大学', 'bristol.ac.uk', '@bristol.ac.uk'),
('University of Essex', '埃塞克斯大学', 'essex.ac.uk', '@essex.ac.uk'),
('University of Glasgow', '格拉斯哥大学', 'student.gla.ac.uk', '@student.gla.ac.uk'),
('University of Oxford', '牛津大学', 'ox.ac.uk', '@*.ox.ac.uk'),
('University of Cambridge', '剑桥大学', 'cam.ac.uk', '@*.cam.ac.uk');
```

#### 4.1.2 学生认证表 (`student_verifications`)

```sql
CREATE TABLE student_verifications (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    university_id INTEGER NOT NULL REFERENCES universities(id),
    email VARCHAR(255) NOT NULL,
    status VARCHAR(50) NOT NULL DEFAULT 'pending',
    verification_token VARCHAR(255),
    token_expires_at TIMESTAMP,
    verified_at TIMESTAMP,
    expires_at TIMESTAMP NOT NULL,
    revoked_at TIMESTAMP,
    revoked_reason TEXT NOT NULL,  -- 撤销原因（必填，提升审计能力）
    revoked_reason_type VARCHAR(50),  -- 撤销原因类型（user_request, violation, account_hacked, other）
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 添加字段注释
COMMENT ON COLUMN student_verifications.email IS '验证的学生邮箱（统一小写存储）';
COMMENT ON COLUMN student_verifications.status IS '状态: pending, verified, expired, revoked';
COMMENT ON COLUMN student_verifications.verification_token IS '验证令牌';
COMMENT ON COLUMN student_verifications.token_expires_at IS '令牌过期时间';
COMMENT ON COLUMN student_verifications.verified_at IS '验证通过时间';
COMMENT ON COLUMN student_verifications.expires_at IS '认证过期时间（每年10月1日）';
COMMENT ON COLUMN student_verifications.revoked_at IS '撤销时间';
COMMENT ON COLUMN student_verifications.revoked_reason IS '撤销原因（必填，提升审计能力）';
COMMENT ON COLUMN student_verifications.revoked_reason_type IS '撤销原因类型（user_request, violation, account_hacked, other）';

-- 创建索引
CREATE INDEX idx_user_id ON student_verifications(user_id);
CREATE INDEX idx_university_id ON student_verifications(university_id);
CREATE INDEX idx_email ON student_verifications(email);
CREATE INDEX idx_status ON student_verifications(status);
CREATE INDEX idx_expires_at ON student_verifications(expires_at);
CREATE INDEX idx_verification_token ON student_verifications(verification_token);

-- 创建唯一索引（验证令牌）
CREATE UNIQUE INDEX idx_verification_token_unique ON student_verifications(verification_token) WHERE verification_token IS NOT NULL;

-- 部分唯一索引：同一用户只能有一个活跃的认证（pending或verified状态）
-- 注意：这里使用 (user_id) 而不是 (user_id, status)，确保同一用户最多只有一条 pending 或 verified 记录
CREATE UNIQUE INDEX unique_user_active ON student_verifications(user_id) WHERE status IN ('verified', 'pending');

-- 注意：邮箱唯一性约束在应用层实现，允许过期后的邮箱被重新使用
-- 不在数据库层面设置UNIQUE约束，因为需要支持过期后立即释放
```

#### 4.1.3 验证历史表 (`verification_history`)

```sql
CREATE TABLE verification_history (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    university_id INTEGER NOT NULL REFERENCES universities(id),
    email VARCHAR(255) NOT NULL,
    action VARCHAR(50) NOT NULL,
    previous_status VARCHAR(50),
    new_status VARCHAR(50),
    ip_address VARCHAR(45),
    user_agent TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 添加字段注释
COMMENT ON COLUMN verification_history.action IS '操作: verified, expired, revoked, renewed';

-- 创建索引
CREATE INDEX idx_user_id ON verification_history(user_id);
CREATE INDEX idx_action ON verification_history(action);
CREATE INDEX idx_created_at ON verification_history(created_at);
```

#### 4.1.4 邮箱后缀配置表 (`university_email_patterns`)

```sql
CREATE TABLE university_email_patterns (
    id SERIAL PRIMARY KEY,
    university_id INTEGER NOT NULL REFERENCES universities(id) ON DELETE CASCADE,
    pattern VARCHAR(255) NOT NULL,
    priority INTEGER DEFAULT 0,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 添加字段注释
COMMENT ON COLUMN university_email_patterns.pattern IS '邮箱匹配模式（正则表达式）';
COMMENT ON COLUMN university_email_patterns.priority IS '优先级（数字越大优先级越高）';

-- 创建索引
CREATE INDEX idx_university_id ON university_email_patterns(university_id);
CREATE INDEX idx_priority ON university_email_patterns(priority);

-- 创建唯一索引
CREATE UNIQUE INDEX unique_university_pattern ON university_email_patterns(university_id, pattern);
```

### 4.2 数据库索引优化

```sql
-- 复合索引优化查询性能
CREATE INDEX idx_verification_user_status ON student_verifications(user_id, status);
CREATE INDEX idx_verification_expires_status ON student_verifications(expires_at, status);

-- 邮箱小写索引（PostgreSQL 13+支持函数索引，确保大小写不敏感查询）
CREATE INDEX idx_student_verifications_email_lower ON student_verifications (lower(email));

-- 注意：如果使用 Citus 或支持函数唯一索引的版本，可以考虑：
-- CREATE UNIQUE INDEX idx_student_verifications_email_unique ON student_verifications (lower(email));

-- 全文搜索索引（用于大学名称搜索）
CREATE INDEX idx_university_name_search ON universities USING gin(to_tsvector('english', name || ' ' || COALESCE(name_cn, '')));
```

### 4.3 数据库约束

```sql
-- 检查约束：确保状态值有效
ALTER TABLE student_verifications 
ADD CONSTRAINT chk_status CHECK (status IN ('pending', 'verified', 'expired', 'revoked'));

-- 检查约束：确保过期时间在创建时间之后
ALTER TABLE student_verifications 
ADD CONSTRAINT chk_expires_at CHECK (expires_at > created_at);

-- 注意：邮箱唯一性约束在应用层实现，不在数据库层面设置UNIQUE约束
-- 原因：需要支持过期后的邮箱被其他用户重新使用
-- 应用层会检查邮箱是否在有效期内，如果已过期则允许重新验证

-- 触发器：自动更新 updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_student_verifications_updated_at 
BEFORE UPDATE ON student_verifications 
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

---

## 5. 认证流程

### 5.1 首次认证流程

```
用户提交邮箱
    │
    ▼
验证邮箱格式
    │
    ▼
检查邮箱是否以 `.ac.uk` 结尾
    │
    ├─ 不是 `.ac.uk` 结尾 → 返回错误：只有 `.ac.uk` 结尾的邮箱才能验证
    │
    └─ 是 `.ac.uk` 结尾 → 继续
    │
    ▼
检查邮箱后缀是否在白名单
    │
    ├─ 不在白名单 → 返回错误：该大学不在支持列表中
    │
    └─ 在白名单 → 继续
    │
    ▼
检查邮箱是否已被其他用户验证（检查有效、未过期和pending未超过15分钟的记录）
    │
    ├─ 已被使用且未过期 → 返回错误：邮箱已被使用
    │
    ├─ 已被使用但已过期 → 删除旧记录，允许新验证
    │
    ├─ pending状态且未超过15分钟 → 返回错误：邮箱已被使用
    │
    ├─ pending状态且超过15分钟 → 删除旧记录，允许新验证
    │
    └─ 未被使用 → 继续
    │
    ▼
生成验证令牌（15分钟有效）
    │
    ▼
存储待验证记录（status=pending）
    │
    ▼
发送验证邮件（异步）
    │
    ▼
用户点击邮件链接
    │
    ▼
验证令牌有效性（从Redis获取并验证）
    │
    ├─ 令牌无效或已过期 → 返回错误
    │
    └─ 令牌有效 → 继续
    │
    ▼
从Redis删除验证令牌（一次性使用，防止重复验证）
    │
    ▼
再次检查邮箱唯一性（防止并发验证）
    │
    ├─ 已被使用 → 返回错误
    │
    └─ 未被使用 → 继续
    │
    ▼
更新认证状态（status=verified）
    │
    ▼
设置过期时间（当年10月1日或次年10月1日）
    │
    ▼
记录验证历史
    │
    ▼
返回成功
```

### 5.2 续期认证流程

```
用户申请续期（过期前30天内）
    │
    ▼
检查当前认证状态
    │
    ▼
检查是否为同一用户（续期时允许同一用户使用相同邮箱）
    │
    ├─ 不同用户 → 返回错误：邮箱已被使用
    │
    └─ 同一用户 → 继续
    │
    ▼
生成新的验证令牌
    │
    ▼
发送验证邮件
    │
    ▼
用户完成验证
    │
    ▼
更新过期时间（新的10月1日）
    │
    ▼
记录续期历史
```

**注意**：续期时，系统会排除当前用户的记录进行邮箱唯一性检查，允许同一用户使用相同邮箱进行续期验证。但如果邮箱已被其他用户验证，则不允许续期。

### 5.3 自动过期流程

```
定时任务（每天凌晨2点执行）
    │
    ▼
查询所有 expires_at <= 今天 且 status='verified' 的记录
    │
    ▼
批量更新状态为 expired
    │
    ▼
记录过期历史
    │
    ▼
发送过期通知邮件（可选）
```

### 5.4 提醒流程

```
定时任务（每天检查）
    │
    ▼
查询即将过期的认证（30天、7天、1天）
    │
    ▼
检查是否已发送过该级别的提醒
    │
    ▼
发送提醒邮件（异步）
    │
    ▼
记录提醒发送历史
```

---

## 6. API接口设计

### 6.1 接口规范

- **基础URL**: `/api/student-verification`
- **认证方式**: JWT Token（Bearer Token）
- **数据格式**: JSON
- **字符编码**: UTF-8
- **时区**: UTC（返回时间戳，前端转换）

### 6.2 接口列表

#### 6.2.1 提交认证申请

**接口**: `POST /api/student-verification/submit`

**请求体**:
```json
{
    "email": "student@bristol.ac.uk"
}
```

**响应** (200 OK):
```json
{
    "code": 200,
    "message": "验证邮件已发送",
    "data": {
        "verification_id": 12345,
        "email": "student@bristol.ac.uk",
        "university": {
            "id": 1,
            "name": "University of Bristol",
            "name_cn": "布里斯托大学"
        },
        "expires_at": "2025-10-01T00:00:00Z"
    }
}
```

**错误响应说明**：

> **重要：安全模式策略**
> 
> 系统支持两种响应模式，用于平衡安全性和用户体验：
> 
> **1. 开发/内部环境模式（详细错误码）**：
> - 对无效邮箱格式：返回 `400 + INVALID_EMAIL_FORMAT`
> - 对非 `.ac.uk` 后缀：返回 `400 + INVALID_EMAIL_SUFFIX`
> - 对不在白名单：返回 `400 + INVALID_EMAIL_DOMAIN`
> - 对已使用邮箱：返回 `409 + EMAIL_ALREADY_VERIFIED`
> 
> **2. 生产安全模式（防邮箱枚举）**：
> - 对无效邮箱格式、非 `.ac.uk` 后缀、不在白名单：统一返回 `200 { "message": "验证邮件已发送" }`（不暴露原因）
> - 对已使用邮箱：返回 `409 + EMAIL_ALREADY_VERIFIED`（明确错误）
> 
> 详细说明请参考 [9.4 邮箱枚举防护](#94-邮箱枚举防护) 章节。

**错误响应** (400 Bad Request - 非 .ac.uk 后缀) - 开发模式:
```json
{
    "code": 400,
    "message": "只有以 .ac.uk 结尾的邮箱才能验证学生身份",
    "error": "INVALID_EMAIL_SUFFIX",
    "details": {
        "email": "student@gmail.com",
        "reason": "邮箱必须以 .ac.uk 结尾"
    }
}
```

**错误响应** (400 Bad Request - 不在白名单) - 开发模式:
```json
{
    "code": 400,
    "message": "邮箱后缀不在支持列表中",
    "error": "INVALID_EMAIL_DOMAIN",
    "details": {
        "email": "student@unknown.ac.uk",
        "reason": "该大学不在支持列表中"
    }
}
```

**统一响应** (200 OK) - 生产安全模式:
```json
{
    "code": 200,
    "message": "验证邮件已发送"
}
```
> 注意：在生产安全模式下，对于无效邮箱格式、非 `.ac.uk` 后缀、不在白名单的情况，统一返回此响应，不暴露具体错误原因，防止邮箱枚举攻击。

**错误响应** (409 Conflict):
```json
{
    "code": 409,
    "message": "该学生邮箱已被其他用户验证，每个邮箱在同一时间只能被一个用户使用",
    "error": "EMAIL_ALREADY_VERIFIED",
    "details": {
        "email": "student@bristol.ac.uk",
        "reason": "邮箱已被使用",
        "note": "如果认证已过期，邮箱可以被重新验证"
    }
}
```

**错误响应** (429 Too Many Requests):
```json
{
    "code": 429,
    "message": "请求过于频繁，请稍后再试",
    "error": "RATE_LIMIT_EXCEEDED",
    "retry_after": 60
}
```

#### 6.2.2 验证邮箱

**接口**: `GET /api/student-verification/verify/{token}`

**路径参数**:
- `token`: 验证令牌

**处理流程**:
1. 从Redis获取并验证令牌（使用原子操作GETDEL）
2. 验证成功后立即从Redis删除令牌（确保一次性使用）
3. 检查邮箱唯一性
4. 更新认证状态为verified
5. 设置过期时间

**响应** (200 OK):
```json
{
    "code": 200,
    "message": "验证成功",
    "data": {
        "verification_id": 12345,
        "status": "verified",
        "verified_at": "2024-01-15T10:30:00Z",
        "expires_at": "2025-10-01T00:00:00Z"
    }
}
```

**重要说明**：
- 验证成功后，令牌会**立即从Redis中删除**，无法再次使用
- 使用原子操作（GETDEL或Lua脚本）确保并发安全
- 即使验证过程中出现异常，令牌也会被删除，防止重复使用

**错误响应** (400 Bad Request):
```json
{
    "code": 400,
    "message": "验证令牌无效或已过期",
    "error": "INVALID_TOKEN"
}
```

**说明**：如果令牌已被使用（已从Redis删除），也会返回此错误。

**说明**：如果令牌已被使用（已从Redis删除），也会返回此错误。

#### 6.2.3 查询认证状态

**接口**: `GET /api/student-verification/status`

**响应** (200 OK):
```json
{
    "code": 200,
    "data": {
        "is_verified": true,
        "status": "verified",
        "university": {
            "id": 1,
            "name": "University of Bristol",
            "name_cn": "布里斯托大学"
        },
        "email": "student@bristol.ac.uk",
        "verified_at": "2024-01-15T10:30:00Z",
        "expires_at": "2026-10-01T00:00:00Z",
        "days_remaining": 28,
        "can_renew": true,
        "renewable_from": "2026-09-01T00:00:00Z",
        "email_locked": false
    }
}
```

**字段说明**：
- `email_locked`: 布尔值，表示邮箱是否被锁定（正在验证中）
  - `true`: 邮箱处于 pending 状态且未超过15分钟，被占用，其他用户不能使用
  - `false`: 邮箱未被占用或已过期，可以被使用
  - 用途：前端可以根据此字段提示用户"邮箱正在验证中"或"邮箱可用"
- `can_renew`: 布尔值，表示是否可以续期
  - `true`: 可以续期（过期前30天内）
  - `false`: 不能续期（距离过期超过30天）
- `days_remaining`: 整数，表示距离过期的剩余天数
  - 计算方式：`(expires_at - now).days`
  - 用途：前端可以显示"您的认证还有 28 天过期"
- `renewable_from`: 字符串（ISO 8601格式），表示从哪天开始可以续期（**强烈推荐**）
  - 计算方式：`expires_at - timedelta(days=30)`（过期前30天）
  - 用途：前端可以显示"您可以在 2026-09-01 开始续期"，提供更明确的用户提示
  - 如果 `can_renew` 为 `false`，此字段表示未来可以续期的日期
  - 如果 `can_renew` 为 `true`，此字段表示已经可以续期的日期（可能早于当前时间）
  - **实现示例**：
    ```python
    from datetime import timedelta, timezone
    
    now = datetime.now(timezone.utc)
    days_remaining = (verification.expires_at - now).days
    renewable_from = verification.expires_at - timedelta(days=30)
    can_renew = days_remaining <= 30
    ```

#### 6.2.4 更换邮箱（改绑）

**接口**: `POST /api/student-verification/change-email`

**说明**：已验证用户可以更换新的 `.ac.uk` 邮箱，需要重新验证新邮箱。

**请求体**:
```json
{
    "new_email": "newstudent@bristol.ac.uk"
}
```

**处理流程**：
1. **必须**：检查当前用户是否已有已验证的认证（状态必须为 `verified`）
   - 如果用户当前状态为 `pending` 或 `expired`，拒绝换绑请求
   - 原因：防止用户用 pending 邮箱抢占其他用户的 verified 邮箱
2. 验证新邮箱格式和 `.ac.uk` 后缀
3. 检查新邮箱是否已被其他用户使用（使用 `check_email_uniqueness` 函数）
4. 如果新邮箱可用，将旧认证状态更新为 `revoked`（立即释放旧邮箱）
5. 创建新的 pending 认证记录
6. 发送验证邮件到新邮箱

**实现示例**：
```python
@router.post("/change-email")
async def change_email(new_email: str, current_user: User, db: Session):
    # 1. 检查当前用户是否已有已验证的认证（必须为 verified 状态）
    current_verification = db.query(models.StudentVerification).filter(
        models.StudentVerification.user_id == current_user.id,
        models.StudentVerification.status == 'verified'  # 必须为 verified
    ).first()
    
    if not current_verification:
        raise HTTPException(
            status_code=400,
            detail={
                "code": 400,
                "error": "NO_VERIFIED_VERIFICATION",
                "message": "当前用户没有已验证的认证，无法更换邮箱"
            }
        )
    
    # 2. 验证新邮箱格式和 .ac.uk 后缀
    # ... 其他验证逻辑
    
    # 3. 检查新邮箱是否已被使用
    if not check_email_uniqueness(new_email, db, exclude_user_id=current_user.id):
        raise HTTPException(
            status_code=409,
            detail={
                "code": 409,
                "error": "EMAIL_ALREADY_VERIFIED",
                "message": "新邮箱已被其他用户验证"
            }
        )
    
    # 4. 撤销旧认证
    current_verification.status = 'revoked'
    current_verification.revoked_at = datetime.now(timezone.utc)
    current_verification.revoked_reason = "用户更换邮箱"
    
    # 5. 创建新认证记录
    # ...
```

**响应** (200 OK):
```json
{
    "code": 200,
    "message": "验证邮件已发送到新邮箱",
    "data": {
        "old_email": "oldstudent@bristol.ac.uk",
        "new_email": "newstudent@bristol.ac.uk",
        "verification_id": 12346,
        "university": {
            "id": 1,
            "name": "University of Bristol",
            "name_cn": "布里斯托大学"
        }
    }
}
```

**错误响应** (409 Conflict - 新邮箱已被使用):
```json
{
    "code": 409,
    "message": "新邮箱已被其他用户验证",
    "error": "EMAIL_ALREADY_VERIFIED",
    "details": {
        "new_email": "newstudent@bristol.ac.uk",
        "reason": "邮箱已被使用"
    }
}
```

**错误响应** (400 Bad Request - 用户未验证):
```json
{
    "code": 400,
    "message": "当前用户没有已验证的认证，无法更换邮箱",
    "error": "NO_VERIFIED_VERIFICATION"
}
```

**重要说明**：
- 更换邮箱时，旧邮箱会立即释放（状态更新为 `revoked`），可以被其他用户使用
- 新邮箱需要重新验证，验证流程与首次认证相同
- 更换邮箱后，旧认证的历史记录会保留在 `verification_history` 表中

#### 6.2.5 申请续期

**接口**: `POST /api/student-verification/renew`

**请求体**:
```json
{
    "email": "student@bristol.ac.uk"
}
```

**响应** (200 OK):
```json
{
    "code": 200,
    "message": "续期验证邮件已发送",
    "data": {
        "verification_id": 12345,
        "new_expires_at": "2026-10-01T00:00:00Z"
    }
}
```

**错误响应** (409 Conflict):
```json
{
    "code": 409,
    "message": "该学生邮箱已被其他用户验证，无法用于续期",
    "error": "EMAIL_ALREADY_VERIFIED",
    "details": {
        "email": "student@bristol.ac.uk",
        "reason": "邮箱已被其他用户使用"
    }
}
```

**说明**：
- 续期时，系统会检查邮箱是否被其他用户使用
- 如果邮箱属于当前用户（之前已验证过），允许续期
- **重要**：如果当前认证已经是 `expired` 状态，也允许同一用户重新验证并延长至下一个10月1日
  - 系统会删除旧的expired记录，创建新的verified记录
  - 过期时间设置为下一个10月1日
- 如果邮箱属于其他用户，返回409错误

#### 6.2.6 获取支持的大学列表

**接口**: `GET /api/student-verification/universities`

**查询参数**:
- `search`: 搜索关键词（可选）
- `page`: 页码（默认1）
- `page_size`: 每页数量（默认20）

**响应** (200 OK):
```json
{
    "code": 200,
    "data": {
        "total": 150,
        "page": 1,
        "page_size": 20,
        "items": [
            {
                "id": 1,
                "name": "University of Bristol",
                "name_cn": "布里斯托大学",
                "email_domain": "bristol.ac.uk"
            },
            ...
        ]
    }
}
```

### 6.3 管理接口（需要管理员权限）

#### 6.3.1 手动撤销认证

**接口**: `POST /api/admin/student-verification/{verification_id}/revoke`

**请求体**:
```json
{
    "reason_type": "user_request",  // 必填：撤销原因类型
    "reason_detail": "用户自行申请注销"  // 必填：撤销原因详情
}
```

**撤销原因类型**（`reason_type`，必填，下拉选择）：
- `user_request`: 用户自行申请注销
- `violation`: 涉嫌违规使用
- `account_hacked`: 账号被盗
- `other`: 其他（选择此项时，`reason_detail` 必须手输详细原因）

**处理流程**：
1. 查询认证记录
2. **必须**：验证撤销原因（`reason_type` 和 `reason_detail` 必填）
   - 如果 `reason_type` 为 `other`，`reason_detail` 不能为空
3. 更新状态为 `revoked`
4. 记录撤销时间和原因（`reason_type` + `reason_detail`）
5. **必须**：撤销后立即释放邮箱，允许其他用户使用（与过期释放机制一致）
6. **必须**：异步发送撤销通知邮件到用户邮箱（防止用户完全不知情）
   - 邮件中必须包含管理员填写的撤销原因

**错误响应** (400 Bad Request - 撤销原因未填写):
```json
{
    "code": 400,
    "message": "撤销原因必填",
    "error": "REVOKE_REASON_REQUIRED",
    "details": {
        "reason_type": "reason_type 和 reason_detail 都是必填字段",
        "reason_detail": "如果 reason_type 为 'other'，reason_detail 必须手输详细原因"
    }
}
```

**响应** (200 OK):
```json
{
    "code": 200,
    "message": "认证已撤销，邮箱已释放",
    "data": {
        "verification_id": 12345,
        "email": "student@bristol.ac.uk",
        "status": "revoked",
        "revoked_at": "2024-01-20T10:30:00Z",
        "revoked_reason_type": "user_request",
        "revoked_reason_detail": "用户自行申请注销",
        "email_released": true,
        "notification_sent": true
    }
}
```

**重要说明**：
- **撤销原因必填**：`reason_type` 和 `reason_detail` 都是必填字段，提升审计能力
- 撤销后邮箱立即释放，可以被其他用户使用
- 这与过期释放机制一致，确保邮箱资源的及时释放
- **必须发送撤销通知邮件**：通知用户其学生认证已被撤销，避免用户完全不知情
- 撤销记录会保留在数据库中，用于审计
- **审计闭环**：邮件中必须包含管理员填写的撤销原因，万一出现用户申诉，可以直接甩邮件记录

**撤销通知邮件内容**：
- 邮件主题：`您的学生身份已被注销`
- 邮件正文应包含：
  - 撤销时间
  - 撤销原因类型和详情（管理员填写的完整原因）
  - 说明：邮箱已释放，可以被其他用户使用
  - 如有疑问，请联系客服
  - **必须包含防钓鱼标识**：`此邮件为系统自动发送，请勿回复。如需帮助，请联系 support@yourcompany.com`

**实现示例**：
```python
from pydantic import BaseModel, validator

class RevokeRequest(BaseModel):
    reason_type: str  # 必填：user_request, violation, account_hacked, other
    reason_detail: str  # 必填：撤销原因详情
    
    @validator('reason_type')
    def validate_reason_type(cls, v):
        allowed_types = ['user_request', 'violation', 'account_hacked', 'other']
        if v not in allowed_types:
            raise ValueError(f'reason_type 必须是以下之一: {allowed_types}')
        return v
    
    @validator('reason_detail')
    def validate_reason_detail(cls, v, values):
        if not v or not v.strip():
            raise ValueError('reason_detail 不能为空')
        # 如果 reason_type 为 other，reason_detail 必须手输详细原因
        if values.get('reason_type') == 'other' and len(v.strip()) < 10:
            raise ValueError('reason_type 为 other 时，reason_detail 必须手输至少10个字符的详细原因')
        return v.strip()

@router.post("/admin/student-verification/{verification_id}/revoke")
async def revoke_verification(
    verification_id: int, 
    request: RevokeRequest,  # 使用 Pydantic 模型验证
    db: Session
):
    verification = db.query(models.StudentVerification).filter(
        models.StudentVerification.id == verification_id
    ).first()
    
    if not verification:
        raise HTTPException(status_code=404, detail="认证记录不存在")
    
    # 构建完整的撤销原因（类型 + 详情）
    full_reason = f"{request.reason_type}: {request.reason_detail}"
    
    # 更新状态
    verification.status = 'revoked'
    verification.revoked_at = datetime.now(timezone.utc)
    verification.revoked_reason = full_reason  # 存储完整原因
    db.commit()
    
    # **必须**：异步发送撤销通知邮件（包含管理员填写的撤销原因）
    send_revocation_notification_email.delay(
        email=verification.email,
        revoked_at=verification.revoked_at,
        reason_type=request.reason_type,
        reason_detail=request.reason_detail
    )
    
    return {
        "code": 200,
        "message": "认证已撤销，邮箱已释放",
        "data": {
            "verification_id": verification_id,
            "email": verification.email,
            "status": "revoked",
            "revoked_at": verification.revoked_at.isoformat(),
            "revoked_reason_type": request.reason_type,
            "revoked_reason_detail": request.reason_detail,
            "email_released": True,
            "notification_sent": True
        }
    }
```

#### 6.3.2 手动续期

**接口**: `POST /api/admin/student-verification/{verification_id}/extend`

**请求体**:
```json
{
    "new_expires_at": "2026-10-01T00:00:00Z",
    "reason": "特殊情况延期"
}
```

#### 6.3.3 管理大学列表

**接口**: `POST /api/admin/universities`

**接口**: `PUT /api/admin/universities/{id}`

**接口**: `DELETE /api/admin/universities/{id}`

---

## 7. 邮箱后缀管理

### 7.1 邮箱后缀匹配规则

#### 7.1.1 精确匹配
- `@bristol.ac.uk` → 布里斯托大学
- `@essex.ac.uk` → 埃塞克斯大学

#### 7.1.2 子域名匹配
- `@student.gla.ac.uk` → 格拉斯哥大学
- `@mail.ox.ac.uk` → 牛津大学

#### 7.1.3 通配符匹配
- `@*.cam.ac.uk` → 剑桥大学（支持所有子域名）
- `@*.ac.uk` → 通用英国大学后缀（备用匹配）

### 7.2 匹配优先级

1. **精确匹配** (优先级最高)
2. **子域名匹配**
3. **通配符匹配** (优先级最低)

### 7.3 匹配算法实现

#### 7.3.1 内存缓存优化版本（推荐）

**性能优化**：启动时将所有大学pattern加载到内存，使用Trie树或Aho-Corasick算法，性能提升10倍+

```python
from pyahocorasick import Automaton
from typing import Optional, Dict

class UniversityMatcher:
    """大学匹配器 - 使用Aho-Corasick算法，启动时加载到内存"""
    
    def __init__(self):
        self.automaton = Automaton()
        self.university_map: Dict[str, University] = {}
        self._initialized = False
    
    def initialize(self, db: Session):
        """
        启动时初始化，加载所有大学pattern到内存
        
        重要：此方法应在应用启动时（startup event）主动调用一次，避免并发初始化竞态。
        不要依赖 lazy init，否则高并发首次启动时会导致多次全表扫描。
        """
        if self._initialized:
            return
        
        # 使用锁防止并发初始化（双重检查锁定模式）
        import threading
        if not hasattr(self, '_lock'):
            self._lock = threading.Lock()
        
        with self._lock:
            # 双重检查：再次检查是否已初始化
            if self._initialized:
                return
            
            universities = db.query(University).filter(
                University.is_active == True
            ).all()
        
        for uni in universities:
            pattern = uni.domain_pattern.replace('@', '').replace('*', '')
            # 添加精确匹配
            self.automaton.add_word(pattern, (uni.id, 'exact', pattern))
            self.university_map[f"{uni.id}:exact:{pattern}"] = uni
            
            # 如果是通配符模式，添加所有可能的子域名匹配
            if '*' in uni.domain_pattern:
                base_pattern = pattern.replace('*', '')
                # 添加基础模式匹配
                self.automaton.add_word(base_pattern, (uni.id, 'wildcard', base_pattern))
                self.university_map[f"{uni.id}:wildcard:{base_pattern}"] = uni
        
        self.automaton.make_automaton()
        self._initialized = True
        logger.info(f"大学匹配器初始化完成，加载了 {len(universities)} 所大学")
    
    def match(self, email: str) -> Optional[University]:
        """
        匹配大学（内存匹配，无需数据库查询）
        
        性能：O(n) 其中n是邮箱域名长度，比多次DB查询快10倍+
        """
        domain = email.split('@')[1].lower() if '@' in email else ''
        
        # 检查是否以 .ac.uk 结尾
        if not domain.endswith('.ac.uk'):
            raise ValueError("只有以 .ac.uk 结尾的邮箱才能验证学生身份")
        
        # 1. 精确匹配（最高优先级）
        exact_key = f"exact:{domain}"
        for key, uni in self.university_map.items():
            if key.endswith(exact_key):
                return uni
        
        # 2. 子域名匹配（从右到左）
        domain_parts = domain.split('.')
        for i in range(len(domain_parts)):
            subdomain = '.'.join(domain_parts[i:])
            subdomain_key = f"exact:{subdomain}"
            for key, uni in self.university_map.items():
                if key.endswith(subdomain_key):
                    return uni
        
        # 3. 通配符匹配（使用Aho-Corasick）
        matches = []
        for end_index, (uni_id, match_type, pattern) in self.automaton.iter(domain):
            matches.append((end_index, uni_id, match_type, pattern))
        
        if matches:
            # 选择最长匹配（最具体）
            matches.sort(key=lambda x: len(x[3]), reverse=True)
            uni_id, match_type, pattern = matches[0][1], matches[0][2], matches[0][3]
            key = f"{uni_id}:{match_type}:{pattern}"
            return self.university_map.get(key)
        
        return None

# 全局单例
_university_matcher = UniversityMatcher()

def match_university_by_email(email: str, db: Session = None) -> Optional[University]:
    """
    根据邮箱地址匹配大学（使用内存缓存）
    
    重要约束：只有以 `.ac.uk` 结尾的邮箱才能验证学生身份
    
    性能优化：
    - 启动时加载所有pattern到内存
    - 使用Aho-Corasick算法，一次匹配完成
    - 避免多次数据库查询，性能提升10倍+
    """
    # 确保已初始化
    if not _university_matcher._initialized and db:
        _university_matcher.initialize(db)
    
    return _university_matcher.match(email)
```

#### 7.3.2 传统DB查询版本（备用）

如果内存有限或需要实时更新，可以使用传统DB查询方式：

```python
def match_university_by_email_db(email: str, db: Session) -> Optional[University]:
    """
    根据邮箱地址匹配大学（数据库查询版本）
    
    注意：此版本需要多次DB查询，性能较低，建议使用内存缓存版本
    """
    domain = email.split('@')[1].lower()
    
    # 检查是否以 .ac.uk 结尾
    if not domain.endswith('.ac.uk'):
        raise ValueError("只有以 .ac.uk 结尾的邮箱才能验证学生身份")
    
    # 1. 精确匹配
    university = db.query(University).filter(
        University.domain_pattern == f"@{domain}",
        University.is_active == True
    ).first()
    if university:
        return university
    
    # 2. 子域名匹配（从右到左匹配）
    domain_parts = domain.split('.')
    for i in range(len(domain_parts)):
        pattern = '@' + '.'.join(domain_parts[i:])
        university = db.query(University).filter(
            University.domain_pattern == pattern,
            University.is_active == True
        ).first()
        if university:
            return university
    
    # 3. 通配符匹配
    universities = db.query(University).filter(
        University.is_active == True
    ).all()
    
    for uni in universities:
        pattern = uni.domain_pattern.replace('@', '').replace('*', '.*')
        if re.match(f"^{pattern}$", domain):
            return uni
    
    return None
```

### 7.4 常见英国大学邮箱后缀列表

| 大学名称 | 中文名称 | 邮箱后缀 | 匹配模式 |
|---------|---------|---------|---------|
| University of Bristol | 布里斯托大学 | bristol.ac.uk | @bristol.ac.uk |
| University of Essex | 埃塞克斯大学 | essex.ac.uk | @essex.ac.uk |
| University of Glasgow | 格拉斯哥大学 | student.gla.ac.uk | @student.gla.ac.uk |
| University of Oxford | 牛津大学 | ox.ac.uk | @*.ox.ac.uk |
| University of Cambridge | 剑桥大学 | cam.ac.uk | @*.cam.ac.uk |
| Imperial College London | 帝国理工学院 | imperial.ac.uk | @imperial.ac.uk |
| London School of Economics | 伦敦政治经济学院 | lse.ac.uk | @lse.ac.uk |
| University College London | 伦敦大学学院 | ucl.ac.uk | @ucl.ac.uk |
| King's College London | 伦敦国王学院 | kcl.ac.uk | @kcl.ac.uk |
| University of Manchester | 曼彻斯特大学 | manchester.ac.uk | @manchester.ac.uk |
| University of Edinburgh | 爱丁堡大学 | ed.ac.uk | @*.ed.ac.uk |
| University of Birmingham | 伯明翰大学 | bham.ac.uk | @bham.ac.uk |
| University of Leeds | 利兹大学 | leeds.ac.uk | @leeds.ac.uk |
| University of Liverpool | 利物浦大学 | liverpool.ac.uk | @liverpool.ac.uk |
| University of Sheffield | 谢菲尔德大学 | sheffield.ac.uk | @sheffield.ac.uk |
| University of Nottingham | 诺丁汉大学 | nottingham.ac.uk | @nottingham.ac.uk |
| University of Southampton | 南安普顿大学 | soton.ac.uk | @soton.ac.uk |
| University of Warwick | 华威大学 | warwick.ac.uk | @warwick.ac.uk |
| University of York | 约克大学 | york.ac.uk | @york.ac.uk |
| Durham University | 杜伦大学 | durham.ac.uk | @durham.ac.uk |

---

## 8. 有效期管理

### 8.1 过期时间计算

#### 8.1.1 首次认证
- 如果当前日期在8月1日之前：过期时间为当年10月1日 00:00:00 UTC（如果已经过了就跳到下一年）
- 如果当前日期在8月1日~10月1日（包含）之间：过期时间为次年10月1日 00:00:00 UTC
  - **重要说明**：英国大学本科新生通常8月中下旬拿到A-Level结果、确认offer，很多学生8月底9月初就飞英国了
  - 提前到8月1日可以覆盖这些早期用户，避免8月15日注册的用户发现"要等到9月1日才能续期"的困惑
  - 参考业界通行做法：Notion、Figma、Spotify 学生优惠都采用类似策略
- 如果当前日期在10月1日之后：过期时间为次年10月1日 00:00:00 UTC

#### 8.1.2 续期认证
- 过期时间统一设置为下一个10月1日 00:00:00 UTC

#### 8.1.3 实现代码

```python
from datetime import datetime, timezone

def calculate_expires_at(verified_at: datetime) -> datetime:
    """
    计算认证过期时间（终极优化版本）
    
    规则（业界通行做法，参考 Notion、Figma、Spotify 学生优惠）：
    - 如果验证日期在8月1日~10月1日（含）之间，过期时间为次年10月1日
      - 原因：英国 A-Level 放榜日在8月中旬，大量新生8月就想认证
      - 8月1日~10月1日期间认证的，全部给到下一年10月1日
    - 其他时间认证日期，往最近的下一个10月1日靠
    
    优化说明：
    - 原规则：9月1日~10月1日验证 → 次年10月1日过期
    - 新规则：8月1日~10月1日验证 → 次年10月1日过期
    - 这样8月15日注册的用户也能享受到完整一学年，用户好感度更高
    """
    # 英国 A-Level 放榜日在 8 月中旬，大量新生 8 月就想认证
    if (verified_at.month == 8 and verified_at.day >= 1) or \
       (verified_at.month == 9) or \
       (verified_at.month == 10 and verified_at.day == 1):
        # 8月1日 ~ 10月1日期间认证的，全部给到下一年10月1日
        return datetime(verified_at.year + 1, 10, 1, tzinfo=timezone.utc)
    else:
        # 其他时间认证日期，往最近的下一个10月1日靠
        next_oct = datetime(
            verified_at.year if verified_at.month < 10 else verified_at.year + 1,
            10, 1, tzinfo=timezone.utc
        )
        return next_oct

def get_next_expiry_date() -> datetime:
    """获取下一个10月1日"""
    today = datetime.now(timezone.utc)
    return calculate_expires_at(today)
```

### 8.2 提醒机制

#### 8.2.1 提醒时间点
- **30天前**: 首次提醒
- **7天前**: 二次提醒
- **1天前**: 最后提醒
- **过期当天**: 过期通知（可选）

#### 8.2.2 提醒任务配置

```python
# Celery定时任务配置
from celery.schedules import crontab

CELERY_BEAT_SCHEDULE = {
    'check-expiring-verifications-30-days': {
        'task': 'app.celery_tasks.send_expiry_reminders',
        'schedule': crontab(hour=2, minute=0),  # 每天凌晨2点
        'kwargs': {'days_before': 30}
    },
    'check-expiring-verifications-7-days': {
        'task': 'app.celery_tasks.send_expiry_reminders',
        'schedule': crontab(hour=2, minute=5),
        'kwargs': {'days_before': 7}
    },
    'check-expiring-verifications-1-day': {
        'task': 'app.celery_tasks.send_expiry_reminders',
        'schedule': crontab(hour=2, minute=10),
        'kwargs': {'days_before': 1}
    },
    'process-expired-verifications': {
        'task': 'app.celery_tasks.process_expired_verifications',
        'schedule': crontab(minute=0),  # 每小时执行一次，实时处理过期
    },
}
```

### 8.3 批量过期处理（兜底任务）

**重要说明**：此定时任务仅作为兜底和批量处理，不用于实现"立即释放"机制。

**真正的"立即释放"机制**：
- 在 `check_email_uniqueness` 函数中实现
- 每次 `submit`、`verify`、`renew`、`change-email` 操作时，都会实时检查记录是否已过期
- 如果发现已过期，立即删除旧记录并标记为 expired，实现真正的"立即释放"

**定时任务的作用**：
- 批量处理可能遗漏的过期记录（兜底机制）
- 批量更新过期记录的状态为 expired（用于统计和审计）
- 清理历史数据

**注意**：即使定时任务不运行，过期邮箱也会在下次操作时被实时释放。

```python
@celery_app.task
def process_expired_verifications():
    """
    批量处理过期的认证（兜底任务）
    
    **重要说明**：此任务仅作为兜底和批量处理，不用于实现"立即释放"机制。
    真正的"立即释放"在 check_email_uniqueness 函数中实现，每次操作时实时检查过期。
    
    执行频率：每小时执行一次
    
    作用：
    - 批量处理可能遗漏的过期记录（兜底机制）
    - 批量更新过期记录的状态为 expired（用于统计和审计）
    - 清理历史数据
    
    幂等性保证：
    - 只处理状态为 'verified' 且已过期的记录
    - 如果因为宕机漏跑，下次执行时只会处理仍过期的记录
    - 已处理为 'expired' 状态的记录不会重复处理
    - 确保任务可以安全地重复执行
    
    注意：即使此任务不运行，过期邮箱也会在下次操作时被实时释放（通过 check_email_uniqueness）
    """
    from app.database import SessionLocal
    from app import models
    
    db = SessionLocal()
    try:
        now = datetime.now(timezone.utc)
        
        # 查询所有已过期但状态仍为verified的记录（幂等性：只处理verified状态）
        # 注意：expires_at 是 TIMESTAMP 类型，使用 datetime 比较，而不是 date
        expired_verifications = db.query(models.StudentVerification).filter(
            models.StudentVerification.status == 'verified',
            models.StudentVerification.expires_at <= now
        ).all()
        
        for verification in expired_verifications:
            # 更新状态
            verification.status = 'expired'
            verification.updated_at = datetime.now(timezone.utc)
            
            # 记录历史
            history = models.VerificationHistory(
                user_id=verification.user_id,
                university_id=verification.university_id,
                email=verification.email,
                action='expired',
                previous_status='verified',
                new_status='expired'
            )
            db.add(history)
        
        db.commit()
        logger.info(f"处理了 {len(expired_verifications)} 个过期认证")
        
    except Exception as e:
        db.rollback()
        logger.error(f"处理过期认证失败: {e}")
        raise
    finally:
        db.close()
```

---

## 9. 安全机制

### 9.1 令牌安全

#### 9.1.1 令牌生成
- 使用加密安全的随机数生成器（`secrets.token_urlsafe()`）
- 令牌长度：约64字符（48字节的URL安全编码）
- 令牌存储：使用 Redis 存储，TTL 15分钟，自动过期
- **注意**：令牌为加密安全随机字符串，不包含时间戳或邮箱哈希值，安全性由随机性和 Redis TTL 保证

```python
import secrets
import hashlib
from datetime import datetime, timedelta, timezone

def generate_verification_token(email: str) -> tuple[str, datetime]:
    """
    生成验证令牌
    
    使用 secrets.token_urlsafe() 生成URL安全的令牌
    长度48字节，提供足够的熵（约384位）
    
    返回:
        (token, token_expires_at): 令牌和过期时间
    """
    import secrets
    
    # 使用 token_urlsafe 生成URL安全的令牌（更简洁，熵值足够）
    token = secrets.token_urlsafe(48)  # 48字节，约64字符URL安全编码
    
    # 统一转小写存储邮箱
    email_lower = email.strip().lower()
    
    # 计算令牌过期时间（15分钟后）
    now = datetime.now(timezone.utc)
    token_expires_at = now + timedelta(minutes=15)
    
    # 存储到Redis，使用业务前缀，15分钟过期
    redis_client.setex(
        f"student_verification:token:{token}",  # 业务前缀，便于管理和监控
        900,  # 15分钟 = 900秒
        email_lower
    )
    
    return token, token_expires_at
```

**重要说明**：
- 函数返回 `(token, token_expires_at)` 元组
- `token_expires_at` 必须保存到数据库的 `token_expires_at` 字段
- 在检查 pending 状态时，使用 `token_expires_at` 而不是 `created_at` 来判断是否过期
- 这样可以避免邮件发送延迟导致的判断错误

#### 9.1.2 令牌验证
- 一次性使用（验证成功后立即从Redis删除）
- 15分钟有效期
- 防止重放攻击

**重要**：验证成功后立即从Redis删除令牌，确保：
1. 令牌只能使用一次
2. 防止令牌被重复使用
3. 及时释放Redis存储空间

#### 9.1.3 令牌存储架构说明

**Redis + DB 双存设计**：

系统采用 Redis + DB 双存 token 的架构，两者职责不同：

1. **Redis 存储（主要验证流程）**：
   - 存储位置：`student_verification:token:{token}`
   - 存储内容：邮箱地址（小写）
   - TTL：15分钟，自动过期
   - 用途：快速验证流程，一次性使用（GETDEL 原子操作）
   - 优势：高性能、自动过期、原子操作保证并发安全

2. **DB 存储（审计和管理）**：
   - 存储位置：`student_verifications.verification_token` 字段
   - 存储内容：验证令牌（用于审计）
   - 过期时间：`token_expires_at` 字段记录
   - 用途：
     - 后台管理：管理员可以查看验证令牌历史
     - 审计日志：记录完整的验证流程
     - 手动重发：如果需要手动重发验证邮件，可以从 DB 获取令牌
     - 问题排查：当验证出现问题时，可以通过 DB 记录排查

**重要说明**：
- Redis 中的 token 是验证流程的主要数据源，验证时优先从 Redis 获取
- DB 中的 token 主要用于审计和管理，不参与实际验证流程
- 如果 Redis 和 DB 中的 token 不一致，以 Redis 为准（因为 Redis 负责实际验证）
- 删除或重构代码时，不要误以为 DB 中的 `verification_token` 字段没用，它用于审计和管理

```python
def verify_token(token: str, email: str) -> bool:
    """
    验证令牌
    
    流程：
    1. 从Redis获取令牌
    2. 验证令牌和邮箱是否匹配
    3. 验证成功后立即删除Redis中的令牌（原子操作）
    """
    # 统一转小写比较
    email_lower = email.strip().lower()
    
    token_key = f"student_verification:token:{token}"  # 使用业务前缀
    
    # 使用GETDEL原子操作（Redis 6.2+），获取并删除令牌
    # 这样可以确保即使并发请求，令牌也只能被使用一次
    try:
        # Redis 6.2+ 支持GETDEL原子操作
        stored_email = redis_client.getdel(token_key)
    except AttributeError:
        # Redis版本不支持GETDEL，使用Lua脚本实现原子操作
        lua_script = """
        local value = redis.call('GET', KEYS[1])
        if value then
            redis.call('DEL', KEYS[1])
        end
        return value
        """
        stored_email = redis_client.eval(lua_script, 1, token_key)
    
    if not stored_email:
        # 令牌不存在或已被使用
        return False
    
    # 验证邮箱是否匹配（统一转小写比较）
    stored_email_str = stored_email.decode('utf-8') if isinstance(stored_email, bytes) else stored_email
    if stored_email_str.lower() != email_lower:
        return False
    
    # 令牌已从Redis删除（通过GETDEL或Lua脚本），确保一次性使用
    logger.info(f"验证令牌成功，已从Redis删除: {email}")
    
    return True
```

**原子操作说明**：
- 使用 `GETDEL` 命令（Redis 6.2+）或 Lua 脚本实现原子操作
- 确保获取和删除在同一事务中完成，防止并发问题
- 即使多个请求同时验证同一令牌，也只有一个会成功

### 9.2 限流保护

#### 9.2.1 接口限流
- 提交认证：5次/分钟/IP
- 验证令牌：10次/分钟/IP
- 查询状态：60次/分钟/用户

```python
from slowapi import Limiter
from slowapi.util import get_remote_address

limiter = Limiter(key_func=get_remote_address)

@router.post("/submit")
@limiter.limit("5/minute")
async def submit_verification(request: Request, ...):
    ...
```

### 9.3 邮箱唯一性约束

#### 9.3.1 全局唯一性检查规则
**重要规则：同一个学生邮箱在同一时间只能被一个用户验证**

**过期释放机制**：
- 认证过期后，邮箱立即可以被其他用户重新验证
- 原因：学生可能毕业、转学，邮箱可能被回收或重新分配
- 释放时机：过期后立即释放

系统在以下时机检查邮箱唯一性：
1. **提交认证申请时**：检查邮箱是否已被其他用户验证（仅检查有效和未过期的记录）
2. **验证令牌时**：再次检查邮箱唯一性（防止并发验证）

```python
from datetime import datetime, timedelta, timezone

def check_email_uniqueness(email: str, db: Session, exclude_user_id: int = None) -> bool:
    """
    检查邮箱是否已被使用
    
    重要：邮箱统一转小写存储和比较，确保大小写不敏感
    
    **实时过期检查**：此函数会在每次调用时实时检查记录是否已过期，实现"立即释放"机制。
    定时任务 process_expired_verifications 仅作为兜底和批量处理，不依赖它来实现立即释放。
    
    规则：
    1. verified状态的记录：实时检查是否已过期
       - 如果已过期：立即删除旧记录并标记为expired，允许新验证（实现立即释放）
       - 如果未过期：阻止新验证
    2. expired状态的记录：已过期，允许重新验证（删除旧记录）
    3. pending状态的记录：使用 token_expires_at 判断（不是 created_at）
       - token_expires_at 未过期：阻止新验证（邮箱被占用）
       - token_expires_at 已过期：允许覆盖（验证令牌已过期，删除旧记录）
    4. revoked状态的记录：撤销后立即释放邮箱，允许重新验证（删除旧记录）
       - 注意：撤销后邮箱立即释放，不检查过期时间（与过期释放机制一致）
    
    返回:
        True: 邮箱可用
        False: 邮箱已被使用
    """
    
    # 统一转小写，确保大小写不敏感
    email = email.strip().lower()
    
    query = db.query(models.StudentVerification).filter(
        models.StudentVerification.email == email
    )
    
    # 如果提供了用户ID，排除该用户的记录（用于续期场景）
    if exclude_user_id:
        query = query.filter(models.StudentVerification.user_id != exclude_user_id)
    
    existing = query.order_by(models.StudentVerification.created_at.desc()).first()
    
    if not existing:
        return True
    
    now = datetime.now(timezone.utc)
    
    # 检查状态
    if existing.status == 'verified':
        # verified状态：实时检查是否已过期（实现立即释放）
        if existing.expires_at and existing.expires_at < now:
            # 已过期，立即删除旧记录并标记为expired，允许新验证
            logger.info(f"邮箱 {email} 已过期（实时检查），立即释放并允许重新验证")
            # 记录历史
            history = models.VerificationHistory(
                user_id=existing.user_id,
                university_id=existing.university_id,
                email=existing.email,
                action='expired',
                previous_status='verified',
                new_status='expired'
            )
            db.add(history)
            # 更新状态为expired（保留记录用于审计）
            existing.status = 'expired'
            existing.updated_at = now
            db.commit()
            # 删除记录，释放邮箱
            db.delete(existing)
            db.commit()
            return True
        # 未过期，阻止新验证
        return False
    
    elif existing.status == 'expired':
        # expired状态：已过期，允许重新验证
        logger.info(f"邮箱 {email} 已过期，允许重新验证")
        db.delete(existing)
        db.commit()
        return True
    
    elif existing.status == 'pending':
        # pending状态：使用 token_expires_at 判断（不是 created_at）
        # 原因：created_at 是记录创建时间，如果邮件发送延迟，会导致判断错误
        # token_expires_at = created_at + 15分钟，准确反映令牌过期时间
        token_expires_at = existing.token_expires_at or (existing.created_at + timedelta(minutes=15))
        
        if token_expires_at < now:
            # token已过期，允许覆盖
            logger.info(f"邮箱 {email} 的pending记录token已过期（token_expires_at={token_expires_at}），允许覆盖")
            db.delete(existing)
            db.commit()
            return True
        # token未过期，邮箱被占用
        logger.info(f"邮箱 {email} 处于pending状态，token未过期（token_expires_at={token_expires_at}），阻止新验证")
        return False
    
    elif existing.status == 'revoked':
        # revoked状态：撤销后立即释放邮箱，允许重新验证
        # 注意：撤销后邮箱立即释放，不检查过期时间（与过期释放机制一致）
        logger.info(f"邮箱 {email} 的revoked记录已释放，允许重新验证")
        db.delete(existing)
        db.commit()
        return True
    
    # 理论上不应该到达这里，但为了代码完整性，返回False
    logger.warning(f"未知的认证状态: {existing.status}, 邮箱: {email}")
    return False
```

#### 9.3.2 应用层唯一性约束
**注意**：邮箱唯一性约束在应用层实现，不在数据库层面设置UNIQUE约束。

**原因**：
- 需要支持过期后的邮箱被其他用户重新使用
- 数据库的UNIQUE约束无法区分过期时间，会永久阻止邮箱重用
- 应用层可以灵活判断过期时间，实现过期后立即释放机制

**实现方式**：
- 在提交认证和验证令牌时，通过应用层逻辑检查邮箱唯一性
- 查询时过滤掉已过期的记录
- 如果发现已过期的记录，自动删除旧记录，允许新验证

#### 9.3.3 并发处理
使用数据库事务和行锁防止并发验证同一邮箱：

```python
from sqlalchemy import select
from sqlalchemy.orm import with_for_update
from datetime import datetime, timedelta, timezone

def submit_verification_with_lock(email: str, user_id: int, db: Session):
    """
    使用数据库行锁提交认证申请（支持过期后立即释放）
    """
    now = datetime.now(timezone.utc)
    
    # 使用SELECT FOR UPDATE锁定邮箱记录
    existing = db.execute(
        select(models.StudentVerification)
        .where(models.StudentVerification.email == email.lower())
        .with_for_update(nowait=True)
    ).scalar_one_or_none()
    
    if existing:
        # 检查是否可以释放（已过期）
        can_release = False
        
        if existing.status == 'expired':
            # expired状态：已过期，允许释放
            can_release = True
        elif existing.status == 'verified':
            # verified状态：检查是否已过期
            if existing.expires_at and existing.expires_at < now:
                can_release = True
        elif existing.status == 'revoked':
            # revoked状态：检查是否已过期
            if existing.expires_at and existing.expires_at < now:
                can_release = True
        elif existing.status == 'pending':
            # pending状态：超过15分钟可以覆盖（验证令牌已过期）
            if existing.created_at < now - timedelta(minutes=15):
                can_release = True
            # pending状态未超过15分钟，邮箱被占用，不能释放
        
        if can_release:
            # 删除旧记录，允许新验证
            logger.info(f"邮箱 {email} 的旧记录已过期，删除并允许新验证")
            db.delete(existing)
        else:
            # 邮箱仍在使用中，阻止新验证
            raise EmailAlreadyVerifiedError("邮箱已被使用")
    
    # 创建新记录
    verification = models.StudentVerification(
        user_id=user_id,
        email=email.lower(),
        ...
    )
    db.add(verification)
    db.commit()
```

### 9.4 邮箱枚举防护

#### 9.4.1 统一响应策略

为了防止通过响应时间或错误信息枚举邮箱，系统采用以下安全策略：

**策略说明**：
- **对于已使用的邮箱**：返回明确的错误信息（409 Conflict），因为邮箱唯一性约束是业务规则，需要明确告知用户
- **对于无效的邮箱格式、非 `.ac.uk` 后缀、不在白名单**：在生产安全模式下，统一返回 `200 { "message": "验证邮件已发送" }`，不暴露具体错误原因

**环境配置**：
- **开发/内部环境**：使用详细错误码模式，方便调试和开发
- **生产环境**：使用安全模式，统一响应，防止邮箱枚举攻击

**配置方式**：
```python
# 环境变量控制
SECURITY_MODE = os.getenv("SECURITY_MODE", "production")  # development 或 production

# 在提交认证接口中使用
if SECURITY_MODE == "production":
    # 生产模式：统一响应
    if not is_valid_email_format(email) or not email.endswith('.ac.uk') or not university:
        return {"message": "验证邮件已发送"}  # 统一响应，不暴露原因
else:
    # 开发模式：详细错误码
    if not is_valid_email_format(email):
        raise InvalidEmailFormatError(...)
    if not email.endswith('.ac.uk'):
        raise InvalidEmailSuffixError(...)
    if not university:
        raise InvalidEmailDomainError(...)
```

```python
async def submit_verification(email: str):
    """
    提交认证申请
    
    安全措施：
    1. 统一响应时间（防止时间攻击）
    2. 统一响应内容（防止邮箱枚举）
    """
    import time
    start_time = time.time()
    
    # 验证邮箱格式
    if not is_valid_email_format(email):
        # 延迟响应，统一时间
        elapsed = time.time() - start_time
        if elapsed < 1.0:
            time.sleep(1.0 - elapsed)
        return {"message": "验证邮件已发送"}  # 不透露邮箱是否有效
    
    # 检查邮箱后缀
    university = match_university_by_email(email, db)
    if not university:
        elapsed = time.time() - start_time
        if elapsed < 1.0:
            time.sleep(1.0 - elapsed)
        return {"message": "验证邮件已发送"}  # 统一响应
    
    # 统一转小写存储
    email_lower = email.strip().lower()
    
    # 发送邮件（异步，不阻塞）
    # 注意：邮件发送失败后会进入死信队列，支持人工审核和手动重试
    send_verification_email.delay(email_lower, university.id)
    
    # 统一响应
    elapsed = time.time() - start_time
    if elapsed < 1.0:
        time.sleep(1.0 - elapsed)
    
    return {"message": "验证邮件已发送"}
```

### 9.4 审计日志

#### 9.4.1 记录内容
- 用户ID
- 操作类型
- IP地址
- User-Agent
- 时间戳
- 操作结果

#### 9.4.2 日志脱敏

**重要**：为了保护用户隐私，避免日志泄露敏感信息，系统应对日志中的邮箱地址进行脱敏处理。

**脱敏规则**：
- 邮箱格式：`st****@bristol.ac.uk`（保留前2个字符，中间用 `****` 替代，保留域名）
- 示例：
  - `student@bristol.ac.uk` → `st****@bristol.ac.uk`
  - `john.doe@oxford.ac.uk` → `jo****@oxford.ac.uk`
  - `a@bristol.ac.uk` → `a****@bristol.ac.uk`（如果用户名少于2个字符，只保留1个）

**实现示例**：
```python
def mask_email(email: str) -> str:
    """
    邮箱脱敏：保留前2个字符，中间用****替代，保留域名
    """
    if '@' not in email:
        return email
    
    local_part, domain = email.split('@', 1)
    if len(local_part) <= 2:
        masked_local = local_part[0] + '****' if len(local_part) > 0 else '****'
    else:
        masked_local = local_part[:2] + '****'
    
    return f"{masked_local}@{domain}"

# 在日志记录中使用
logger.info(f"用户提交认证申请: {mask_email(email)}")
logger.info(f"AUDIT: {json.dumps({**audit_log, 'email': mask_email(email)})}")
```

**注意**：
- 审计日志中的邮箱应统一进行脱敏处理
- 数据库中的邮箱保持原文存储（用于业务逻辑）
- 日志脱敏不影响业务功能，仅用于日志输出

#### 9.4.3 邮件防钓鱼标识

**重要**：在所有验证/提醒/撤销邮件最底部必须添加防钓鱼标识，大幅降低用户被钓鱼邮件欺骗的概率。

**防钓鱼标识格式**：
```
此邮件为系统自动发送，请勿回复。如需帮助，请联系 support@yourcompany.com
```

**实现要求**：
- 所有邮件模板（验证邮件、提醒邮件、撤销通知邮件）都必须包含此标识
- 使用灰色小字显示（`color: #999; font-size: 12px;`）
- 放在邮件最底部，用分隔线（`<hr>`）与正文分开

**邮件模板示例（包含防钓鱼标识）**：
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>学生邮箱验证</title>
</head>
<body>
    <h2>学生邮箱验证</h2>
    <p>您好，</p>
    <p>您正在验证的邮箱是：<strong>student@bristol.ac.uk</strong></p>
    <p>请点击以下链接完成验证：</p>
    <p>
        <a href="https://yourdomain.com/verify?token={{token}}&email={{masked_email}}">
            点击验证邮箱
        </a>
    </p>
    <p><strong>此验证链接15分钟内有效</strong>，过期后请重新申请。</p>
    <p>如果这不是您的操作，请忽略此邮件。</p>
    
    <!-- 分隔线 -->
    <hr style="border: none; border-top: 1px solid #eee; margin: 30px 0;">
    
    <!-- 防钓鱼标识（必须包含） -->
    <p style="color: #999; font-size: 12px; text-align: center;">
        此邮件为系统自动发送，请勿回复。如需帮助，请联系 support@yourcompany.com
    </p>
</body>
</html>
```

**实现示例**：
```python
def get_email_footer() -> str:
    """
    获取邮件底部防钓鱼标识（所有邮件模板统一使用）
    """
    return """
    <hr style="border: none; border-top: 1px solid #eee; margin: 30px 0;">
    <p style="color: #999; font-size: 12px; text-align: center;">
        此邮件为系统自动发送，请勿回复。如需帮助，请联系 support@yourcompany.com
    </p>
    """

def send_verification_email(email: str, token: str, university_name: str):
    """
    发送验证邮件（包含防钓鱼措施）
    """
    # 邮箱脱敏（用于链接参数）
    masked_email = mask_email(email)  # st****@bristol.ac.uk
    
    # 构建验证链接（包含邮箱参数）
    verification_url = f"https://yourdomain.com/verify?token={token}&email={masked_email}"
    
    # 邮件主题
    subject = f"验证您的{university_name}学生邮箱"
    
    # 邮件正文（HTML格式）
    html_body = f"""
    <!DOCTYPE html>
    <html>
    <body>
        <h2>学生邮箱验证</h2>
        <p>您好，</p>
        <p>您正在验证的邮箱是：<strong>{email}</strong></p>
        <p>请点击以下链接完成验证：</p>
        <p><a href="{verification_url}">点击验证邮箱</a></p>
        <p><strong>此验证链接15分钟内有效</strong>，过期后请重新申请。</p>
        <p>如果这不是您的操作，请忽略此邮件。</p>
        {get_email_footer()}
    </body>
    </html>
    """
    
    # 发送邮件
    send_email(email, subject, html_body)
```

**安全说明**：
- 此标识能大幅降低用户被钓鱼邮件欺骗的概率
- 真实案例：某大厂没加这行，被仿冒邮件骗走几千个学生账号
- 几乎零成本但效果极好，必须包含在所有邮件模板中

```python
def log_verification_action(
    user_id: int,
    action: str,
    ip_address: str,
    user_agent: str,
    success: bool,
    details: dict = None
):
    """
    记录认证操作审计日志
    """
    audit_log = {
        "user_id": user_id,
        "action": action,
        "ip_address": ip_address,
        "user_agent": user_agent,
        "success": success,
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "details": details or {}
    }
    
    # 写入日志文件或数据库
    logger.info(f"AUDIT: {json.dumps(audit_log)}")
```

---

## 10. 错误处理

### 10.1 错误码定义

| 错误码 | HTTP状态码 | 说明 |
|-------|-----------|------|
| `INVALID_EMAIL_FORMAT` | 400 | 邮箱格式不正确 |
| `INVALID_EMAIL_SUFFIX` | 400 | 邮箱不是以 `.ac.uk` 结尾（只有 `.ac.uk` 结尾的邮箱才能验证学生身份） |
| `INVALID_EMAIL_DOMAIN` | 400 | 邮箱后缀不在支持列表中（邮箱以 `.ac.uk` 结尾，但不在大学白名单中） |
| `EMAIL_ALREADY_VERIFIED` | 409 | 该学生邮箱已被其他用户验证（未过期的记录会阻止新验证，过期后可以重新验证；pending状态未超过15分钟也会阻止） |
| `VERIFICATION_EXISTS` | 409 | 当前用户已存在待验证或已验证的认证 |
| `INVALID_TOKEN` | 400 | 验证令牌无效或已过期 |
| `TOKEN_EXPIRED` | 400 | 验证令牌已过期 |
| `VERIFICATION_EXPIRED` | 410 | 认证已过期 |
| `VERIFICATION_REVOKED` | 403 | 认证已被撤销 |
| `RATE_LIMIT_EXCEEDED` | 429 | 请求过于频繁 |
| `EMAIL_SEND_FAILED` | 500 | 邮件发送失败 |
| `DATABASE_ERROR` | 500 | 数据库错误 |
| `INTERNAL_ERROR` | 500 | 内部服务器错误 |

### 10.2 错误响应格式

```json
{
    "code": 400,
    "message": "邮箱格式不正确",
    "error": "INVALID_EMAIL_FORMAT",
    "details": {
        "field": "email",
        "reason": "邮箱格式不符合规范"
    },
    "timestamp": "2024-01-15T10:30:00Z",
    "request_id": "req_1234567890abcdef"
}
```

### 10.3 异常处理

```python
from fastapi import HTTPException, status
from app.exceptions import (
    InvalidEmailFormatError,
    InvalidEmailSuffixError,
    InvalidEmailDomainError,
    EmailAlreadyVerifiedError,
    VerificationExistsError,
    InvalidTokenError,
    RateLimitError
)

@router.post("/submit")
async def submit_verification(email: str):
    try:
        # 1. 检查邮箱格式
        if not is_valid_email_format(email):
            raise InvalidEmailFormatError("邮箱格式不正确")
        
        # 2. 统一转小写存储和比较（确保大小写不敏感）
        email_lower = email.strip().lower()
        
        # 3. 检查邮箱是否以 .ac.uk 结尾
        domain = email_lower.split('@')[1] if '@' in email_lower else ''
        if not domain.endswith('.ac.uk'):
            raise InvalidEmailSuffixError(
                "只有以 .ac.uk 结尾的邮箱才能验证学生身份"
            )
        
        # 4. 检查邮箱是否已被使用（全局唯一性）
        # 重要：使用 check_email_uniqueness 函数，支持过期后立即释放和 pending 超过15分钟释放的逻辑
        # 该函数会检查：
        # - verified 且未过期 → 阻止
        # - verified 且已过期 → 删除旧记录，允许
        # - expired → 删除旧记录，允许
        # - pending < 15 分钟 → 阻止
        # - pending ≥ 15 分钟 → 删除旧记录，允许
        # - revoked 同样按是否过期处理
        if not check_email_uniqueness(email_lower, db, exclude_user_id=None):
            raise EmailAlreadyVerifiedError(
                f"该学生邮箱已被其他用户验证，每个邮箱在同一时间只能被一个用户使用"
            )
        
        # 5. 匹配大学（使用小写邮箱）
        university = match_university_by_email(email_lower, db)
        if not university:
            raise InvalidEmailDomainError(
                "该大学不在支持列表中"
            )
        
        # 业务逻辑
        ...
    except InvalidEmailSuffixError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail={
                "code": 400,
                "error": "INVALID_EMAIL_SUFFIX",
                "message": str(e)
            }
        )
    except EmailAlreadyVerifiedError as e:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail={
                "code": 409,
                "error": "EMAIL_ALREADY_VERIFIED",
                "message": str(e)
            }
        )
    except InvalidEmailFormatError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail={
                "code": 400,
                "error": "INVALID_EMAIL_FORMAT",
                "message": str(e)
            }
        )
    except InvalidEmailDomainError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail={
                "code": 400,
                "error": "INVALID_EMAIL_DOMAIN",
                "message": str(e)
            }
        )
    except RateLimitError as e:
        raise HTTPException(
            status_code=status.HTTP_429_TOO_MANY_REQUESTS,
            detail={
                "code": 429,
                "error": "RATE_LIMIT_EXCEEDED",
                "message": str(e),
                "retry_after": e.retry_after
            }
        )
    except Exception as e:
        logger.error(f"未预期的错误: {e}", exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail={
                "code": 500,
                "error": "INTERNAL_ERROR",
                "message": "内部服务器错误"
            }
        )
```

---

## 11. 监控与日志

### 11.1 日志级别

- **DEBUG**: 详细的调试信息
- **INFO**: 一般信息（认证成功、状态变更等）
- **WARNING**: 警告信息（令牌过期、重试等）
- **ERROR**: 错误信息（验证失败、邮件发送失败等）
- **CRITICAL**: 严重错误（数据库连接失败、服务不可用等）

### 11.2 关键指标监控

#### 11.2.1 业务指标
- 每日认证申请数量
- 认证成功率
- 邮件发送成功率
- 认证过期数量
- 续期申请数量
- 邮箱重复使用拒绝次数（EMAIL_ALREADY_VERIFIED错误）

#### 11.2.2 技术指标
- API响应时间（P50, P95, P99）
- 数据库查询时间
- Redis缓存命中率
- 邮件队列长度
- 错误率

### 11.3 告警规则

```yaml
alerts:
  - name: high_error_rate
    condition: error_rate > 5%
    duration: 5m
    severity: warning
    
  - name: email_send_failure
    condition: email_send_success_rate < 95%
    duration: 10m
    severity: critical
    
  - name: database_connection_failure
    condition: database_errors > 10
    duration: 1m
    severity: critical
    
  - name: high_response_time
    condition: p95_response_time > 2s
    duration: 10m
    severity: warning
```

### 11.4 日志格式

```python
import logging
import json
from datetime import datetime

class JSONFormatter(logging.Formatter):
    def format(self, record):
        log_data = {
            "timestamp": datetime.utcnow().isoformat(),
            "level": record.levelname,
            "logger": record.name,
            "message": record.getMessage(),
            "module": record.module,
            "function": record.funcName,
            "line": record.lineno,
        }
        
        # 添加额外字段
        if hasattr(record, "user_id"):
            log_data["user_id"] = record.user_id
        if hasattr(record, "request_id"):
            log_data["request_id"] = record.request_id
        if hasattr(record, "ip_address"):
            log_data["ip_address"] = record.ip_address
        
        # 添加异常信息
        if record.exc_info:
            log_data["exception"] = self.formatException(record.exc_info)
        
        return json.dumps(log_data)

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('student_verification.log')
    ]
)

logger = logging.getLogger(__name__)
logger.handlers[0].setFormatter(JSONFormatter())
```

---

## 12. 测试策略

**重要说明**：以下测试示例中的 `client`、`db_session`、`redis_client` 等依赖项假定读者已按常规 FastAPI + pytest 方式配置了相应的 fixture。这些只是伪代码示例，实际使用时需要：

1. 配置 pytest fixture（如 `client`、`db_session`、`redis_client`）
2. 设置测试数据库和测试环境
3. 配置测试依赖注入

### 12.1 单元测试

#### 12.1.1 邮箱匹配测试

```python
import pytest
from app.student_verification import match_university_by_email

def test_exact_match():
    """测试精确匹配"""
    university = match_university_by_email("student@bristol.ac.uk", db)
    assert university.name == "University of Bristol"

def test_subdomain_match():
    """测试子域名匹配"""
    university = match_university_by_email("student@student.gla.ac.uk", db)
    assert university.name == "University of Glasgow"

def test_wildcard_match():
    """测试通配符匹配"""
    university = match_university_by_email("student@mail.ox.ac.uk", db)
    assert university.name == "University of Oxford"

def test_invalid_suffix():
    """测试非 .ac.uk 后缀的邮箱"""
    # 应该抛出异常，因为不是 .ac.uk 结尾
    with pytest.raises(ValueError, match="只有以 .ac.uk 结尾的邮箱才能验证学生身份"):
        match_university_by_email("student@gmail.com", db)

def test_invalid_domain():
    """测试无效域名（.ac.uk 结尾但不在白名单）"""
    university = match_university_by_email("student@unknown.ac.uk", db)
    assert university is None
```

#### 12.1.2 过期时间计算测试

```python
from datetime import datetime, timezone

def test_expiry_before_october():
    """测试10月1日之前的验证"""
    verified_at = datetime(2024, 5, 15, tzinfo=timezone.utc)
    expires_at = calculate_expires_at(verified_at)
    assert expires_at == datetime(2024, 10, 1, 0, 0, 0, tzinfo=timezone.utc)

def test_expiry_after_october():
    """测试10月1日之后的验证"""
    verified_at = datetime(2024, 11, 15, tzinfo=timezone.utc)
    expires_at = calculate_expires_at(verified_at)
    assert expires_at == datetime(2025, 10, 1, 0, 0, 0, tzinfo=timezone.utc)

def test_expiry_on_october_first():
    """测试10月1日当天的验证（10月1日当天视为'之后'，过期时间为下一年10月1日）"""
    verified_at = datetime(2024, 10, 1, 12, 0, 0, tzinfo=timezone.utc)
    expires_at = calculate_expires_at(verified_at)
    assert expires_at == datetime(2025, 10, 1, 0, 0, 0, tzinfo=timezone.utc)
```

### 12.2 集成测试

```python
import pytest
from fastapi.testclient import TestClient

def test_submit_verification_flow(client: TestClient, db_session):
    """测试完整的认证流程"""
    # 1. 提交认证申请
    response = client.post(
        "/api/student-verification/submit",
        json={"email": "test@bristol.ac.uk"}
    )
    assert response.status_code == 200
    data = response.json()
    assert data["code"] == 200
    verification_id = data["data"]["verification_id"]
    
    # 2. 查询认证状态（应该是pending）
    response = client.get("/api/student-verification/status")
    assert response.status_code == 200
    data = response.json()
    assert data["data"]["status"] == "pending"
    
    # 3. 模拟验证（获取token）
    # 这里需要从数据库或邮件中获取token
    token = get_verification_token(verification_id, db_session)
    
    # 4. 验证邮箱
    response = client.get(f"/api/student-verification/verify/{token}")
    assert response.status_code == 200
    data = response.json()
    assert data["data"]["status"] == "verified"
    
    # 5. 再次查询状态（应该是verified）
    response = client.get("/api/student-verification/status")
    assert response.status_code == 200
    data = response.json()
    assert data["data"]["status"] == "verified"
```

### 12.3 性能测试

```python
import pytest
import asyncio
from concurrent.futures import ThreadPoolExecutor

def test_concurrent_submissions():
    """测试并发提交"""
    def submit():
        response = client.post(
            "/api/student-verification/submit",
            json={"email": f"test{random.randint(1000,9999)}@bristol.ac.uk"}
        )
        return response.status_code
    
    with ThreadPoolExecutor(max_workers=100) as executor:
        results = list(executor.map(submit, range(1000)))
    
    success_count = sum(1 for code in results if code == 200)
    assert success_count > 950  # 95%成功率
```

### 12.4 安全测试

```python
def test_rate_limiting():
    """测试限流"""
    for i in range(10):
        response = client.post(
            "/api/student-verification/submit",
            json={"email": f"test{i}@bristol.ac.uk"}
        )
    
    # 第11次应该被限流
    response = client.post(
        "/api/student-verification/submit",
        json={"email": "test11@bristol.ac.uk"}
    )
    assert response.status_code == 429

def test_token_reuse_prevention():
    """测试令牌一次性使用"""
    token = "valid_token_12345"
    
    # 第一次使用应该成功
    response1 = client.get(f"/api/student-verification/verify/{token}")
    assert response1.status_code == 200
    
    # 第二次使用应该失败
    response2 = client.get(f"/api/student-verification/verify/{token}")
    assert response2.status_code == 400

def test_email_uniqueness_constraint():
    """测试邮箱唯一性约束"""
    email = "unique@bristol.ac.uk"
    
    # 第一个用户提交认证
    response1 = client.post(
        "/api/student-verification/submit",
        json={"email": email}
    )
    assert response1.status_code == 200
    
    # 验证第一个用户的邮箱
    token1 = get_verification_token_from_response(response1)
    client.get(f"/api/student-verification/verify/{token1}")
    
    # 第二个用户尝试使用相同邮箱（应该失败）
    response2 = client.post(
        "/api/student-verification/submit",
        json={"email": email}
    )
    assert response2.status_code == 409
    assert response2.json()["error"] == "EMAIL_ALREADY_VERIFIED"

def test_email_uniqueness_case_insensitive():
    """测试邮箱唯一性不区分大小写"""
    email1 = "Test@Bristol.ac.uk"
    email2 = "test@bristol.ac.uk"
    
    # 第一个用户提交
    response1 = client.post(
        "/api/student-verification/submit",
        json={"email": email1}
    )
    assert response1.status_code == 200
    
    # 验证
    token1 = get_verification_token_from_response(response1)
    client.get(f"/api/student-verification/verify/{token1}")
    
    # 第二个用户使用不同大小写的相同邮箱（应该失败）
    response2 = client.post(
        "/api/student-verification/submit",
        json={"email": email2}
    )
    assert response2.status_code == 409

def test_concurrent_email_verification():
    """测试并发验证同一邮箱"""
    import threading
    email = "concurrent@bristol.ac.uk"
    results = []
    
    def submit():
        response = client.post(
            "/api/student-verification/submit",
            json={"email": email}
        )
        results.append(response.status_code)
    
    # 并发提交
    threads = [threading.Thread(target=submit) for _ in range(5)]
    for t in threads:
        t.start()
    for t in threads:
        t.join()
    
    # 应该只有一个成功（200），其他都是409
    success_count = sum(1 for code in results if code == 200)
    conflict_count = sum(1 for code in results if code == 409)
    
    assert success_count == 1
    assert conflict_count == 4

def test_expired_email_release():
    """测试过期邮箱释放机制"""
    from datetime import datetime, timedelta, timezone
    
    email = "expired@bristol.ac.uk"
    
    # 1. 第一个用户验证邮箱
    user1_response = client.post(
        "/api/student-verification/submit",
        json={"email": email}
    )
    assert user1_response.status_code == 200
    
    # 验证邮箱
    token1 = get_verification_token_from_response(user1_response)
    client.get(f"/api/student-verification/verify/{token1}")
    
    # 2. 模拟过期（设置过期时间为过去）
    verification = get_verification_by_email(email, db_session)
    verification.expires_at = datetime.now(timezone.utc) - timedelta(days=1)  # 1天前过期
    verification.status = 'expired'
    db_session.commit()
    
    # 3. 第二个用户尝试使用相同邮箱（应该成功，因为已过期）
    user2_response = client.post(
        "/api/student-verification/submit",
        json={"email": email}
    )
    assert user2_response.status_code == 200
    
    # 验证第二个用户的邮箱
    token2 = get_verification_token_from_response(user2_response)
    verify_response = client.get(f"/api/student-verification/verify/{token2}")
    assert verify_response.status_code == 200

def test_unexpired_email_not_released():
    """测试未过期的邮箱不能被其他用户使用"""
    from datetime import datetime, timedelta, timezone
    
    email = "active@bristol.ac.uk"
    
    # 1. 第一个用户验证邮箱
    user1_response = client.post(
        "/api/student-verification/submit",
        json={"email": email}
    )
    token1 = get_verification_token_from_response(user1_response)
    client.get(f"/api/student-verification/verify/{token1}")
    
    # 2. 确保认证未过期（过期时间在未来）
    verification = get_verification_by_email(email, db_session)
    verification.expires_at = datetime.now(timezone.utc) + timedelta(days=365)  # 1年后过期
    verification.status = 'verified'
    db_session.commit()
    
    # 3. 第二个用户尝试使用相同邮箱（应该失败，因为未过期）
    user2_response = client.post(
        "/api/student-verification/submit",
        json={"email": email}
    )
    assert user2_response.status_code == 409
    assert user2_response.json()["error"] == "EMAIL_ALREADY_VERIFIED"

def test_pending_email_not_available():
    """测试pending状态的邮箱不能被其他用户使用"""
    email = "pending@bristol.ac.uk"
    
    # 1. 第一个用户提交认证申请（状态为pending）
    user1_response = client.post(
        "/api/student-verification/submit",
        json={"email": email}
    )
    assert user1_response.status_code == 200
    
    # 2. 第二个用户尝试使用相同邮箱（应该失败，因为pending状态未超过15分钟）
    user2_response = client.post(
        "/api/student-verification/submit",
        json={"email": email}
    )
    assert user2_response.status_code == 409
    assert user2_response.json()["error"] == "EMAIL_ALREADY_VERIFIED"

def test_pending_email_release_after_15_minutes():
    """测试pending状态超过15分钟后可以被其他用户使用"""
    from datetime import datetime, timedelta, timezone
    
    email = "old_pending@bristol.ac.uk"
    
    # 1. 第一个用户提交认证申请（状态为pending）
    user1_response = client.post(
        "/api/student-verification/submit",
        json={"email": email}
    )
    assert user1_response.status_code == 200
    
    # 2. 模拟pending记录超过15分钟（验证令牌已过期）
    verification = get_verification_by_email(email, db_session)
    verification.created_at = datetime.now(timezone.utc) - timedelta(minutes=16)  # 16分钟前创建
    verification.status = 'pending'
    db_session.commit()
    
    # 3. 第二个用户尝试使用相同邮箱（应该成功，因为pending超过15分钟）
    user2_response = client.post(
        "/api/student-verification/submit",
        json={"email": email}
    )
    assert user2_response.status_code == 200
```

---

## 13. 部署指南

### 13.1 环境要求

- **Python**: 3.9+
- **PostgreSQL**: 14+
- **Redis**: 6+
- **Celery**: 5.3+
- **Nginx**: 1.20+ (可选，用于反向代理)

### 13.2 环境变量配置

```bash
# 数据库配置
DATABASE_URL=postgresql://user:password@localhost:5432/linku_db

# Redis配置
REDIS_URL=redis://localhost:6379/0

# 邮件服务配置
EMAIL_SERVICE=resend  # 或 smtp
RESEND_API_KEY=your_resend_api_key
SMTP_HOST=smtp.example.com
SMTP_PORT=587
SMTP_USER=your_email@example.com
SMTP_PASSWORD=your_password

# 邮件送达优化配置（重要：防止邮件进入垃圾箱）
# 建议使用可信域名作为发件人，如：no-reply@yourdomain.ac.uk
EMAIL_FROM=no-reply@yourdomain.ac.uk  # 使用可信域名，提高送达率
# 注意：需要配置 SPF/DKIM/DMARC 记录（见 13.6 邮件送达优化配置）

# 注意：邮箱在认证过期后立即释放，无需配置释放期
# 系统会自动检查认证是否过期，过期后邮箱可以被其他用户重新验证

# 应用配置
SECRET_KEY=your-secret-key-here
FRONTEND_URL=https://your-frontend-domain.com
API_BASE_URL=https://your-api-domain.com

# Celery配置
CELERY_BROKER_URL=redis://localhost:6379/1
CELERY_RESULT_BACKEND=redis://localhost:6379/2

# 日志配置
LOG_LEVEL=INFO
LOG_FILE=/var/log/student_verification.log
```

### 13.3 数据库迁移

```bash
# 创建迁移文件
alembic revision --autogenerate -m "add_student_verification_tables"

# 执行迁移
alembic upgrade head

# 初始化大学数据
python scripts/init_universities.py
```

### 13.4 Celery Worker启动

```bash
# 启动Celery Worker
celery -A app.celery_app worker --loglevel=info

# 启动Celery Beat（定时任务）
celery -A app.celery_app beat --loglevel=info
```

### 13.5 Docker部署

```dockerfile
# Dockerfile
FROM python:3.9-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  api:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://user:password@db:5432/linku_db
      - REDIS_URL=redis://redis:6379/0
    depends_on:
      - db
      - redis
  
  celery_worker:
    build: .
    command: celery -A app.celery_app worker --loglevel=info
    environment:
      - DATABASE_URL=postgresql://user:password@db:5432/linku_db
      - REDIS_URL=redis://redis:6379/0
      # 注意：Celery broker / backend 默认从 REDIS_URL 推导
      # 如需独立配置，可显式设置 CELERY_BROKER_URL / CELERY_RESULT_BACKEND
      # - CELERY_BROKER_URL=redis://redis:6379/1
      # - CELERY_RESULT_BACKEND=redis://redis:6379/2
    depends_on:
      - db
      - redis
  
  celery_beat:
    build: .
    command: celery -A app.celery_app beat --loglevel=info
    environment:
      - DATABASE_URL=postgresql://user:password@db:5432/linku_db
      - REDIS_URL=redis://redis:6379/0
      # 注意：Celery broker / backend 默认从 REDIS_URL 推导
      # 如需独立配置，可显式设置 CELERY_BROKER_URL / CELERY_RESULT_BACKEND
      # - CELERY_BROKER_URL=redis://redis:6379/1
      # - CELERY_RESULT_BACKEND=redis://redis:6379/2
    depends_on:
      - db
      - redis
  
  db:
    image: postgres:14
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=linku_db
    volumes:
      - postgres_data:/var/lib/postgresql/data
  
  redis:
    image: redis:6-alpine
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:
```

### 13.6 邮件送达优化配置

#### 13.6.1 防止邮件进入垃圾箱

**问题**：验证码邮件可能被标记为垃圾邮件，影响用户体验。

**解决方案**：配置 SPF/DKIM/DMARC 记录，使用可信域名作为发件人。

#### 13.6.2 推荐配置

**1. 使用可信域名作为发件人**：
- **推荐格式**：`no-reply@yourdomain.ac.uk` 或 `noreply@yourdomain.ac.uk`
- **优势**：使用 `.ac.uk` 等教育域名，可信度更高，送达率更好
- **配置示例**：
```env
EMAIL_FROM=no-reply@yourdomain.ac.uk
```

**2. 配置 SPF 记录**（Sender Policy Framework）：
在域名 DNS 中添加 TXT 记录：
```
yourdomain.ac.uk.  IN  TXT  "v=spf1 include:_spf.resend.com ~all"
```
- 如果使用 Resend：`include:_spf.resend.com`
- 如果使用 SendGrid：`include:sendgrid.net`
- 如果使用自定义 SMTP：`include:your-smtp-server.com`

**3. 配置 DKIM 记录**（DomainKeys Identified Mail）：
- **Resend**：在 Resend 控制台中验证域名，会自动生成 DKIM 记录
- **SendGrid**：在 SendGrid 控制台中验证域名，会自动生成 DKIM 记录
- **自定义 SMTP**：需要从邮件服务商获取 DKIM 公钥，添加到 DNS：
```
default._domainkey.yourdomain.ac.uk.  IN  TXT  "v=DKIM1; k=rsa; p=YOUR_PUBLIC_KEY"
```

**4. 配置 DMARC 记录**（Domain-based Message Authentication）：
在域名 DNS 中添加 TXT 记录：
```
_dmarc.yourdomain.ac.uk.  IN  TXT  "v=DMARC1; p=quarantine; rua=mailto:dmarc@yourdomain.ac.uk"
```
- `p=quarantine`：未通过验证的邮件进入隔离区
- `p=reject`：未通过验证的邮件直接拒绝（更严格）
- `p=none`：仅监控，不采取行动（测试阶段）

#### 13.6.3 配置步骤

**使用 Resend（推荐）**：
1. 在 Resend 控制台中添加域名 `yourdomain.ac.uk`
2. 按照 Resend 提示添加 DNS 记录（SPF、DKIM）
3. 等待 DNS 验证通过（通常几分钟到几小时）
4. 配置环境变量：
```env
EMAIL_FROM=no-reply@yourdomain.ac.uk
RESEND_API_KEY=your_resend_api_key
USE_RESEND=true
```

**使用 SendGrid**：
1. 在 SendGrid 控制台中添加域名 `yourdomain.ac.uk`
2. 按照 SendGrid 提示添加 DNS 记录（SPF、DKIM）
3. 等待 DNS 验证通过
4. 配置环境变量：
```env
EMAIL_FROM=no-reply@yourdomain.ac.uk
SENDGRID_API_KEY=your_sendgrid_api_key
USE_SENDGRID=true
```

**使用自定义 SMTP**：
1. 联系邮件服务商获取 SPF/DKIM/DMARC 配置
2. 在域名 DNS 中添加相应记录
3. 使用邮件服务商提供的工具验证配置

#### 13.6.4 验证配置

**检查 SPF 记录**：
```bash
dig TXT yourdomain.ac.uk
# 或
nslookup -type=TXT yourdomain.ac.uk
```

**检查 DKIM 记录**：
```bash
dig TXT default._domainkey.yourdomain.ac.uk
```

**检查 DMARC 记录**：
```bash
dig TXT _dmarc.yourdomain.ac.uk
```

**在线验证工具**：
- https://mxtoolbox.com/spf.aspx
- https://mxtoolbox.com/dkim.aspx
- https://mxtoolbox.com/dmarc.aspx

#### 13.6.5 邮件送达率监控

**建议监控指标**：
- 邮件送达率（Delivery Rate）
- 垃圾邮件率（Spam Rate）
- 打开率（Open Rate）
- 点击率（Click Rate）

**Resend 监控**：
- 在 Resend 控制台查看邮件统计
- 监控送达率、打开率等指标

**SendGrid 监控**：
- 在 SendGrid 控制台查看邮件统计
- 使用 SendGrid 的 Webhook 接收邮件事件

---

## 14. 运维手册

### 14.1 日常运维

#### 14.1.1 监控检查清单
- [ ] API响应时间正常（P95 < 2s）
- [ ] 错误率 < 1%
- [ ] 邮件发送成功率 > 99%
- [ ] 数据库连接正常
- [ ] Redis连接正常
- [ ] Celery Worker运行正常
- [ ] 磁盘空间充足
- [ ] 内存使用率 < 80%

#### 14.1.2 日志检查
```bash
# 查看错误日志
tail -f /var/log/student_verification.log | grep ERROR

# 查看认证统计
grep "verification_success" /var/log/student_verification.log | wc -l

# 查看邮件发送失败
grep "email_send_failed" /var/log/student_verification.log
```

### 14.2 常见问题处理

#### 14.2.1 邮件发送失败
**症状**: 用户收不到验证邮件

**排查步骤**:
1. 检查邮件服务配置（API Key、SMTP设置）
2. 检查邮件队列是否有积压
3. 查看Celery Worker日志
4. 检查邮件服务商状态

**解决方案**:
```python
# 手动重试失败的邮件
from app.celery_tasks import send_verification_email
send_verification_email.apply_async(
    args=[email, university_id],
    retry=True,
    max_retries=3
)

# 从死信队列中获取失败的邮件任务（需要配置Celery死信队列）
from celery.result import AsyncResult
from app.celery_app import celery_app

# 查询死信队列中的失败任务
failed_tasks = celery_app.control.inspect().reserved()  # 或使用其他方法查询死信队列

# 人工审核后决定是否重试
for task_id in failed_tasks:
    task_result = AsyncResult(task_id)
    if task_result.failed():
        # 检查失败原因，决定是否重试
        error = task_result.info
        # 人工审核后重试
        task_result.retry()
```

**死信队列配置**（Celery配置）:
```python
# celery_config.py
CELERY_TASK_REJECT_ON_WORKER_LOST = True
CELERY_TASK_ACKS_LATE = True

# 配置死信队列
CELERY_TASK_ROUTES = {
    'app.celery_tasks.send_verification_email': {'queue': 'email_queue'},
}

CELERY_TASK_QUEUES = {
    'email_queue': {
        'exchange': 'email_exchange',
        'routing_key': 'email.send',
    },
    'dead_letter_queue': {
        'exchange': 'email_exchange',
        'routing_key': 'email.failed',
    },
}
```

#### 14.2.2 认证过期未处理
**症状**: 过期认证状态未更新

**排查步骤**:
1. 检查Celery Beat是否运行
2. 查看定时任务执行日志
3. 手动执行过期处理任务

**解决方案**:
```python
# 手动执行过期处理
from app.celery_tasks import process_expired_verifications
process_expired_verifications.delay()
```

#### 14.2.3 数据库性能问题
**症状**: API响应变慢

**排查步骤**:
1. 检查慢查询日志
2. 分析数据库索引使用情况
3. 检查连接池配置

**解决方案**:
```sql
-- 分析慢查询
SELECT * FROM pg_stat_statements 
ORDER BY total_exec_time DESC 
LIMIT 10;

-- 重建索引
REINDEX TABLE student_verifications;
```

### 14.3 数据备份与恢复

#### 14.3.1 备份策略
- **全量备份**: 每天凌晨2点
- **增量备份**: 每小时
- **保留期限**: 30天

#### 14.3.2 备份脚本
```bash
#!/bin/bash
# backup_student_verification.sh

DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_DIR="/backup/student_verification"

# 备份数据库
pg_dump $DATABASE_URL > $BACKUP_DIR/db_backup_$DATE.sql

# 压缩备份
gzip $BACKUP_DIR/db_backup_$DATE.sql

# 删除30天前的备份
find $BACKUP_DIR -name "*.sql.gz" -mtime +30 -delete
```

### 14.4 性能优化

#### 14.4.1 数据库优化
```sql
-- 定期更新统计信息
ANALYZE student_verifications;

-- 清理过期数据（可选）
DELETE FROM verification_history 
WHERE created_at < NOW() - INTERVAL '1 year';
```

#### 14.4.2 缓存优化
```python
# 缓存大学列表
@cache(expire=3600)  # 缓存1小时
def get_universities():
    return db.query(University).filter(University.is_active == True).all()

# 缓存用户认证状态
@cache(expire=300)  # 缓存5分钟
def get_user_verification_status(user_id):
    ...
```

---

## 15. 附录

### 15.1 英国大学邮箱后缀完整列表

详见 `scripts/university_email_domains.json` 文件，包含150+所英国大学的邮箱后缀配置。

### 15.2 扩展支持其他地区大学（可配置扩展点）

**当前设计**：系统默认只支持 `.ac.uk` 结尾的英国大学邮箱。

**扩展支持其他地区**（如 EU/US 学校）：

如果未来需要支持其他地区的大学邮箱，只需要进行以下配置调整：

1. **放宽邮箱后缀规则**：
   - 修改邮箱验证逻辑，不再强制要求 `.ac.uk` 结尾
   - 可以配置允许的后缀列表（如 `.edu`、`.edu.au`、`.ac.cn` 等）
   - 或使用配置化的后缀白名单

2. **扩展大学数据表**：
   - `universities` 表已支持任意邮箱域名，无需修改表结构
   - 在 `university_email_patterns` 表中添加新的匹配模式
   - 更新 `scripts/university_email_domains.json` 文件，添加新地区的大学数据

3. **配置示例**：
```python
# 配置允许的邮箱后缀
ALLOWED_EMAIL_SUFFIXES = [
    '.ac.uk',      # 英国
    '.edu',         # 美国
    '.edu.au',      # 澳大利亚
    '.ac.cn',       # 中国
    # ... 其他后缀
]

# 在邮箱验证中使用
def is_valid_student_email(email: str) -> bool:
    domain = email.split('@')[1].lower() if '@' in email else ''
    return any(domain.endswith(suffix) for suffix in ALLOWED_EMAIL_SUFFIXES)
```

**注意**：
- 扩展时需要确保邮箱后缀的唯一性和可识别性
- 建议为不同地区配置不同的匹配规则和优先级
- 更新文档和用户界面，明确说明支持的邮箱后缀范围

### 15.3 API接口完整文档

访问 `/docs` 查看Swagger API文档，或访问 `/redoc` 查看ReDoc文档。

### 15.4 相关文档链接

- [FastAPI文档](https://fastapi.tiangolo.com/)
- [Celery文档](https://docs.celeryproject.org/)
- [PostgreSQL文档](https://www.postgresql.org/docs/)
- [Redis文档](https://redis.io/documentation)

### 15.5 联系方式

- **技术支持**: tech-support@linku.com
- **紧急联系**: emergency@linku.com
- **文档反馈**: docs@linku.com

### 15.6 更新日志

#### v1.0.0 (2024-01-15)
- 初始版本发布
- 实现基本的邮箱验证功能
- 实现大学识别功能
- 实现有效期管理功能
- 实现提醒机制

---

## 文档结束

**注意**: 本文档为企业级技术文档，涵盖了英国留学生认证系统的完整设计、实现和运维指南。在实际开发过程中，请根据具体需求进行调整和优化。

**最后更新**: 2024年1月15日
**文档维护**: LinkU开发团队

