# LinkU æ•°æ®åº“è¯»å–åŠŸèƒ½ä¼˜åŒ–å¼€å‘æ–‡æ¡£

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†åˆ†æäº† LinkU é¡¹ç›®ä¸­æ‰€æœ‰éœ€è¦ä»åç«¯æˆ–æ•°æ®åº“è¯»å–çš„åŠŸèƒ½ï¼ˆåŠ è½½ã€ç­›é€‰ã€æ’åºã€æ›´æ–°ç­‰ï¼‰ï¼Œå¹¶æä¾›äº†å…¨é¢çš„ä¼˜åŒ–æ–¹æ¡ˆã€‚

**æ–‡æ¡£ç‰ˆæœ¬**: v1.1  
**åˆ›å»ºæ—¥æœŸ**: 2025-01-27  
**æœ€åæ›´æ–°**: 2025-01-27

---

## ğŸ“Š åŠŸèƒ½æ¸…å•ä¸ç°çŠ¶åˆ†æ

### 1. ä»»åŠ¡ç›¸å…³åŠŸèƒ½

#### 1.1 ä»»åŠ¡åˆ—è¡¨åŠ è½½ (`GET /tasks`)
**æ–‡ä»¶ä½ç½®**: `backend/app/async_routers.py:95-171`, `backend/app/async_crud.py:260-345`

**å½“å‰å®ç°**:
- âœ… å·²ä½¿ç”¨ `selectinload` é¢„åŠ è½½å…³è”æ•°æ®ï¼ˆé¿å… N+1 æŸ¥è¯¢ï¼‰
- âœ… å·²å®ç° Redis ç¼“å­˜
- âœ… æ”¯æŒå¤šç§ç­›é€‰æ¡ä»¶ï¼ˆç±»å‹ã€åœ°ç‚¹ã€çŠ¶æ€ã€å…³é”®è¯ï¼‰
- âœ… æ”¯æŒå¤šç§æ’åºæ–¹å¼ï¼ˆæœ€æ–°ã€æœ€æ—§ã€ä»·æ ¼ã€æˆªæ­¢æ—¥æœŸï¼‰

**å­˜åœ¨çš„é—®é¢˜**:
1. **å…³é”®è¯æœç´¢æ€§èƒ½é—®é¢˜** (P1)
   - å½“å‰ä½¿ç”¨ `ilike` è¿›è¡Œæ¨¡ç³Šæœç´¢ï¼Œåœ¨å¤§æ•°æ®é‡ä¸‹æ€§èƒ½è¾ƒå·®
   - æœªä½¿ç”¨ PostgreSQL å…¨æ–‡æœç´¢æˆ– `pg_trgm` æ‰©å±•
   - æœç´¢æ¡ä»¶æœªä½¿ç”¨ç´¢å¼•

2. **åˆ†é¡µæŸ¥è¯¢ä¼˜åŒ–ç©ºé—´** (P2)
   - ä½¿ç”¨ `offset/limit` åˆ†é¡µï¼Œåœ¨æ·±åˆ†é¡µæ—¶æ€§èƒ½ä¸‹é™
   - æœªå®ç°æ¸¸æ ‡åˆ†é¡µï¼ˆcursor-based paginationï¼‰

3. **ç¼“å­˜ç­–ç•¥é—®é¢˜** (P2)
   - ç¼“å­˜é”®åŒ…å«æ‰€æœ‰ç­›é€‰å‚æ•°ï¼Œå¯¼è‡´ç¼“å­˜å‘½ä¸­ç‡ä½
   - æœªå®ç°ç¼“å­˜é¢„çƒ­æœºåˆ¶
   - ç¼“å­˜å¤±æ•ˆç­–ç•¥ä¸å¤Ÿç²¾ç»†

4. **æ€»æ•°æŸ¥è¯¢æ€§èƒ½** (P2)
   - `get_tasks_with_total` ä¸­æ€»æ•°æŸ¥è¯¢å¯èƒ½è¾ƒæ…¢
   - æœªä½¿ç”¨ä¼°ç®—æˆ–ç¼“å­˜æ€»æ•°

#### 1.2 ä»»åŠ¡è¯¦æƒ…åŠ è½½ (`GET /tasks/{task_id}`)
**æ–‡ä»¶ä½ç½®**: `backend/app/async_routers.py:174-182`, `backend/app/async_crud.py:149-161`

**å½“å‰å®ç°**:
- âœ… å·²ä½¿ç”¨ `selectinload` é¢„åŠ è½½å‘å¸ƒè€…å’Œæ¥å—è€…
- âœ… å·²å®ç°ç¼“å­˜è£…é¥°å™¨

**å­˜åœ¨çš„é—®é¢˜**:
1. **å…³è”æ•°æ®åŠ è½½ä¸å®Œæ•´** (P2)
   - æœªé¢„åŠ è½½è¯„ä»·ï¼ˆreviewsï¼‰
   - æœªé¢„åŠ è½½ç”³è¯·è®°å½•ï¼ˆapplicationsï¼‰

2. **ç¼“å­˜ TTL å›ºå®š** (P3)
   - ç¼“å­˜æ—¶é—´å›ºå®šä¸º 300 ç§’ï¼Œæœªæ ¹æ®æ•°æ®æ›´æ–°é¢‘ç‡è°ƒæ•´

#### 1.3 ç”¨æˆ·ä»»åŠ¡åˆ—è¡¨ (`GET /users/{user_id}/tasks`)
**æ–‡ä»¶ä½ç½®**: `backend/app/async_routers.py:728-736`, `backend/app/async_crud.py:437-461`

**å½“å‰å®ç°**:
- âœ… åˆ†åˆ«æŸ¥è¯¢å‘å¸ƒå’Œæ¥å—çš„ä»»åŠ¡
- âœ… æŒ‰åˆ›å»ºæ—¶é—´æ’åº

**å­˜åœ¨çš„é—®é¢˜**:
1. **N+1 æŸ¥è¯¢é£é™©** (P1)
   - æœªä½¿ç”¨ `selectinload` é¢„åŠ è½½å…³è”æ•°æ®
   - å¦‚æœå‰ç«¯éœ€è¦æ˜¾ç¤ºå‘å¸ƒè€…/æ¥å—è€…ä¿¡æ¯ï¼Œä¼šè§¦å‘ N+1 æŸ¥è¯¢

2. **æŸ¥è¯¢å¯ä»¥åˆå¹¶** (P2)
   - ä¸¤ä¸ªç‹¬ç«‹æŸ¥è¯¢å¯ä»¥åˆå¹¶ä¸ºä¸€ä¸ª UNION æŸ¥è¯¢

3. **ç¼ºå°‘ç­›é€‰å’Œåˆ†é¡µ** (P2)
   - æœªæ”¯æŒä»»åŠ¡ç±»å‹ç­›é€‰
   - æœªæ”¯æŒåˆ†é¡µ

---

### 2. ç”¨æˆ·ç›¸å…³åŠŸèƒ½

#### 2.1 ç”¨æˆ·ä¿¡æ¯åŠ è½½ (`GET /users/{user_id}`)
**æ–‡ä»¶ä½ç½®**: `backend/app/async_routers.py:72-80`, `backend/app/async_crud.py:29-38`

**å½“å‰å®ç°**:
- âœ… å·²å®ç° Redis ç¼“å­˜
- âœ… ç®€å•çš„å•è¡¨æŸ¥è¯¢

**å­˜åœ¨çš„é—®é¢˜**:
1. **ç»Ÿè®¡ä¿¡æ¯æœªé¢„åŠ è½½** (P2)
   - å¦‚æœå‰ç«¯éœ€è¦æ˜¾ç¤ºä»»åŠ¡æ•°ã€è¯„åˆ†ç­‰ç»Ÿè®¡ä¿¡æ¯ï¼Œéœ€è¦é¢å¤–æŸ¥è¯¢

#### 2.2 ç”¨æˆ·åˆ—è¡¨åŠ è½½ (`GET /users`)
**æ–‡ä»¶ä½ç½®**: `backend/app/async_routers.py:83-91`, `backend/app/async_crud.py:127-141`

**å½“å‰å®ç°**:
- âœ… æ”¯æŒåˆ†é¡µ
- âœ… æŒ‰åˆ›å»ºæ—¶é—´æ’åº

**å­˜åœ¨çš„é—®é¢˜**:
1. **ç¼ºå°‘ç­›é€‰æ¡ä»¶** (P2)
   - æœªæ”¯æŒæŒ‰ç”¨æˆ·ç­‰çº§ã€çŠ¶æ€ç­‰ç­›é€‰
   - æœªæ”¯æŒå…³é”®è¯æœç´¢

2. **æœªä½¿ç”¨ç¼“å­˜** (P2)
   - ç”¨æˆ·åˆ—è¡¨æŸ¥è¯¢æœªä½¿ç”¨ç¼“å­˜

---

### 3. ç”³è¯·ç›¸å…³åŠŸèƒ½

#### 3.1 ç”¨æˆ·ç”³è¯·åˆ—è¡¨ (`GET /my-applications`)
**æ–‡ä»¶ä½ç½®**: `backend/app/async_routers.py:558-598`

**å½“å‰å®ç°**:
- âœ… æŸ¥è¯¢ç”¨æˆ·çš„æ‰€æœ‰ç”³è¯·è®°å½•
- âœ… å…³è”æŸ¥è¯¢ä»»åŠ¡ä¿¡æ¯

**å­˜åœ¨çš„é—®é¢˜**:
1. **N+1 æŸ¥è¯¢é—®é¢˜** (P1)
   - å¾ªç¯ä¸­ä¸ºæ¯ä¸ªç”³è¯·å•ç‹¬æŸ¥è¯¢ä»»åŠ¡ï¼Œå­˜åœ¨ N+1 æŸ¥è¯¢
   ```python
   # å½“å‰å®ç°ï¼ˆé—®é¢˜ä»£ç ï¼‰
   for app in applications:
       task_query = select(models.Task).where(models.Task.id == app.task_id)
       task_result = await db.execute(task_query)
       task = task_result.scalar_one_or_none()
   ```

2. **ç¼ºå°‘åˆ†é¡µ** (P2)
   - æœªå®ç°åˆ†é¡µï¼Œå¯èƒ½è¿”å›å¤§é‡æ•°æ®

3. **ç¼ºå°‘ç­›é€‰å’Œæ’åº** (P2)
   - æœªæ”¯æŒæŒ‰çŠ¶æ€ã€æ—¶é—´ç­‰ç­›é€‰å’Œæ’åº

#### 3.2 ä»»åŠ¡ç”³è¯·åˆ—è¡¨ (`GET /tasks/{task_id}/applications`)
**æ–‡ä»¶ä½ç½®**: `backend/app/async_routers.py:600-664`

**å½“å‰å®ç°**:
- âœ… æŸ¥è¯¢ä»»åŠ¡çš„ç”³è¯·è®°å½•
- âœ… å…³è”æŸ¥è¯¢ç”³è¯·è€…ä¿¡æ¯

**å­˜åœ¨çš„é—®é¢˜**:
1. **N+1 æŸ¥è¯¢é—®é¢˜** (P1)
   - å¾ªç¯ä¸­ä¸ºæ¯ä¸ªç”³è¯·å•ç‹¬æŸ¥è¯¢ç”¨æˆ·ï¼Œå­˜åœ¨ N+1 æŸ¥è¯¢
   ```python
   # å½“å‰å®ç°ï¼ˆé—®é¢˜ä»£ç ï¼‰
   for app in applications:
       user = await db.execute(
           select(models.User).where(models.User.id == app.applicant_id)
       )
   ```

2. **ç¼ºå°‘åˆ†é¡µ** (P2)
   - æœªå®ç°åˆ†é¡µ

---

### 4. æ¶ˆæ¯ç›¸å…³åŠŸèƒ½

#### 4.1 æ¶ˆæ¯åˆ—è¡¨ (`GET /messages`)
**æ–‡ä»¶ä½ç½®**: `backend/app/async_routers.py:757-768`, `backend/app/async_crud.py:733-753`

**å½“å‰å®ç°**:
- âœ… æ”¯æŒåˆ†é¡µ
- âœ… æŒ‰åˆ›å»ºæ—¶é—´æ’åº

**å­˜åœ¨çš„é—®é¢˜**:
1. **æœªé¢„åŠ è½½å…³è”æ•°æ®** (P2)
   - æœªé¢„åŠ è½½å‘é€è€…å’Œæ¥æ”¶è€…ä¿¡æ¯

2. **æŸ¥è¯¢æ¡ä»¶å¯ä»¥ä¼˜åŒ–** (P2)
   - ä½¿ç”¨ `or_` æŸ¥è¯¢ï¼Œå¯èƒ½æœªä½¿ç”¨ç´¢å¼•

#### 4.2 å¯¹è¯æ¶ˆæ¯ (`GET /messages/conversation/{user_id}`)
**æ–‡ä»¶ä½ç½®**: `backend/app/async_routers.py:771-785`, `backend/app/async_crud.py:756-782`

**å½“å‰å®ç°**:
- âœ… æ”¯æŒåˆ†é¡µ
- âœ… æŒ‰åˆ›å»ºæ—¶é—´æ’åº

**å­˜åœ¨çš„é—®é¢˜**:
1. **æŸ¥è¯¢æ€§èƒ½é—®é¢˜** (P2)
   - ä½¿ç”¨å¤æ‚çš„ `or_` å’Œ `and_` ç»„åˆï¼Œå¯èƒ½æœªä½¿ç”¨ç´¢å¼•
   - å½“å‰æŸ¥è¯¢æ¡ä»¶ï¼š`(sender_id = :me AND receiver_id = :other) OR (sender_id = :other AND receiver_id = :me)`
   - å¤åˆç´¢å¼• `(sender_id, receiver_id, created_at)` åªèƒ½è¦†ç›–ä¸€åŠæ¡ä»¶ï¼Œå¦ä¸€åŠï¼ˆäº¤æ¢ sender/receiverï¼‰æ— æ³•ä½¿ç”¨ç´¢å¼•
   - ç¼ºå°‘æ›´ä¼˜åŒ–çš„ç´¢å¼•ç»“æ„

**ä¼˜åŒ–æ–¹æ¡ˆ**ï¼ˆè§ä¸‹æ–¹ä¼˜åŒ–æ–¹æ¡ˆ 8ï¼‰

---

### 5. é€šçŸ¥ç›¸å…³åŠŸèƒ½

#### 5.1 é€šçŸ¥åˆ—è¡¨ (`GET /notifications`)
**æ–‡ä»¶ä½ç½®**: `backend/app/async_routers.py:789-801`, `backend/app/async_crud.py:826-850`

**å½“å‰å®ç°**:
- âœ… æ”¯æŒåˆ†é¡µ
- âœ… æ”¯æŒæœªè¯»ç­›é€‰
- âœ… æŒ‰åˆ›å»ºæ—¶é—´æ’åº

**å­˜åœ¨çš„é—®é¢˜**:
1. **æœªä½¿ç”¨ç¼“å­˜** (P2)
   - é€šçŸ¥æŸ¥è¯¢æœªä½¿ç”¨ç¼“å­˜

2. **ç´¢å¼•ä½¿ç”¨å¯èƒ½ä¸å……åˆ†** (P2)
   - å¤åˆæŸ¥è¯¢å¯èƒ½æœªå……åˆ†åˆ©ç”¨ç´¢å¼•

---

### 6. è¯„ä»·ç›¸å…³åŠŸèƒ½

#### 6.1 ä»»åŠ¡è¯„ä»·åˆ—è¡¨ (`GET /tasks/{task_id}/reviews`)
**æ–‡ä»¶ä½ç½®**: `backend/app/async_routers.py:847-919`

**å½“å‰å®ç°**:
- âœ… æŸ¥è¯¢ä»»åŠ¡çš„æ‰€æœ‰è¯„ä»·
- âœ… æ”¯æŒåŒ¿åè¯„ä»·è¿‡æ»¤

**å­˜åœ¨çš„é—®é¢˜**:
1. **N+1 æŸ¥è¯¢é£é™©** (P2)
   - å¦‚æœå‰ç«¯éœ€è¦æ˜¾ç¤ºè¯„ä»·è€…ä¿¡æ¯ï¼Œä¼šè§¦å‘ N+1 æŸ¥è¯¢

2. **ç¼ºå°‘åˆ†é¡µ** (P2)
   - æœªå®ç°åˆ†é¡µ

---

## ğŸ”§ ä¼˜åŒ–æ–¹æ¡ˆ

### ä¼˜å…ˆçº§è¯´æ˜
- **P1**: é«˜ä¼˜å…ˆçº§ï¼Œä¸¥é‡å½±å“æ€§èƒ½ï¼Œéœ€è¦ç«‹å³ä¼˜åŒ–
- **P2**: ä¸­ä¼˜å…ˆçº§ï¼Œæœ‰ä¼˜åŒ–ç©ºé—´ï¼Œå»ºè®®å°½å¿«ä¼˜åŒ–
- **P3**: ä½ä¼˜å…ˆçº§ï¼Œä¼˜åŒ–æ”¶ç›Šè¾ƒå°ï¼Œå¯é€‰æ‹©æ€§ä¼˜åŒ–

---

### ä¼˜åŒ–æ–¹æ¡ˆ 1: è§£å†³ N+1 æŸ¥è¯¢é—®é¢˜ (P1)

#### 1.1 ä¼˜åŒ–ç”¨æˆ·ç”³è¯·åˆ—è¡¨æŸ¥è¯¢

**æ–‡ä»¶**: `backend/app/async_routers.py:558-598`

**ä¼˜åŒ–å‰**:
```python
applications = applications_result.scalars().all()
result = []
for app in applications:
    task_query = select(models.Task).where(models.Task.id == app.task_id)
    task_result = await db.execute(task_query)
    task = task_result.scalar_one_or_none()
```

**ä¼˜åŒ–å**:
```python
# ä½¿ç”¨ JOIN æŸ¥è¯¢ï¼Œä¸€æ¬¡è·å–æ‰€æœ‰æ•°æ®
from sqlalchemy.orm import selectinload

applications_query = (
    select(models.TaskApplication)
    .options(selectinload(models.TaskApplication.task))  # é¢„åŠ è½½ä»»åŠ¡
    .where(models.TaskApplication.applicant_id == current_user.id)
    .order_by(models.TaskApplication.created_at.desc())
)

applications_result = await db.execute(applications_query)
applications = applications_result.scalars().all()

# ç›´æ¥ä½¿ç”¨å…³è”æ•°æ®ï¼Œæ— éœ€é¢å¤–æŸ¥è¯¢
result = []
for app in applications:
    task = app.task  # å·²é¢„åŠ è½½ï¼Œæ— éœ€æŸ¥è¯¢
    if task:
        result.append({
            "id": app.id,
            "task_id": app.task_id,
            "task_title": task.title,
            # ... å…¶ä»–å­—æ®µ
        })
```

**æ€§èƒ½æå‡**: ä» N+1 æ¬¡æŸ¥è¯¢å‡å°‘åˆ° 2 æ¬¡æŸ¥è¯¢ï¼ˆ1 æ¬¡æŸ¥è¯¢ç”³è¯·ï¼Œ1 æ¬¡æ‰¹é‡æŸ¥è¯¢ä»»åŠ¡ï¼‰

#### 1.2 ä¼˜åŒ–ä»»åŠ¡ç”³è¯·åˆ—è¡¨æŸ¥è¯¢

**æ–‡ä»¶**: `backend/app/async_routers.py:600-664`

**ä¼˜åŒ–å‰**:
```python
for app in applications:
    user = await db.execute(
        select(models.User).where(models.User.id == app.applicant_id)
    )
    user = user.scalar_one_or_none()
```

**ä¼˜åŒ–å**:
```python
# ä½¿ç”¨ JOIN æŸ¥è¯¢
applications = await async_crud.async_task_crud.get_task_applications(db, task_id)

# æ‰¹é‡è·å–æ‰€æœ‰ç”³è¯·è€…ID
applicant_ids = [app.applicant_id for app in applications]

# æ‰¹é‡æŸ¥è¯¢ç”¨æˆ·ä¿¡æ¯
from app.query_optimizer import AsyncQueryOptimizer
users_dict = await AsyncQueryOptimizer.batch_get_users(db, applicant_ids)

# æ„å»ºç»“æœ
result = []
for app in applications:
    user = users_dict.get(app.applicant_id)
    if user:
        result.append({
            "id": app.id,
            "applicant_id": app.applicant_id,
            "applicant_name": user.name,
            # ... å…¶ä»–å­—æ®µ
        })
```

**æ€§èƒ½æå‡**: ä» N+1 æ¬¡æŸ¥è¯¢å‡å°‘åˆ° 2 æ¬¡æŸ¥è¯¢

#### 1.3 ä¼˜åŒ–ç”¨æˆ·ä»»åŠ¡åˆ—è¡¨æŸ¥è¯¢

**æ–‡ä»¶**: `backend/app/async_crud.py:437-461`

**ä¼˜åŒ–å**ï¼ˆæ–¹æ¡ˆAï¼šåˆ†åˆ«åˆ†é¡µï¼‰:
```python
@staticmethod
async def get_user_tasks(
    db: AsyncSession, 
    user_id: str, 
    task_type: str = "all",
    posted_skip: int = 0,
    posted_limit: int = 25,
    taken_skip: int = 0,
    taken_limit: int = 25,
    with_reviews: bool = False  # åˆ—è¡¨æ¥å£é»˜è®¤ä¸åŠ è½½ reviewsï¼Œå‡å°‘æ•°æ®é‡
) -> Dict[str, Any]:
    """è·å–ç”¨æˆ·çš„ä»»åŠ¡ï¼ˆå‘å¸ƒçš„å’Œæ¥å—çš„ï¼‰ï¼Œæ”¯æŒç­›é€‰å’Œåˆ†é¡µ"""
    
    # æ„å»ºå‘å¸ƒä»»åŠ¡æŸ¥è¯¢
    posted_query = (
        select(models.Task)
        .options(
            selectinload(models.Task.poster),
            selectinload(models.Task.taker)
        )
        .where(models.Task.poster_id == user_id)
    )
    
    # æ„å»ºæ¥å—ä»»åŠ¡æŸ¥è¯¢
    taken_query = (
        select(models.Task)
        .options(
            selectinload(models.Task.poster),
            selectinload(models.Task.taker)
        )
        .where(models.Task.taker_id == user_id)
    )
    
    # åˆ—è¡¨æ¥å£é»˜è®¤ä¸åŠ è½½ reviewsï¼ˆè¯¦æƒ…æ¥å£æ‰éœ€è¦ï¼‰
    if with_reviews:
        posted_query = posted_query.options(selectinload(models.Task.reviews))
        taken_query = taken_query.options(selectinload(models.Task.reviews))
    
    # åº”ç”¨ä»»åŠ¡ç±»å‹ç­›é€‰
    if task_type and task_type != "all":
        posted_query = posted_query.where(models.Task.task_type == task_type)
        taken_query = taken_query.where(models.Task.task_type == task_type)
    
    # åˆ†åˆ«æ‰§è¡ŒæŸ¥è¯¢å¹¶åº”ç”¨åˆ†é¡µ
    posted_result = await db.execute(
        posted_query.order_by(models.Task.created_at.desc())
                   .offset(posted_skip)
                   .limit(posted_limit)
    )
    taken_result = await db.execute(
        taken_query.order_by(models.Task.created_at.desc())
                  .offset(taken_skip)
                  .limit(taken_limit)
    )
    
    posted_tasks = list(posted_result.scalars().all())
    taken_tasks = list(taken_result.scalars().all())
    
    # è·å–æ€»æ•°ï¼ˆå¯é€‰ï¼Œå¦‚æœå‰ç«¯éœ€è¦ï¼‰
    posted_count_query = select(func.count()).select_from(
        posted_query.subquery()
    )
    taken_count_query = select(func.count()).select_from(
        taken_query.subquery()
    )
    posted_total = (await db.execute(posted_count_query)).scalar() or 0
    taken_total = (await db.execute(taken_count_query)).scalar() or 0
    
    return {
        "posted": posted_tasks,
        "taken": taken_tasks,
        "total_posted": posted_total,
        "total_taken": taken_total,
        "posted_has_more": len(posted_tasks) == posted_limit,
        "taken_has_more": len(taken_tasks) == taken_limit
    }
```

**ä¼˜åŒ–å**ï¼ˆæ–¹æ¡ˆBï¼šåˆå¹¶ç»Ÿä¸€æ—¶é—´çº¿ï¼Œä½¿ç”¨æ¸¸æ ‡åˆ†é¡µï¼Œæ¨èå®ç°ï¼‰:
```python
@staticmethod
async def get_user_tasks_unified(
    db: AsyncSession, 
    user_id: str, 
    task_type: str = "all",
    cursor: Optional[str] = None,
    limit: int = 50,
    with_reviews: bool = False
) -> tuple[List[Dict[str, Any]], Optional[str]]:
    """è·å–ç”¨æˆ·çš„ä»»åŠ¡ï¼ˆåˆå¹¶ä¸ºç»Ÿä¸€æ—¶é—´çº¿ï¼‰ï¼Œä½¿ç”¨æ¸¸æ ‡åˆ†é¡µ"""
    from sqlalchemy import case
    from app.utils.time_utils import parse_iso_utc, format_iso_utc
    
    # å•è¡¨æŸ¥è¯¢ + or_ æ¡ä»¶ï¼ˆæ¯” union_all æ›´ç®€å•ã€æ›´ç¨³å®šï¼‰
    query = (
        select(
            models.Task,
            case(
                (models.Task.poster_id == user_id, "posted"),
                else_="taken"
            ).label("task_role")
        )
        .options(
            selectinload(models.Task.poster),
            selectinload(models.Task.taker)
        )
        .where(
            or_(
                models.Task.poster_id == user_id,
                models.Task.taker_id == user_id
            )
        )
    )
    
    # åº”ç”¨ä»»åŠ¡ç±»å‹ç­›é€‰
    if task_type and task_type != "all":
        query = query.where(models.Task.task_type == task_type)
    
    # åˆ—è¡¨æ¥å£é»˜è®¤ä¸åŠ è½½ reviewsï¼ˆè¯¦æƒ…æ¥å£æ‰éœ€è¦ï¼‰
    if with_reviews:
        query = query.options(selectinload(models.Task.reviews))
    
    # åº”ç”¨æ¸¸æ ‡ï¼ˆåŸºäºåˆ›å»ºæ—¶é—´å’ŒIDï¼‰
    if cursor:
        try:
            cursor_parts = cursor.split('_', 1)
            if len(cursor_parts) == 2:
                cursor_time_str, cursor_id_str = cursor_parts
                cursor_time = parse_iso_utc(cursor_time_str.replace('Z', '+00:00'))
                cursor_id = int(cursor_id_str)
                
                # æŸ¥è¯¢æ›´æ—§çš„ä»»åŠ¡
                query = query.where(
                    or_(
                        models.Task.created_at < cursor_time,
                        and_(
                            models.Task.created_at == cursor_time,
                            models.Task.id < cursor_id
                        )
                    )
                )
        except (ValueError, IndexError) as e:
            logger.warning("Invalid cursor for user tasks: %s, error: %s", cursor, e)
    
    # æ’åºå’Œåˆ†é¡µ
    query = query.order_by(models.Task.created_at.desc(), models.Task.id.desc())
    
    # æŸ¥è¯¢ limit + 1 æ¡ï¼Œç”¨äºåˆ¤æ–­æ˜¯å¦æœ‰æ›´å¤š
    result = await db.execute(query.limit(limit + 1))
    rows = result.all()
    
    # åˆ¤æ–­æ˜¯å¦æœ‰æ›´å¤š
    has_more = len(rows) > limit
    if has_more:
        rows = rows[:limit]
    
    # æ„å»ºç»“æœ
    tasks = []
    for row in rows:
        task = row[0]  # Task å¯¹è±¡
        task_role = row[1]  # "posted" æˆ– "taken"
        tasks.append({
            "task": task,
            "role": task_role
        })
    
    # ç”Ÿæˆä¸‹ä¸€ä¸ªæ¸¸æ ‡
    next_cursor = None
    if has_more and rows:
        last_task = rows[-1][0]
        next_cursor = f"{format_iso_utc(last_task.created_at)}_{last_task.id}"
    
    return tasks, next_cursor
```

**è¯´æ˜**:
- ä½¿ç”¨å•è¡¨æŸ¥è¯¢ + `or_` æ¡ä»¶ï¼Œæ¯” `union_all` æ›´ç®€å•ã€æ›´ç¨³å®š
- æ¸¸æ ‡æ¡ä»¶å’Œæ’åºéƒ½åœ¨åŒä¸€å±‚å¤„ç†ï¼Œé¿å…ä¸ `union_all` çš„å…¼å®¹æ€§é—®é¢˜
- ä»£ç å¯è¯»æ€§å’Œå¯ç»´æŠ¤æ€§æ›´é«˜

**æç«¯è¾¹ç•Œæƒ…å†µè¯´æ˜**:
- å¦‚æœå‡ºç°ã€Œè‡ªå·±ç»™è‡ªå·±å‘ä»»åŠ¡ã€çš„æƒ…å†µï¼ˆ`poster_id == taker_id == user_id`ï¼‰ï¼Œ`case` åˆ†æ”¯ä¼šç»Ÿä¸€åˆ¤æˆ `"posted"`ï¼Œä¸ä¼šæœ‰ `"taken"` è§’è‰²è®°å½•ã€‚ä¸šåŠ¡ä¸Šä¸€èˆ¬æ— æ‰€è°“ï¼Œä½†å›¢é˜Ÿéœ€è¦çŸ¥æƒ…ã€‚
- ç»Ÿä¸€æ—¶é—´çº¿ç›®å‰ä¸»è¦æŒ‰ `created_at + id` æ’åºï¼Œå¦‚æœåç»­æƒ³æ”¯æŒæŒ‰ `deadline` æˆ–å…¶ä»–å­—æ®µæ’åºï¼Œéœ€è¦å•ç‹¬è®¾è®¡å¯¹åº”çš„æ¸¸æ ‡ï¼ˆä¸ä»»åŠ¡ä¸»åˆ—è¡¨çš„æ¸¸æ ‡åˆ†é¡µçº¦æŸä¸€è‡´ï¼Œæ¸¸æ ‡åªå¯¹æŒ‰æ—¶é—´æ’åºä¸¥æ ¼æ­£ç¡®ï¼‰ã€‚

---

### ä¼˜åŒ–æ–¹æ¡ˆ 2: å…³é”®è¯æœç´¢æ€§èƒ½ä¼˜åŒ– (P1)

#### 2.1 ä½¿ç”¨ PostgreSQL å…¨æ–‡æœç´¢

**æ–‡ä»¶**: `backend/app/async_crud.py:305-315`

**ä¼˜åŒ–å‰**:
```python
if keyword:
    keyword = keyword.strip()
    query = query.where(
        or_(
            func.similarity(models.Task.title, keyword) > 0.2,
            func.similarity(models.Task.description, keyword) > 0.2,
            models.Task.title.ilike(f"%{keyword}%"),
            models.Task.description.ilike(f"%{keyword}%")
        )
    )
```

**ä¼˜åŒ–å**ï¼ˆä¸¤ç§æ–¹æ¡ˆäºŒé€‰ä¸€ï¼‰:

**æ–¹æ¡ˆ1: ä½¿ç”¨ pg_trgm æ‰©å±•ï¼ˆé€‚åˆæ¨¡ç³ŠåŒ¹é…å’Œå®¹é”™æœç´¢ï¼‰**
```python
# é…ç½®é¡¹ï¼šUSE_PG_TRGM = True
# ä¼˜åŠ¿ï¼šæ”¯æŒæ¨¡ç³ŠåŒ¹é…ã€æ‹¼å†™å®¹é”™ã€éƒ¨åˆ†åŒ¹é…ï¼Œå¯¹ä¸­è‹±æ–‡éƒ½é€‚ç”¨
if keyword:
    keyword = keyword.strip()
    
    # ä½¿ç”¨ pg_trgm ç›¸ä¼¼åº¦æœç´¢ï¼ˆéœ€è¦å…ˆåˆ›å»ºç´¢å¼•ï¼‰
    # ç¡®ä¿å·²åˆ›å»ºç´¢å¼•: CREATE INDEX idx_tasks_title_trgm ON tasks USING gin(title gin_trgm_ops);
    query = query.where(
        or_(
            func.similarity(models.Task.title, keyword) > 0.2,
            func.similarity(models.Task.description, keyword) > 0.2
        )
    ).order_by(
        func.similarity(models.Task.title, keyword).desc(),
        func.similarity(models.Task.description, keyword).desc()
    )
```

**æ–¹æ¡ˆ2: ä½¿ç”¨ PostgreSQL å…¨æ–‡æœç´¢ï¼ˆé€‚åˆç²¾ç¡®åŒ¹é…å’Œç›¸å…³æ€§æ’åºï¼Œæ¨èä½¿ç”¨ SQLAlchemy å‡½æ•°å¼å†™æ³•ï¼‰**
```python
# é…ç½®é¡¹ï¼šUSE_PG_TRGM = False
if keyword:
    keyword = keyword.strip()
    
    # ä½¿ç”¨ SQLAlchemy å‡½æ•°å¼å†™æ³•ï¼ˆæ¨èï¼Œä¾¿äºé…ç½®å’Œè¿ç§»ï¼‰
    from sqlalchemy import func
    
    # æ„å»ºå…¨æ–‡æœç´¢å‘é‡å’ŒæŸ¥è¯¢
    ts_vector = func.to_tsvector('english', models.Task.title + ' ' + models.Task.description)
    ts_query = func.plainto_tsquery('english', keyword)
    
    # ä½¿ç”¨æ“ä½œç¬¦ @@ è¿›è¡Œå…¨æ–‡æœç´¢åŒ¹é…
    query = query.where(ts_vector.op('@@')(ts_query))
    
    # å¯é€‰ï¼šæŒ‰ç›¸å…³æ€§æ’åº
    # query = query.order_by(func.ts_rank(ts_vector, ts_query).desc())
```

**ä¸¤ç§æ–¹æ¡ˆå¯¹æ¯”**:

| ç‰¹æ€§ | pg_trgm | å…¨æ–‡æœç´¢ |
|------|---------|----------|
| **é€‚ç”¨è¯­è¨€** | ä¸­è‹±æ–‡éƒ½é€‚ç”¨ | ä¸»è¦é’ˆå¯¹è‹±æ–‡ï¼ˆä¸­æ–‡éœ€è¦é¢å¤–é…ç½®ï¼‰ |
| **æ¨¡ç³ŠåŒ¹é…** | âœ… ä¼˜ç§€ï¼ˆæ”¯æŒæ‹¼å†™é”™è¯¯ã€éƒ¨åˆ†åŒ¹é…ï¼‰ | âŒ ä¸æ”¯æŒ |
| **ç›¸ä¼¼åº¦æ’åº** | âœ… æ”¯æŒï¼ˆæŒ‰ç›¸ä¼¼åº¦åˆ†æ•°æ’åºï¼‰ | âœ… æ”¯æŒï¼ˆæŒ‰ç›¸å…³æ€§æ’åºï¼‰ |
| **æ€§èƒ½** | å¿«ï¼ˆGIN ç´¢å¼•ï¼‰ | å¿«ï¼ˆGIN ç´¢å¼•ï¼‰ |
| **è¯å¹²æå–** | âŒ ä¸æ”¯æŒ | âœ… æ”¯æŒï¼ˆå¦‚ "running" åŒ¹é… "run"ï¼‰ |
| **åœç”¨è¯è¿‡æ»¤** | âŒ ä¸æ”¯æŒ | âœ… æ”¯æŒï¼ˆè¿‡æ»¤ "the", "a" ç­‰ï¼‰ |
| **æœ€ä½³åœºæ™¯** | ç”¨æˆ·è¾“å…¥å¯èƒ½æœ‰æ‹¼å†™é”™è¯¯ã€éœ€è¦å®¹é”™æœç´¢ | ç²¾ç¡®æœç´¢ã€éœ€è¦è¯å¹²åŒ¹é… |

**æ¨èå®ç°æ–¹å¼ï¼ˆæ”¯æŒé…ç½®åˆ‡æ¢ï¼‰**:
```python
# åœ¨é…ç½®æ–‡ä»¶ä¸­
USE_PG_TRGM = os.getenv("USE_PG_TRGM", "false").lower() == "true"
SEARCH_LANGUAGE = os.getenv("SEARCH_LANGUAGE", "english")  # æ”¯æŒåˆ‡æ¢è¯­è¨€

# åœ¨æŸ¥è¯¢å‡½æ•°ä¸­
if keyword:
    keyword = keyword.strip()
    
    if USE_PG_TRGM:
        # æ–¹æ¡ˆ1: pg_trgmï¼ˆé€‚åˆéœ€è¦å®¹é”™æœç´¢çš„åœºæ™¯ï¼Œä¸­è‹±æ–‡éƒ½é€‚ç”¨ï¼‰
        query = query.where(
            or_(
                func.similarity(models.Task.title, keyword) > 0.2,
                func.similarity(models.Task.description, keyword) > 0.2
            )
        ).order_by(
            func.similarity(models.Task.title, keyword).desc(),
            func.similarity(models.Task.description, keyword).desc(),
            # æ·»åŠ ç¨³å®šçš„ tie-breakerï¼Œé¿å…ç›¸ä¼¼åº¦æ¥è¿‘æ—¶é¡ºåºæŠ–åŠ¨
            # åŒæ—¶åˆ©äºåˆ©ç”¨å¤åˆç´¢å¼• (status, created_at, id)
            models.Task.created_at.desc(),
            models.Task.id.desc()
        )
    else:
        # æ–¹æ¡ˆ2: å…¨æ–‡æœç´¢ï¼ˆé€‚åˆç²¾ç¡®æœç´¢ï¼Œä¸»è¦é’ˆå¯¹è‹±æ–‡ï¼‰
        ts_vector = func.to_tsvector(SEARCH_LANGUAGE, 
                                     models.Task.title + ' ' + models.Task.description)
        ts_query = func.plainto_tsquery(SEARCH_LANGUAGE, keyword)
        query = query.where(ts_vector.op('@@')(ts_query))
        # å¯é€‰ï¼šæŒ‰ç›¸å…³æ€§æ’åº
        # query = query.order_by(func.ts_rank(ts_vector, ts_query).desc())
```

**æ•°æ®åº“è¿ç§»è„šæœ¬**:
```sql
-- 1. å¯ç”¨ pg_trgm æ‰©å±•
CREATE EXTENSION IF NOT EXISTS pg_trgm;

-- 2. åˆ›å»º GIN ç´¢å¼•ï¼ˆç”¨äºç›¸ä¼¼åº¦æœç´¢ï¼‰
CREATE INDEX IF NOT EXISTS idx_tasks_title_trgm 
ON tasks USING gin(title gin_trgm_ops);

CREATE INDEX IF NOT EXISTS idx_tasks_description_trgm 
ON tasks USING gin(description gin_trgm_ops);

-- 3. åˆ›å»ºå…¨æ–‡æœç´¢ç´¢å¼•ï¼ˆå¯é€‰ï¼Œæ›´å¼ºå¤§ä½†æ›´å¤æ‚ï¼‰
CREATE INDEX IF NOT EXISTS idx_tasks_search 
ON tasks USING gin(to_tsvector('english', title || ' ' || description));
```

**æ€§èƒ½æå‡**: æœç´¢é€Ÿåº¦æå‡ 10-100 å€ï¼ˆå–å†³äºæ•°æ®é‡ï¼‰

---

### ä¼˜åŒ–æ–¹æ¡ˆ 3: åˆ†é¡µæŸ¥è¯¢ä¼˜åŒ– (P2)

#### 3.1 å®ç°æ¸¸æ ‡åˆ†é¡µ

**æ–‡ä»¶**: `backend/app/async_crud.py:260-345`

**å®Œæ•´å®ç°**:
```python
from typing import Optional, List, Tuple
from sqlalchemy import select, or_, and_, func
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload
from app import models
from app.core.config import USE_PG_TRGM, SEARCH_LANGUAGE
from app.utils.time_utils import parse_iso_utc, format_iso_utc
from app.core.logger import logger

class AsyncTaskCrud:
    @staticmethod
    async def get_tasks_cursor(
        db: AsyncSession,
        cursor: Optional[str] = None,
        limit: int = 20,
        task_type: Optional[str] = None,
        location: Optional[str] = None,
        keyword: Optional[str] = None,
        sort_by: str = "latest",  # åªæ”¯æŒ latest / oldest
    ) -> Tuple[List[models.Task], Optional[str]]:
        """
        ä½¿ç”¨æ¸¸æ ‡åˆ†é¡µè·å–ä»»åŠ¡åˆ—è¡¨ã€‚
        
        çº¦æŸï¼š
        - åªåœ¨ sort_by ä¸º "latest" / "oldest" æ—¶ä½¿ç”¨
        - æ¸¸æ ‡æ ¼å¼: "<ISO8601æ—¶é—´>_<id>"ï¼Œä¾‹å¦‚ "2025-01-27T12:00:00Z_123"
        """
        
        # 1. ä»…å¯¹æ—¶é—´æ’åºåœºæ™¯å¯ç”¨ï¼Œå…¶ä»–æ’åºè¯·ç”¨ offset/limit
        if sort_by not in ("latest", "oldest"):
            raise ValueError("get_tasks_cursor ä»…æ”¯æŒ sort_by=latest/oldest")
        
        query = (
            select(models.Task)
            .options(selectinload(models.Task.poster))
            .where(models.Task.status == "open")
        )
        
        # ç­›é€‰æ¡ä»¶ï¼šå’Œ /tasks ä¿æŒä¸€è‡´
        if task_type and task_type not in ["å…¨éƒ¨ç±»å‹", "å…¨éƒ¨", "all"]:
            query = query.where(models.Task.task_type == task_type)
        
        if location and location not in ["å…¨éƒ¨åŸå¸‚", "å…¨éƒ¨", "all"]:
            query = query.where(models.Task.location == location)
        
        if keyword:
            keyword = keyword.strip()
            if USE_PG_TRGM:
                query = query.where(
                    or_(
                        func.similarity(models.Task.title, keyword) > 0.2,
                        func.similarity(models.Task.description, keyword) > 0.2,
                    )
                )
                # æ³¨æ„ï¼šæ’åºä¼šåœ¨åé¢ç»Ÿä¸€å¤„ç†ï¼ŒåŒ…å« tie-breaker
            else:
                ts_vector = func.to_tsvector(
                    SEARCH_LANGUAGE,
                    models.Task.title + " " + models.Task.description,
                )
                ts_query = func.plainto_tsquery(SEARCH_LANGUAGE, keyword)
                query = query.where(ts_vector.op("@@")(ts_query))
        
        # 2. åº”ç”¨æ¸¸æ ‡æ¡ä»¶ï¼ˆåŸºäº created_at + idï¼‰
        if cursor:
            try:
                ts, id_str = cursor.split("_", 1)
                cursor_time = parse_iso_utc(ts.replace("Z", "+00:00"))
                cursor_id = int(id_str)
                
                if sort_by == "latest":
                    # å‘åç¿»é¡µï¼šæ›´æ—§çš„æ•°æ®
                    query = query.where(
                        or_(
                            models.Task.created_at < cursor_time,
                            and_(
                                models.Task.created_at == cursor_time,
                                models.Task.id < cursor_id,
                            ),
                        )
                    )
                else:
                    # sort_by == "oldest"ï¼Œå‘åç¿»é¡µï¼šæ›´"æ–°"çš„æ•°æ®
                    query = query.where(
                        or_(
                            models.Task.created_at > cursor_time,
                            and_(
                                models.Task.created_at == cursor_time,
                                models.Task.id > cursor_id,
                            ),
                        )
                    )
            except Exception as e:
                logger.warning("Invalid cursor for tasks: %s, error: %s", cursor, e)
        
        # 3. æ’åºï¼ˆå¿…é¡»ä¸æ¸¸æ ‡æ¡ä»¶ä¸€è‡´ï¼‰
        if sort_by == "latest":
            query = query.order_by(
                models.Task.created_at.desc(), models.Task.id.desc()
            )
        else:  # oldest
            query = query.order_by(
                models.Task.created_at.asc(), models.Task.id.asc()
            )
        
        # 4. æŸ¥è¯¢ limit + 1 æ¡ï¼Œç”¨äºåˆ¤æ–­æ˜¯å¦æœ‰æ›´å¤š
        result = await db.execute(query.limit(limit + 1))
        tasks = list(result.scalars().all())
        
        has_more = len(tasks) > limit
        if has_more:
            tasks = tasks[:limit]
        
        # 5. ç”Ÿæˆä¸‹ä¸€é¡µæ¸¸æ ‡
        next_cursor = None
        if has_more and tasks:
            last = tasks[-1]
            next_cursor = f"{format_iso_utc(last.created_at)}_{last.id}"
        
        return tasks, next_cursor
```

**ä¼˜åŠ¿**:
- æ·±åˆ†é¡µæ€§èƒ½æ›´å¥½ï¼ˆO(1) vs O(n)ï¼‰
- é¿å…æ•°æ®é‡å¤å’Œé—æ¼
- é€‚åˆå®æ—¶æ•°æ®æµ

**é‡è¦çº¦æŸ**:
- âš ï¸ **æ¸¸æ ‡åˆ†é¡µå½“å‰åªå¯¹ã€ŒæŒ‰æ—¶é—´æ’åºã€çš„åœºæ™¯ä¿è¯ä¸¥æ ¼æ­£ç¡®**
- æ¸¸æ ‡åŸºäº `created_at + id` çš„ç»„åˆï¼Œå¦‚æœæ’åºå­—æ®µä¸æ˜¯æ—¶é—´ï¼ˆå¦‚ `reward_high`ã€`deadline`ï¼‰ï¼Œæ¸¸æ ‡å­—æ®µå’Œæ’åºå­—æ®µä¸ä¸€è‡´ï¼Œæ·±ç¿»é¡µæ—¶å¯èƒ½å‡ºç°é‡å¤/é—æ¼
- **å»ºè®®**ï¼š
  - æŒ‰æ—¶é—´æ’åºçš„åœºæ™¯ï¼šä½¿ç”¨æ¸¸æ ‡åˆ†é¡µ
  - å…¶ä»–æ’åºæ–¹å¼ï¼šç»§ç»­ä½¿ç”¨ `offset/limit` åˆ†é¡µ
  - å¦‚éœ€æ”¯æŒå…¶ä»–æ’åºçš„æ¸¸æ ‡åˆ†é¡µï¼Œéœ€è¦å•ç‹¬è®¾è®¡å¯¹åº”çš„æ¸¸æ ‡å­—æ®µï¼ˆå¦‚ `reward + id`ã€`deadline + id`ï¼‰

#### 3.2 è·¯ç”±å±‚ä½¿ç”¨ç¤ºä¾‹

**æ–‡ä»¶**: `backend/app/async_routers.py`

**å®Œæ•´å®ç°**:
```python
from typing import Optional
from fastapi import APIRouter, Depends, Query
from sqlalchemy.ext.asyncio import AsyncSession
from app.database import get_async_db_dependency
from app import async_crud

router = APIRouter()

@router.get("/tasks")
async def list_tasks(
    db: AsyncSession = Depends(get_async_db_dependency),
    skip: int = Query(0, ge=0),
    limit: int = Query(20, ge=1, le=100),
    cursor: Optional[str] = Query(None),
    task_type: Optional[str] = Query(None),
    location: Optional[str] = Query(None),
    keyword: Optional[str] = Query(None),
    sort_by: str = Query("latest"),
):
    """
    è·å–ä»»åŠ¡åˆ—è¡¨
    
    åˆ†é¡µç­–ç•¥ï¼š
    - æ—¶é—´æ’åºï¼ˆlatest/oldestï¼‰ä¸”æä¾›äº† cursorï¼šä½¿ç”¨æ¸¸æ ‡åˆ†é¡µ
    - å…¶ä»–æƒ…å†µï¼šä½¿ç”¨ offset/limit + total
    """
    # æ—¶é—´æ’åºï¼šç”¨æ¸¸æ ‡åˆ†é¡µ
    if sort_by in ("latest", "oldest") and cursor is not None:
        tasks, next_cursor = await async_crud.async_task_crud.get_tasks_cursor(
            db=db,
            cursor=cursor,
            limit=limit,
            task_type=task_type,
            location=location,
            keyword=keyword,
            sort_by=sort_by,
        )
        return {
            "items": tasks,
            "next_cursor": next_cursor,
        }
    
    # å…¶ä»–æ’åºæˆ–åˆæ¬¡åŠ è½½ï¼šç”¨ offset/limit + total
    tasks, total = await async_crud.async_task_crud.get_tasks_with_total(
        db=db,
        skip=skip,
        limit=limit,
        task_type=task_type,
        location=location,
        status=None,  # é»˜è®¤ä½¿ç”¨ 'open'
        keyword=keyword,
        sort_by=sort_by,
    )
    return {
        "items": tasks,
        "total": total,
        "skip": skip,
        "limit": limit,
    }
```

**è¯´æ˜**:
- è·¯ç”±å±‚æ ¹æ® `sort_by` å’Œ `cursor` å‚æ•°è‡ªåŠ¨é€‰æ‹©åˆ†é¡µç­–ç•¥
- æ—¶é—´æ’åºä¸”æœ‰æ¸¸æ ‡ï¼šä½¿ç”¨ `get_tasks_cursor`ï¼Œè¿”å› `next_cursor`
- å…¶ä»–æƒ…å†µï¼šä½¿ç”¨ `get_tasks_with_total`ï¼Œè¿”å› `total`ã€`skip`ã€`limit`
- å‰ç«¯å¯ä»¥æ ¹æ®è¿”å›çš„å­—æ®µåˆ¤æ–­å½“å‰ä½¿ç”¨çš„åˆ†é¡µæ–¹å¼

---

### ä¼˜åŒ–æ–¹æ¡ˆ 4: ç¼“å­˜ç­–ç•¥ä¼˜åŒ– (P2)

#### 4.1 æ”¹è¿›ç¼“å­˜é”®è®¾è®¡

**æ–‡ä»¶**: `backend/app/redis_cache.py`

**ä¼˜åŒ–å‰**:
```python
# ç¼“å­˜é”®åŒ…å«æ‰€æœ‰å‚æ•°ï¼Œå¯¼è‡´ç¼“å­˜å‘½ä¸­ç‡ä½
cache_key = f"tasks:{skip}:{limit}:{task_type}:{location}:{status}:{keyword}:{sort_by}"
```

**ä¼˜åŒ–å**:
```python
import hashlib
import json

def get_tasks_cache_key(skip: int, limit: int, task_type: Optional[str], 
                        location: Optional[str], status: Optional[str],
                        keyword: Optional[str], sort_by: Optional[str]) -> str:
    """ç”Ÿæˆä»»åŠ¡åˆ—è¡¨ç¼“å­˜é”®ï¼ˆä½¿ç”¨å“ˆå¸Œé¿å…é”®è¿‡é•¿ï¼‰"""
    # æ„å»ºå‚æ•°å­—å…¸
    params = {
        "skip": skip,
        "limit": limit,
        "task_type": task_type or "all",
        "location": location or "all",
        "status": status or "all",
        "keyword": keyword or "",
        "sort_by": sort_by or "latest"
    }
    
    # å¯¹å‚æ•°è¿›è¡Œå“ˆå¸Œï¼ˆé¿å…é”®è¿‡é•¿ï¼‰
    params_str = json.dumps(params, sort_keys=True)
    params_hash = hashlib.md5(params_str.encode()).hexdigest()[:16]
    
    # ä½¿ç”¨ç‰ˆæœ¬å·å’Œå“ˆå¸Œ
    version = get_cache_version("tasks")
    return f"tasks:list:v{version}:{params_hash}"

def get_tasks_count_cache_key(task_type: Optional[str], 
                              location: Optional[str], 
                              status: Optional[str],
                              keyword: Optional[str]) -> str:
    """ç”Ÿæˆä»»åŠ¡æ€»æ•°ç¼“å­˜é”®ï¼ˆä¸åˆ—è¡¨ç¼“å­˜é”®ç»“æ„ç»Ÿä¸€ï¼ŒåªåŒ…å«å‚ä¸ count çš„è¿‡æ»¤æ¡ä»¶ï¼‰"""
    # æ„å»ºå‚æ•°å­—å…¸ï¼ˆä¸åŒ…å« skip/limit/sort_byï¼Œè¿™äº›ä¸å½±å“æ€»æ•°ï¼‰
    params = {
        "task_type": task_type or "all",
        "location": location or "all",
        "status": status or "all",
        "keyword": keyword or ""
    }
    
    # å¯¹å‚æ•°è¿›è¡Œå“ˆå¸Œ
    params_str = json.dumps(params, sort_keys=True)
    params_hash = hashlib.md5(params_str.encode()).hexdigest()[:16]
    
    # ä½¿ç”¨ç‰ˆæœ¬å·å’Œå“ˆå¸Œï¼ˆä¸åˆ—è¡¨ç¼“å­˜é”®ç»“æ„ç»Ÿä¸€ï¼‰
    version = get_cache_version("tasks")
    return f"tasks:count:v{version}:{params_hash}"
```

**è¯´æ˜**:
- åˆ—è¡¨ç¼“å­˜é”®ï¼š`tasks:list:v{version}:{params_hash}`ï¼ˆåŒ…å«æ‰€æœ‰å‚æ•°ï¼‰
- æ€»æ•°ç¼“å­˜é”®ï¼š`tasks:count:v{version}:{params_hash}`ï¼ˆåªåŒ…å«å½±å“ count çš„è¿‡æ»¤æ¡ä»¶ï¼‰
- ä¸¤ä¸ªç¼“å­˜é”®ä½¿ç”¨ç›¸åŒçš„ç‰ˆæœ¬å·å’Œå“ˆå¸Œç®—æ³•ï¼Œç»“æ„ç»Ÿä¸€ï¼Œä¾¿äºç»´æŠ¤
- å¯ä»¥æ ¹æ®åˆ—è¡¨ç¼“å­˜é”®ç›´æ¥æ¨å¯¼å‡ºå¯¹åº”çš„æ€»æ•°ç¼“å­˜é”®

#### 4.2 å®ç°ç¼“å­˜é¢„çƒ­

**æ–‡ä»¶**: `backend/app/redis_cache.py`

**æ–¹æ¡ˆAï¼šå¼‚æ­¥é¢„çƒ­ï¼ˆæ¨èï¼Œä½¿ç”¨ AsyncSessionï¼‰**
```python
async def warmup_tasks_cache():
    """å¼‚æ­¥é¢„çƒ­ä»»åŠ¡åˆ—è¡¨ç¼“å­˜ï¼ˆå¸¸ç”¨æŸ¥è¯¢ï¼‰"""
    from app.database import AsyncSessionLocal
    from app import async_crud
    
    async with AsyncSessionLocal() as db:
        # é¢„çƒ­å¸¸ç”¨æŸ¥è¯¢
        common_queries = [
            {"skip": 0, "limit": 20, "sort_by": "latest"},
            {"skip": 0, "limit": 20, "sort_by": "reward_high"},
            {"skip": 0, "limit": 20, "task_type": "delivery", "sort_by": "latest"},
            # ... å…¶ä»–å¸¸ç”¨æŸ¥è¯¢
        ]
        
        for params in common_queries:
            try:
                tasks = await async_crud.async_task_crud.get_tasks(
                    db, **params
                )
                # ç¼“å­˜ä¼šè‡ªåŠ¨å†™å…¥
            except Exception as e:
                logger.warning(f"é¢„çƒ­ç¼“å­˜å¤±è´¥: {params}, {e}")

# åœ¨å®šæ—¶ä»»åŠ¡ä¸­è°ƒç”¨ï¼ˆä¾‹å¦‚ä½¿ç”¨ APSchedulerï¼‰
# scheduler.add_job(warmup_tasks_cache, 'interval', minutes=5)
```

**æ–¹æ¡ˆBï¼šåŒæ­¥é¢„çƒ­ï¼ˆå¦‚æœå¿…é¡»ä½¿ç”¨åŒæ­¥ Sessionï¼‰**
```python
# éœ€è¦åˆ›å»ºä¸€ä¸ªåŒæ­¥ç‰ˆæœ¬çš„ CRUD å‡½æ•°ï¼Œå…±ç”¨æ ¸å¿ƒæŸ¥è¯¢é€»è¾‘
def warmup_tasks_cache_sync():
    """åŒæ­¥é¢„çƒ­ä»»åŠ¡åˆ—è¡¨ç¼“å­˜ï¼ˆä½¿ç”¨åŒæ­¥ Sessionï¼‰"""
    from app.database import SessionLocal
    from app.sync_crud import sync_task_crud  # åŒæ­¥ç‰ˆæœ¬çš„ CRUD
    
    db = SessionLocal()
    try:
        common_queries = [
            {"skip": 0, "limit": 20, "sort_by": "latest"},
            # ... å…¶ä»–å¸¸ç”¨æŸ¥è¯¢
        ]
        
        for params in common_queries:
            try:
                tasks = sync_task_crud.get_tasks(db, **params)
            except Exception as e:
                logger.warning(f"é¢„çƒ­ç¼“å­˜å¤±è´¥: {params}, {e}")
    finally:
        db.close()
```

---

### ä¼˜åŒ–æ–¹æ¡ˆ 5: æ•°æ®åº“ç´¢å¼•ä¼˜åŒ– (P1)

#### 5.1 æ·»åŠ å¤åˆç´¢å¼•

**æ–‡ä»¶**: `backend/app/models.py`

**éœ€è¦æ·»åŠ çš„ç´¢å¼•**:
```python
# ä»»åŠ¡è¡¨å¤åˆç´¢å¼•
Index("ix_tasks_status_created_id", Task.status, Task.created_at, Task.id)  # ç”¨äºæ¸¸æ ‡åˆ†é¡µ
Index("ix_tasks_type_location_status", Task.task_type, Task.location, Task.status)  # ç»„åˆæŸ¥è¯¢
Index("ix_tasks_poster_status_created", Task.poster_id, Task.status, Task.created_at)  # ç”¨æˆ·ä»»åŠ¡æŸ¥è¯¢
Index("ix_tasks_taker_status_created", Task.taker_id, Task.status, Task.created_at)  # ç”¨æˆ·ä»»åŠ¡æŸ¥è¯¢

# ç”³è¯·è¡¨ç´¢å¼•
Index("ix_applications_applicant_created", TaskApplication.applicant_id, TaskApplication.created_at)
Index("ix_applications_task_status", TaskApplication.task_id, TaskApplication.status)

# æ¶ˆæ¯è¡¨ç´¢å¼•ï¼ˆä¼˜åŒ–æ–¹æ¡ˆï¼šä½¿ç”¨ conversation_keyï¼‰
# æ³¨æ„ï¼šéœ€è¦åœ¨ Message æ¨¡å‹ä¸­æ·»åŠ  conversation_key å­—æ®µ
# conversation_key = Column(String, index=True)  # å€¼ä¸º: least(sender_id, receiver_id) || '-' || greatest(sender_id, receiver_id)
Index("ix_messages_conversation_created", Message.conversation_key, Message.created_at)
Index("ix_messages_receiver_created", Message.receiver_id, Message.created_at)

# é€šçŸ¥è¡¨ç´¢å¼•
Index("ix_notifications_user_read_created", Notification.user_id, Notification.is_read, Notification.created_at)
```

**æ•°æ®åº“è¿ç§»è„šæœ¬**:
```sql
-- ä»»åŠ¡è¡¨ç´¢å¼•
CREATE INDEX IF NOT EXISTS ix_tasks_status_created_id 
ON tasks(status, created_at DESC, id DESC)
WHERE status IN ('open', 'taken');

CREATE INDEX IF NOT EXISTS ix_tasks_type_location_status 
ON tasks(task_type, location, status)
WHERE status IN ('open', 'taken');

-- âš ï¸ é‡è¦ï¼šéƒ¨åˆ†ç´¢å¼•çš„ WHERE æ¡ä»¶å¿…é¡»ä¸æŸ¥è¯¢æ¡ä»¶ä¸¥æ ¼å¯¹é½
-- æ­¤ç´¢å¼•åªè¦†ç›– status IN ('open', 'taken') çš„æŸ¥è¯¢
-- æŸ¥è¯¢æ—¶å°½é‡ä½¿ç”¨ status = 'open' æˆ– status IN ('open', 'taken')
-- é¿å…ä½¿ç”¨ status != 'closed' è¿™ç§å½¢å¼ï¼ˆä¸èµ°éƒ¨åˆ†ç´¢å¼•ï¼‰
-- å¦‚æœåç»­æœ‰å¤§é‡æŸ¥è¯¢ completed / closed çŠ¶æ€çš„æ¥å£ï¼Œéœ€è¦æ–°å»ºå¯¹åº”çš„éƒ¨åˆ†ç´¢å¼•

CREATE INDEX IF NOT EXISTS ix_tasks_poster_status_created 
ON tasks(poster_id, status, created_at DESC);

CREATE INDEX IF NOT EXISTS ix_tasks_taker_status_created 
ON tasks(taker_id, status, created_at DESC);

-- ç”³è¯·è¡¨ç´¢å¼•
CREATE INDEX IF NOT EXISTS ix_applications_applicant_created 
ON task_applications(applicant_id, created_at DESC);

CREATE INDEX IF NOT EXISTS ix_applications_task_status 
ON task_applications(task_id, status);

-- æ¶ˆæ¯è¡¨ç´¢å¼•ï¼ˆä¼˜åŒ–æ–¹æ¡ˆï¼šä½¿ç”¨ conversation_keyï¼‰
-- 1. æ·»åŠ  conversation_key å­—æ®µï¼ˆå¦‚æœè¿˜æ²¡æœ‰ï¼‰
ALTER TABLE messages ADD COLUMN IF NOT EXISTS conversation_key VARCHAR(255);

-- 2. å¡«å…… conversation_keyï¼ˆä½¿ç”¨ least/greatest ç¡®ä¿ä¸€è‡´æ€§ï¼‰
UPDATE messages 
SET conversation_key = LEAST(sender_id::text, receiver_id::text) || '-' || 
                      GREATEST(sender_id::text, receiver_id::text)
WHERE conversation_key IS NULL;

-- 3. åˆ›å»ºç´¢å¼•
CREATE INDEX IF NOT EXISTS ix_messages_conversation_created 
ON messages(conversation_key, created_at DESC);

CREATE INDEX IF NOT EXISTS ix_messages_receiver_created 
ON messages(receiver_id, created_at DESC);

-- 4. æ·»åŠ è§¦å‘å™¨ï¼Œè‡ªåŠ¨ç»´æŠ¤ conversation_keyï¼ˆå¯é€‰ï¼‰
CREATE OR REPLACE FUNCTION update_message_conversation_key()
RETURNS TRIGGER AS $$
BEGIN
    NEW.conversation_key := LEAST(NEW.sender_id::text, NEW.receiver_id::text) || '-' || 
                           GREATEST(NEW.sender_id::text, NEW.receiver_id::text);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_conversation_key
BEFORE INSERT OR UPDATE ON messages
FOR EACH ROW
EXECUTE FUNCTION update_message_conversation_key();

-- é€šçŸ¥è¡¨ç´¢å¼•
CREATE INDEX IF NOT EXISTS ix_notifications_user_read_created 
ON notifications(user_id, is_read, created_at DESC);

-- åˆ†æè¡¨ï¼Œæ›´æ–°ç»Ÿè®¡ä¿¡æ¯
ANALYZE tasks;
ANALYZE task_applications;
ANALYZE messages;
ANALYZE notifications;
```

---

### ä¼˜åŒ–æ–¹æ¡ˆ 6: æ‰¹é‡æ“ä½œä¼˜åŒ– (P2)

#### 6.1 ä¼˜åŒ–æ‰¹é‡æŸ¥è¯¢

**æ–‡ä»¶**: `backend/app/query_optimizer.py`

**æ–°å¢å‡½æ•°**:
```python
@staticmethod
async def batch_get_tasks(
    db: AsyncSession, 
    task_ids: List[int],
    with_reviews: bool = False  # åˆ—è¡¨æ¥å£é»˜è®¤ä¸åŠ è½½ reviews
) -> Dict[int, models.Task]:
    """æ‰¹é‡è·å–ä»»åŠ¡ä¿¡æ¯ï¼Œé¿å…N+1æŸ¥è¯¢"""
    if not task_ids:
        return {}
    
    # å»é‡ï¼Œé˜²æ­¢é‡å¤æŸ¥è¯¢
    task_ids = list(set(task_ids))
    
    query = (
        select(models.Task)
        .options(
            selectinload(models.Task.poster),
            selectinload(models.Task.taker)
        )
        .where(models.Task.id.in_(task_ids))
    )
    
    # åˆ—è¡¨æ¥å£é»˜è®¤ä¸åŠ è½½ reviewsï¼ˆè¯¦æƒ…æ¥å£æ‰éœ€è¦ï¼‰
    if with_reviews:
        query = query.options(selectinload(models.Task.reviews))
    
    result = await db.execute(query)
    tasks = result.scalars().all()
    
    return {task.id: task for task in tasks}

@staticmethod
async def batch_get_users(db: AsyncSession, user_ids: List[str]) -> Dict[str, models.User]:
    """æ‰¹é‡è·å–ç”¨æˆ·ä¿¡æ¯ï¼Œé¿å…N+1æŸ¥è¯¢"""
    if not user_ids:
        return {}
    
    # å»é‡ï¼Œé˜²æ­¢é‡å¤æŸ¥è¯¢
    user_ids = list(set(user_ids))
    
    query = select(models.User).where(models.User.id.in_(user_ids))
    result = await db.execute(query)
    users = result.scalars().all()
    
    return {user.id: user for user in users}
```

**è¯´æ˜**:
- åˆ—è¡¨æ¥å£é»˜è®¤ä¸åŠ è½½ `reviews`ï¼Œå‡å°‘æ•°æ®é‡
- è¯¦æƒ…æ¥å£å¯é€šè¿‡ `with_reviews=True` åŠ è½½å®Œæ•´æ•°æ®
- å¯¹ ID åˆ—è¡¨è¿›è¡Œå»é‡ï¼Œé¿å…é‡å¤æŸ¥è¯¢

---

### ä¼˜åŒ–æ–¹æ¡ˆ 7: æ€»æ•°æŸ¥è¯¢ä¼˜åŒ– (P2)

#### 7.1 ä½¿ç”¨ä¼°ç®—æˆ–ç¼“å­˜æ€»æ•°

**æ–‡ä»¶**: `backend/app/async_crud.py:348-434`

**é‡è¦è¯´æ˜**:
- `reltuples` æ˜¯æ•´å¼ è¡¨çš„å¤§æ¦‚è¡Œæ•°ï¼Œ**å®Œå…¨ä¸è€ƒè™‘ç­›é€‰æ¡ä»¶**
- åªæœ‰åœ¨**çœŸæ­£æ²¡æœ‰ä»»ä½•è¿‡æ»¤æ¡ä»¶**æ—¶ï¼Œä¼°ç®—å€¼æ‰ç›¸å¯¹å‡†ç¡®
- ä¸€æ—¦æœ‰ç­›é€‰æ¡ä»¶ï¼ˆåŒ…æ‹¬é»˜è®¤çš„ `status='open'`ï¼‰ï¼Œä¼°ç®—å€¼å’ŒçœŸå®å€¼å¯èƒ½ç›¸å·®åå€ä»¥ä¸Š
- **ä¸¥æ ¼è§„åˆ™**ï¼šåœ¨æœ¬é¡¹ç›®ä¸­ï¼Œåªè¦ `status`/`task_type`/`location`/`keyword` ä»»æ„ä¸€ä¸ªæœ‰å€¼ï¼ˆ**åŒ…æ‹¬é»˜è®¤ `status='open'`**ï¼‰ï¼Œå°±è§†ä¸º"æœ‰ç­›é€‰"ï¼Œä¸€å¾‹ä¸ç”¨ `reltuples` ä¼°ç®—ï¼Œåªç”¨ç¼“å­˜ + ç²¾ç¡® count
- **åŸå› **ï¼šå³ä½¿å‰ç«¯æ²¡ä¼  `status`ï¼Œ`base_query` é‡Œä¹Ÿå¼ºåˆ¶åŠ äº† `status = 'open'` çš„è¿‡æ»¤ï¼Œä½† `reltuples` ä¼°ç®—çš„æ˜¯æ•´å¼ è¡¨çš„è¡Œæ•°ï¼Œå¦‚æœè¡¨é‡Œæœ‰å¤§é‡å·²å…³é—­/å·²åˆ é™¤ä»»åŠ¡ï¼Œä¼°ç®—å€¼ä¼šæ˜æ˜¾å¤§äºå®é™…å€¼

**å®Œæ•´å®ç°**:
```python
from typing import Optional, List, Tuple
from sqlalchemy import select, func, or_, and_
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload
from app import models
from app.core.config import USE_PG_TRGM, SEARCH_LANGUAGE
from app.redis_cache import get_tasks_count_cache_key
from app.core.redis import redis_client

class AsyncTaskCrud:
    @staticmethod
    async def get_tasks_with_total(
        db: AsyncSession,
        skip: int = 0,
        limit: int = 100,
        task_type: Optional[str] = None,
        location: Optional[str] = None,
        status: Optional[str] = None,
        keyword: Optional[str] = None,
        sort_by: Optional[str] = "latest",
    ) -> Tuple[List[models.Task], int]:
        """
        è·å–ä»»åŠ¡åˆ—è¡¨ + æ€»æ•°ï¼ˆä½¿ç”¨ç¼“å­˜ + ç²¾ç¡® countï¼Œä¸ç”¨ reltuples ä¼°ç®—ï¼‰
        
        è§„åˆ™çº¦æŸï¼š
        - å³ä½¿ status ä¸º Noneï¼Œä¹Ÿé»˜è®¤è§†ä¸º status='open'ï¼Œè¿™ä¹Ÿç®—"æœ‰ç­›é€‰"
        - åªè¦ status / task_type / location / keyword ä»»ä¸€æœ‰å€¼ï¼Œå°±è§†ä¸º"æœ‰ç­›é€‰"
        - æœ¬å‡½æ•°ç»Ÿä¸€ä½¿ç”¨ç¼“å­˜ + ç²¾ç¡® countï¼Œä¸å†ä½¿ç”¨ reltuples ä¼°ç®—
        """
        
        # 1. æ„å»º base_queryï¼ˆåˆ—è¡¨ & æ€»æ•°å…±ç”¨ï¼‰
        actual_status = status or "open"
        base_query = select(models.Task).where(models.Task.status == actual_status)
        
        # ä»»åŠ¡ç±»å‹ç­›é€‰
        if task_type and task_type not in ["å…¨éƒ¨ç±»å‹", "å…¨éƒ¨", "all"]:
            base_query = base_query.where(models.Task.task_type == task_type)
        
        # åœ°ç‚¹ç­›é€‰
        if location and location not in ["å…¨éƒ¨åŸå¸‚", "å…¨éƒ¨", "all"]:
            base_query = base_query.where(models.Task.location == location)
        
        # å…³é”®è¯ç­›é€‰ï¼ˆå’Œ /tasks çš„å®ç°ä¿æŒä¸€è‡´ï¼‰
        if keyword:
            keyword = keyword.strip()
            if USE_PG_TRGM:
                # pg_trgm ç›¸ä¼¼åº¦æœç´¢
                base_query = base_query.where(
                    or_(
                        func.similarity(models.Task.title, keyword) > 0.2,
                        func.similarity(models.Task.description, keyword) > 0.2,
                    )
                ).order_by(
                    func.similarity(models.Task.title, keyword).desc(),
                    func.similarity(models.Task.description, keyword).desc(),
                    # æ·»åŠ ç¨³å®šçš„ tie-breakerï¼Œé¿å…ç›¸ä¼¼åº¦æ¥è¿‘æ—¶é¡ºåºæŠ–åŠ¨
                    models.Task.created_at.desc(),
                    models.Task.id.desc(),
                )
            else:
                # å…¨æ–‡æœç´¢
                ts_vector = func.to_tsvector(
                    SEARCH_LANGUAGE,
                    models.Task.title + " " + models.Task.description,
                )
                ts_query = func.plainto_tsquery(SEARCH_LANGUAGE, keyword)
                base_query = base_query.where(ts_vector.op("@@")(ts_query))
                # å¦‚éœ€ç›¸å…³æ€§æ’åºå¯ä»¥åŠ  ts_rankï¼Œè¿™é‡Œå…ˆæŒ‰æ—¶é—´ä¿è¯ç¨³å®š
                # base_query = base_query.order_by(func.ts_rank(ts_vector, ts_query).desc())
        
        # 2. å…ˆç®— totalï¼ˆç¼“å­˜ + ç²¾ç¡® countï¼‰
        cache_key = get_tasks_count_cache_key(
            task_type=task_type,
            location=location,
            status=actual_status,  # åŒ…å«é»˜è®¤ 'open'
            keyword=keyword,
        )
        
        cached_total = await redis_client.get(cache_key)
        if cached_total is not None:
            try:
                total = int(cached_total)
            except ValueError:
                total = 0
        else:
            count_query = select(func.count()).select_from(base_query.subquery())
            total_result = await db.execute(count_query)
            total = total_result.scalar() or 0
            # TTL å¯ä»¥æŒ‰éœ€è°ƒæ•´
            await redis_client.setex(cache_key, 300, str(total))
        
        # 3. åˆ—è¡¨æŸ¥è¯¢ï¼ˆåŸºäºåŒä¸€ä¸ª base_queryï¼‰
        list_query = base_query.options(
            selectinload(models.Task.poster)
        )
        
        # æ’åºï¼šæ³¨æ„å’Œ get_tasks_cursor çš„çº¦æŸä¿æŒä¸€è‡´
        if sort_by == "latest":
            list_query = list_query.order_by(
                models.Task.created_at.desc(), models.Task.id.desc()
            )
        elif sort_by == "oldest":
            list_query = list_query.order_by(
                models.Task.created_at.asc(), models.Task.id.asc()
            )
        elif sort_by == "reward_high":
            list_query = list_query.order_by(
                models.Task.reward.desc(), models.Task.created_at.desc()
            )
        elif sort_by == "reward_low":
            list_query = list_query.order_by(
                models.Task.reward.asc(), models.Task.created_at.asc()
            )
        elif sort_by == "deadline":
            list_query = list_query.order_by(
                models.Task.deadline.asc().nulls_last(),
                models.Task.created_at.desc(),
            )
        else:
            # é»˜è®¤æŒ‰æœ€æ–°
            list_query = list_query.order_by(
                models.Task.created_at.desc(), models.Task.id.desc()
            )
        
        list_query = list_query.offset(skip).limit(limit)
        
        result = await db.execute(list_query)
        tasks = list(result.scalars().all())
        
        return tasks, total
```

**ç¼“å­˜æ›´æ–°ç­–ç•¥**:
```python
# åœ¨ä»»åŠ¡åˆ›å»º/æ›´æ–°/åˆ é™¤æ—¶ï¼Œå¼‚æ­¥æ›´æ–°ç›¸å…³ç¼“å­˜
async def invalidate_task_count_cache(task_type: Optional[str] = None, 
                                      location: Optional[str] = None):
    """ä½¿ä»»åŠ¡æ€»æ•°ç¼“å­˜å¤±æ•ˆ"""
    # æ–¹æ¡ˆ1: ä½¿ç”¨ KEYSï¼ˆé€‚åˆå°é¡¹ç›®ï¼Œkey ä¸å¤šæ—¶ï¼‰
    # æ³¨æ„ï¼šKEYS æ˜¯ O(N) æ“ä½œï¼Œkey å¾ˆå¤šæ—¶ä¼šé˜»å¡ Redis
    # ç°é˜¶æ®µè¿™æ ·å†™å®Œå…¨å¯ä»¥å…ˆä¸Šï¼Œä½†è¦æœ‰å¿ƒç†é¢„æœŸ
    pattern = f"tasks:count:*"
    keys = await redis_client.keys(pattern)
    if keys:
        await redis_client.delete(*keys)
    
    # æ–¹æ¡ˆ2: ä½¿ç”¨ SCAN åˆ†æ‰¹åˆ é™¤ï¼ˆé€‚åˆ key å¾ˆå¤šæ—¶ï¼Œå¯é€‰ä¼˜åŒ–ï¼‰
    # å¦‚æœåç»­ä¸šåŠ¡è†¨èƒ€ï¼Œkey æ•°é‡å¾ˆå¤§ï¼Œå¯ä»¥è€ƒè™‘æ”¹ç”¨ SCANï¼š
    # cursor = 0
    # while True:
    #     cursor, keys = await redis_client.scan(cursor, match=pattern, count=100)
    #     if keys:
    #         await redis_client.delete(*keys)
    #     if cursor == 0:
    #         break
    
    # æ–¹æ¡ˆ3: ä½¿ç”¨ Set ç»´æŠ¤ç¼“å­˜é”®åˆ—è¡¨ï¼ˆæ›´å¤æ‚ï¼Œç°é˜¶æ®µ overkillï¼‰
    # æŠŠæ‰€æœ‰ count ç¼“å­˜é”®éƒ½æŒ‚åˆ°ä¸€ä¸ª set é‡Œï¼Œç”¨ SMEMBERS æ‰¾åˆ°å†åˆ 
    # ä½†ç°é˜¶æ®µä¸éœ€è¦è¿™ä¹ˆå¤æ‚ï¼ŒKEYS æ–¹æ¡ˆè¶³å¤Ÿç”¨
```

**Redis ç›‘æ§å»ºè®®**:
- âš ï¸ **ä¸Šçº¿åéœ€è¦ç›‘æ§ KEYS å‘½ä»¤çš„æ€§èƒ½**
- åœ¨ Redis ç›‘æ§ä¸­æ·»åŠ ä»¥ä¸‹æŒ‡æ ‡ï¼š
  - `KEYS` å‘½ä»¤çš„æ‰§è¡Œè€—æ—¶
  - Redis æ…¢æ—¥å¿—ï¼ˆæŸ¥çœ‹æ˜¯å¦æœ‰ `KEYS` å‘½ä»¤è¢«è®°å½•ï¼‰
  - å½“å‰ `tasks:count:*` æ¨¡å¼ä¸‹çš„ key æ•°é‡
- å¦‚æœå‘ç° `KEYS` å‘½ä»¤è€—æ—¶è¿‡é•¿ï¼ˆä¾‹å¦‚ > 10msï¼‰æˆ– key æ•°é‡è¿‡å¤šï¼ˆä¾‹å¦‚ > 1000ï¼‰ï¼Œè€ƒè™‘åˆ‡æ¢åˆ°æ–¹æ¡ˆ2ï¼ˆSCAN åˆ†æ‰¹åˆ é™¤ï¼‰
- å®šæœŸæ£€æŸ¥ Redis ç›‘æ§ï¼Œç¡®ä¿ç¼“å­˜å¤±æ•ˆæ“ä½œä¸ä¼šå½±å“ Redis æ€§èƒ½

---

### ä¼˜åŒ–æ–¹æ¡ˆ 8: æ¶ˆæ¯å¯¹è¯æŸ¥è¯¢ä¼˜åŒ– (P2)

#### 8.1 ä½¿ç”¨ conversation_key ä¼˜åŒ–å¯¹è¯æŸ¥è¯¢

**æ–‡ä»¶**: `backend/app/models.py`, `backend/app/async_crud.py:756-782`

**ä¼˜åŒ–æ€è·¯**:
- åœ¨ Message æ¨¡å‹ä¸­æ·»åŠ  `conversation_key` å­—æ®µ
- å€¼ä¸ºï¼š`least(sender_id, receiver_id) || '-' || greatest(sender_id, receiver_id)`
- è¿™æ ·æ— è®º sender/receiver å¦‚ä½•äº¤æ¢ï¼Œconversation_key éƒ½ä¿æŒä¸€è‡´
- åˆ›å»ºç´¢å¼• `(conversation_key, created_at)`ï¼Œæ‰€æœ‰å¯¹è¯æŸ¥è¯¢éƒ½èƒ½é«˜æ•ˆèµ°ç´¢å¼•

**æ¨¡å‹ä¿®æ”¹**:
```python
# backend/app/models.py
class Message(Base):
    # ... ç°æœ‰å­—æ®µ ...
    
    # æ–°å¢å­—æ®µï¼šå¯¹è¯é”®ï¼ˆç”¨äºä¼˜åŒ–æŸ¥è¯¢ï¼‰
    # æ³¨æ„ï¼šconversation_key ç”±æ•°æ®åº“è§¦å‘å™¨è‡ªåŠ¨ç»´æŠ¤ï¼Œåº”ç”¨å±‚ä¸éœ€è¦æ‰‹åŠ¨è®¾ç½®
    conversation_key = Column(String(255), index=True, nullable=True)
```

**ç»´æŠ¤ç­–ç•¥**ï¼ˆæ¨èï¼šå®Œå…¨ä¾èµ–æ•°æ®åº“è§¦å‘å™¨ï¼‰:
- âœ… **åªä¿ç•™æ•°æ®åº“è§¦å‘å™¨**ï¼Œåº”ç”¨å±‚ä¸éœ€è¦ç»´æŠ¤ `conversation_key`
- ä¼˜ç‚¹ï¼šä¸ä¼šå› ä¸ºæŸä¸ªåœ°æ–¹å¿˜è®°è®¾ç½®å¯¼è‡´ç´¢å¼•å¤±æ•ˆï¼Œç»´æŠ¤æˆæœ¬ä½
- åº”ç”¨å±‚åªéœ€è¦è®¾ç½® `sender_id` å’Œ `receiver_id`ï¼Œè§¦å‘å™¨ä¼šè‡ªåŠ¨ç”Ÿæˆ `conversation_key`

**æŸ¥è¯¢ä¼˜åŒ–**:
```python
# backend/app/async_crud.py
@staticmethod
async def get_conversation_messages(
    db: AsyncSession, 
    user1_id: str, 
    user2_id: str, 
    skip: int = 0, 
    limit: int = 50
) -> List[models.Message]:
    """è·å–ä¸¤ä¸ªç”¨æˆ·ä¹‹é—´çš„å¯¹è¯æ¶ˆæ¯ï¼ˆä¼˜åŒ–ç‰ˆæœ¬ï¼‰"""
    try:
        # æ„å»º conversation_keyï¼ˆä¸æ•°æ®åº“è§¦å‘å™¨é€»è¾‘ä¿æŒä¸€è‡´ï¼‰
        # ä½¿ç”¨ LEAST/GREATEST ç¡®ä¿æ— è®º sender/receiver å¦‚ä½•äº¤æ¢ï¼Œkey éƒ½ä¸€è‡´
        ids = [str(user1_id), str(user2_id)]
        conversation_key = f"{min(ids)}-{max(ids)}"
        
        # ä½¿ç”¨ conversation_key æŸ¥è¯¢ï¼ˆé«˜æ•ˆèµ°ç´¢å¼•ï¼‰
        result = await db.execute(
            select(models.Message)
            .where(models.Message.conversation_key == conversation_key)
            .order_by(models.Message.created_at.asc())
            .offset(skip)
            .limit(limit)
        )
        return list(result.scalars().all())
    except Exception as e:
        logger.error(f"Error getting conversation messages: {e}")
        return []
```

**æ•°æ®åº“è¿ç§»**ï¼ˆè§ä¸Šæ–¹ä¼˜åŒ–æ–¹æ¡ˆ 5.1 çš„ SQL è„šæœ¬ï¼‰

**æ€§èƒ½æå‡**: æŸ¥è¯¢é€Ÿåº¦æå‡ 5-10 å€ï¼ˆå–å†³äºæ•°æ®é‡ï¼‰

---

## ğŸ“ å®æ–½è®¡åˆ’

### ç¬¬ä¸€æ³¢ï¼šç«‹ç«¿è§å½±ï¼ˆ1-2å‘¨ï¼‰

1. **è§£å†³æ‰€æœ‰ N+1 æŸ¥è¯¢é—®é¢˜**
   - [ ] ä¼˜åŒ–ç”¨æˆ·ç”³è¯·åˆ—è¡¨æŸ¥è¯¢ï¼ˆä½¿ç”¨ selectinloadï¼‰
   - [ ] ä¼˜åŒ–ä»»åŠ¡ç”³è¯·åˆ—è¡¨æŸ¥è¯¢ï¼ˆæ‰¹é‡æŸ¥è¯¢ç”¨æˆ·ï¼‰
   - [ ] ä¼˜åŒ–ç”¨æˆ·ä»»åŠ¡åˆ—è¡¨æŸ¥è¯¢ï¼ˆæ·»åŠ  selectinloadï¼Œä¿®å¤åˆ†é¡µï¼‰
   - [ ] æ·»åŠ å¿…è¦çš„ `selectinload` åˆ°å…¶ä»–æ¥å£

2. **å»ºç«‹æ‰€æœ‰ç´¢å¼•**
   - [ ] åˆ›å»ºä»»åŠ¡è¡¨å¤åˆç´¢å¼•
   - [ ] åˆ›å»ºç”³è¯·è¡¨ç´¢å¼•
   - [ ] åˆ›å»ºæ¶ˆæ¯è¡¨ç´¢å¼•ï¼ˆåŒ…æ‹¬ conversation_key ä¼˜åŒ–ï¼‰
   - [ ] åˆ›å»ºé€šçŸ¥è¡¨ç´¢å¼•
   - [ ] éªŒè¯ç´¢å¼•ä½¿ç”¨æƒ…å†µï¼ˆEXPLAIN ANALYZEï¼‰

3. **ä¿®å¤ get_user_tasks åˆ†é¡µé—®é¢˜**
   - [ ] å®ç°æ–¹æ¡ˆAï¼ˆåˆ†åˆ«åˆ†é¡µï¼‰æˆ–æ–¹æ¡ˆBï¼ˆç»Ÿä¸€æ—¶é—´çº¿ï¼‰
   - [ ] æ›´æ–° API æ¥å£å‚æ•°
   - [ ] å‰ç«¯é€‚é…æ–°çš„åˆ†é¡µå‚æ•°

### ç¬¬äºŒæ³¢ï¼šä½“éªŒä¼˜åŒ–ï¼ˆ2-3å‘¨ï¼‰

4. **æ¸¸æ ‡åˆ†é¡µ + å‰ç«¯é€‚é…**
   - [ ] å®ç°æ¸¸æ ‡åˆ†é¡µæ¥å£
   - [ ] æ›´æ–° API æ¥å£ï¼ˆå¯ä»¥æ–°å¼€æ¥å£åšç°åº¦ï¼‰
   - [ ] å‰ç«¯é€‚é…æ¸¸æ ‡åˆ†é¡µ

5. **ç¼“å­˜ç­–ç•¥ä¼˜åŒ–**
   - [ ] æ”¹è¿›ç¼“å­˜é”®è®¾è®¡ï¼ˆä½¿ç”¨å“ˆå¸Œï¼‰
   - [ ] å®ç°ç¼“å­˜ç‰ˆæœ¬æœºåˆ¶
   - [ ] ä¼˜åŒ–ç¼“å­˜å¤±æ•ˆç­–ç•¥
   - [ ] å®ç°å¼‚æ­¥ç¼“å­˜é¢„çƒ­

### ç¬¬ä¸‰æ³¢ï¼šè¿›é˜¶ä¼˜åŒ–ï¼ˆå¯é€‰ï¼‰

6. **å…³é”®è¯æœç´¢ä¼˜åŒ–**
   - [ ] å¯ç”¨ `pg_trgm` æ‰©å±•æˆ–å…¨æ–‡æœç´¢
   - [ ] åˆ›å»º GIN ç´¢å¼•
   - [ ] æ›´æ–°æœç´¢æŸ¥è¯¢é€»è¾‘ï¼ˆä½¿ç”¨ SQLAlchemy å‡½æ•°å¼å†™æ³•ï¼‰
   - [ ] æ·»åŠ  feature flag åš A/B æµ‹è¯•

7. **æ€»æ•°ä¼°ç®— + ç›‘æ§**
   - [ ] å®ç°æ€»æ•°ä¼°ç®—ï¼ˆä»…åœ¨æ— ç­›é€‰æ—¶ï¼‰
   - [ ] å®ç°å¸¸ç”¨è¿‡æ»¤ç»„åˆçš„ count ç¼“å­˜
   - [ ] æ·»åŠ æ…¢æŸ¥è¯¢æ—¥å¿—
   - [ ] å®Œå–„æ€§èƒ½ç›‘æ§æŒ‡æ ‡


---

## âš ï¸ å®æ–½æ³¨æ„äº‹é¡¹

### å…³é”®å®æ–½è¦ç‚¹

#### 1. åˆ—è¡¨æŸ¥è¯¢å’Œæ€»æ•°æŸ¥è¯¢å¿…é¡»å…±ç”¨åŒä¸€ä¸ª base_query

**é‡è¦æ€§**: âš ï¸ **å¿…é¡»ä¸¥æ ¼éµå®ˆ**

**åŸå› **: å¦‚æœåˆ—è¡¨æŸ¥è¯¢å’Œæ€»æ•°æŸ¥è¯¢ä½¿ç”¨ä¸åŒçš„ç­›é€‰æ¡ä»¶ï¼Œä¼šå¯¼è‡´å‰ç«¯æ˜¾ç¤ºçš„æ€»æ•°å’Œå®é™…åˆ—è¡¨æ•°æ®ä¸ä¸€è‡´ï¼Œé€ æˆç”¨æˆ·ä½“éªŒé—®é¢˜ã€‚

**å®æ–½è¦æ±‚**:
```python
# âœ… æ­£ç¡®åšæ³•ï¼šå…ˆæ„å»º base_queryï¼Œå†è¡ç”Ÿ count å’Œ list
base_query = select(models.Task).where(models.Task.status == "open")

# åº”ç”¨æ‰€æœ‰ç­›é€‰æ¡ä»¶ï¼ˆåªå†™ä¸€æ¬¡ï¼‰
if task_type:
    base_query = base_query.where(models.Task.task_type == task_type)
if location:
    base_query = base_query.where(models.Task.location == location)
if keyword:
    base_query = base_query.where(...)  # å…³é”®è¯æœç´¢

# æ€»æ•°æŸ¥è¯¢ï¼šä½¿ç”¨ base_query
count_query = select(func.count()).select_from(base_query.subquery())

# åˆ—è¡¨æŸ¥è¯¢ï¼šä½¿ç”¨ base_query
list_query = base_query.options(...).order_by(...).offset(...).limit(...)
```

**âŒ é”™è¯¯åšæ³•**:
```python
# ä¸è¦åœ¨ä¸åŒåœ°æ–¹å„å†™ä¸€ä»½ç­›é€‰æ¡ä»¶
count_query = select(func.count()).where(...)  # ç­›é€‰æ¡ä»¶1
list_query = select(models.Task).where(...)    # ç­›é€‰æ¡ä»¶2ï¼ˆå¯èƒ½ä¸ä¸€è‡´ï¼‰
```

**æ£€æŸ¥æ–¹æ³•**: ä»£ç å®¡æŸ¥æ—¶ç¡®è®¤ `base_query` åªæ„å»ºä¸€æ¬¡ï¼Œcount å’Œ list éƒ½ä»å®ƒè¡ç”Ÿã€‚

---

#### 2. æ¸¸æ ‡åˆ†é¡µåªä¿è¯ã€ŒæŒ‰ created_at æ’åºã€æ—¶ä¸¥æ ¼æ­£ç¡®

**é‡è¦æ€§**: âš ï¸ **å¿…é¡»ä¸¥æ ¼éµå®ˆ**

**åŸå› **: æ¸¸æ ‡åŸºäº `created_at + id` çš„ç»„åˆï¼Œå¦‚æœæ’åºå­—æ®µä¸æ˜¯æ—¶é—´ï¼Œæ¸¸æ ‡å­—æ®µå’Œæ’åºå­—æ®µä¸ä¸€è‡´ï¼Œæ·±ç¿»é¡µæ—¶å¯èƒ½å‡ºç°é‡å¤/é—æ¼ã€‚

**å®æ–½è¦æ±‚**:
```python
# âœ… æ­£ç¡®åšæ³•ï¼šæŒ‰æ—¶é—´æ’åºæ—¶ä½¿ç”¨æ¸¸æ ‡åˆ†é¡µ
if sort_by in ["latest", "oldest"]:
    tasks, next_cursor = await get_tasks_cursor(db, cursor=cursor, sort_by=sort_by, ...)
else:
    # âŒ å…¶ä»–æ’åºæ–¹å¼ï¼ˆå¦‚ reward_highã€deadlineï¼‰ä½¿ç”¨ offset/limit
    tasks, total = await get_tasks_with_total(db, skip=skip, limit=limit, sort_by=sort_by, ...)
```

**æ£€æŸ¥æ–¹æ³•**: 
- ä»£ç å®¡æŸ¥æ—¶ç¡®è®¤æ¸¸æ ‡åˆ†é¡µåªåœ¨ `sort_by == "latest"` æˆ– `"oldest"` æ—¶ä½¿ç”¨
- å…¶ä»–æ’åºæ–¹å¼å¿…é¡»ä½¿ç”¨ `offset/limit`

---

#### 3. conversation_key å®Œå…¨äº¤ç»™æ•°æ®åº“è§¦å‘å™¨ç»´æŠ¤

**é‡è¦æ€§**: âš ï¸ **å¿…é¡»ä¸¥æ ¼éµå®ˆ**

**åŸå› **: å¦‚æœåº”ç”¨å±‚æ‰‹åŠ¨è®¾ç½® `conversation_key`ï¼Œå¯èƒ½å› ä¸ºæŸä¸ªåœ°æ–¹å¿˜è®°è®¾ç½®å¯¼è‡´ç´¢å¼•å¤±æ•ˆï¼Œé€ æˆæŸ¥è¯¢æ€§èƒ½é—®é¢˜ã€‚

**å®æ–½è¦æ±‚**:
```python
# âœ… æ­£ç¡®åšæ³•ï¼šåº”ç”¨å±‚åªè®¾ç½® sender_id å’Œ receiver_id
message = Message(
    sender_id=user1_id,
    receiver_id=user2_id,
    content="Hello"
    # ä¸è¦æ‰‹åŠ¨è®¾ç½® conversation_keyï¼Œè®©è§¦å‘å™¨è‡ªåŠ¨ç”Ÿæˆ
)
db.add(message)
```

**âŒ é”™è¯¯åšæ³•**:
```python
# ä¸è¦åœ¨åº”ç”¨å±‚æ‰‹åŠ¨è®¾ç½® conversation_key
message.conversation_key = f"{min(ids)}-{max(ids)}"  # âŒ ä¸è¦è¿™æ ·åš
```

**æ£€æŸ¥æ–¹æ³•**:
- ä»£ç å®¡æŸ¥æ—¶ç¡®è®¤ Message æ¨¡å‹ä¸­æ²¡æœ‰æ‰‹åŠ¨è®¾ç½® `conversation_key` çš„ä»£ç 
- ç¡®è®¤æ•°æ®åº“è§¦å‘å™¨å·²æ­£ç¡®åˆ›å»ºå¹¶æµ‹è¯•

---

#### 4. å¿…é¡»ä½¿ç”¨ EXPLAIN ANALYZE éªŒè¯ç´¢å¼•ä½¿ç”¨æƒ…å†µ

**é‡è¦æ€§**: âš ï¸ **å¿…é¡»ä¸¥æ ¼éµå®ˆ**

**åŸå› **: ç´¢å¼•åˆ›å»ºåï¼Œéœ€è¦ç¡®è®¤æŸ¥è¯¢è®¡åˆ’æ˜¯å¦çœŸæ­£ä½¿ç”¨äº†ç´¢å¼•ï¼Œå¦åˆ™ç´¢å¼•å¯èƒ½æ— æ•ˆã€‚

**å®æ–½è¦æ±‚**:

**æ­¥éª¤ 1: å¯¹å…³é”®æŸ¥è¯¢æ‰§è¡Œ EXPLAIN ANALYZE**
```sql
-- ä»»åŠ¡åˆ—è¡¨æŸ¥è¯¢
EXPLAIN ANALYZE
SELECT * FROM tasks 
WHERE status = 'open' 
  AND task_type = 'delivery'
ORDER BY created_at DESC 
LIMIT 20;

-- é¢„æœŸç»“æœï¼šåº”è¯¥çœ‹åˆ° "Index Scan using ix_tasks_status_created_id"
```

**æ­¥éª¤ 2: æ£€æŸ¥ç´¢å¼•ä½¿ç”¨æƒ…å†µ**
```sql
-- æŸ¥çœ‹ç´¢å¼•ä½¿ç”¨ç»Ÿè®¡
SELECT 
    schemaname,
    tablename,
    indexname,
    idx_scan as index_scans,
    idx_tup_read as tuples_read,
    idx_tup_fetch as tuples_fetched
FROM pg_stat_user_indexes
WHERE tablename IN ('tasks', 'task_applications', 'messages', 'notifications')
ORDER BY idx_scan DESC;
```

**æ­¥éª¤ 3: éªŒè¯å…³é”®è¯æœç´¢ç´¢å¼•**
```sql
-- pg_trgm ç´¢å¼•
EXPLAIN ANALYZE
SELECT * FROM tasks 
WHERE similarity(title, 'delivery') > 0.2
ORDER BY similarity(title, 'delivery') DESC
LIMIT 20;

-- é¢„æœŸç»“æœï¼šåº”è¯¥çœ‹åˆ° "Bitmap Index Scan using idx_tasks_title_trgm"

-- å…¨æ–‡æœç´¢ç´¢å¼•
EXPLAIN ANALYZE
SELECT * FROM tasks 
WHERE to_tsvector('english', title || ' ' || description) @@ plainto_tsquery('english', 'delivery')
LIMIT 20;

-- é¢„æœŸç»“æœï¼šåº”è¯¥çœ‹åˆ° "Bitmap Index Scan using idx_tasks_search"
```

**æ­¥éª¤ 4: éªŒè¯æ¸¸æ ‡åˆ†é¡µç´¢å¼•**
```sql
-- æ¸¸æ ‡åˆ†é¡µæŸ¥è¯¢
EXPLAIN ANALYZE
SELECT * FROM tasks 
WHERE status = 'open' 
  AND (created_at < '2024-01-01' OR (created_at = '2024-01-01' AND id < 123))
ORDER BY created_at DESC, id DESC
LIMIT 20;

-- é¢„æœŸç»“æœï¼šåº”è¯¥çœ‹åˆ° "Index Scan using ix_tasks_status_created_id"
```

**æ­¥éª¤ 5: éªŒè¯å¯¹è¯æŸ¥è¯¢ç´¢å¼•**
```sql
-- å¯¹è¯æ¶ˆæ¯æŸ¥è¯¢
EXPLAIN ANALYZE
SELECT * FROM messages 
WHERE conversation_key = 'user1-user2'
ORDER BY created_at ASC
LIMIT 50;

-- é¢„æœŸç»“æœï¼šåº”è¯¥çœ‹åˆ° "Index Scan using ix_messages_conversation_created"
```

**æ£€æŸ¥æ¸…å•**:
- [ ] æ‰€æœ‰å…³é”®æŸ¥è¯¢çš„ EXPLAIN ANALYZE ç»“æœå·²æ£€æŸ¥
- [ ] ç¡®è®¤æŸ¥è¯¢è®¡åˆ’ä½¿ç”¨äº†é¢„æœŸçš„ç´¢å¼•
- [ ] ç¡®è®¤æ²¡æœ‰å‡ºç° "Seq Scan"ï¼ˆå…¨è¡¨æ‰«æï¼‰çš„æƒ…å†µ
- [ ] ç¡®è®¤æŸ¥è¯¢æ‰§è¡Œæ—¶é—´åœ¨é¢„æœŸèŒƒå›´å†…

---

## ğŸ§ª æµ‹è¯•å»ºè®®

### æ€§èƒ½æµ‹è¯•

1. **å•è¯·æ±‚æ€§èƒ½æµ‹è¯•**
   ```python
   import time
   import asyncio
   
   async def test_query_performance():
       start = time.time()
       tasks = await async_crud.async_task_crud.get_tasks(db, limit=100)
       elapsed = time.time() - start
       print(f"æŸ¥è¯¢è€—æ—¶: {elapsed:.3f}ç§’")
   ```

2. **å¹¶å‘å‹æµ‹ï¼ˆé‡è¦ï¼‰**
   - ä½¿ç”¨ **Locust** æˆ– **k6** è¿›è¡Œå¹¶å‘å‹æµ‹
   - å¾ˆå¤šä¼˜åŒ–æ•ˆæœåœ¨å•è¯·æ±‚çœ‹ä¸å‡ºï¼Œéœ€è¦çœ‹å¹¶å‘ä¸‹çš„ QPS å’Œ P95
   - å»ºè®®å‹æµ‹åœºæ™¯ï¼š
     - ä»»åŠ¡åˆ—è¡¨æŸ¥è¯¢ï¼ˆ100 å¹¶å‘ï¼‰
     - å…³é”®è¯æœç´¢ï¼ˆ50 å¹¶å‘ï¼‰
     - ç”¨æˆ·ç”³è¯·åˆ—è¡¨ï¼ˆ50 å¹¶å‘ï¼‰
     - å¯¹è¯æ¶ˆæ¯æŸ¥è¯¢ï¼ˆ100 å¹¶å‘ï¼‰
   ```python
   # Locust ç¤ºä¾‹
   from locust import HttpUser, task, between
   
   class TaskListUser(HttpUser):
       wait_time = between(1, 3)
       
       @task
       def get_tasks(self):
           self.client.get("/tasks?limit=20&sort_by=latest")
   ```

3. **N+1 æŸ¥è¯¢æ£€æµ‹**
   - ä½¿ç”¨ SQLAlchemy çš„ `echo=True` æŸ¥çœ‹ SQL æ—¥å¿—
   - æ£€æŸ¥æŸ¥è¯¢æ¬¡æ•°æ˜¯å¦åˆç†
   - ä½¿ç”¨ `sqlalchemy.engine.events` ç›‘å¬æ‰€æœ‰ SQL æŸ¥è¯¢

4. **ç´¢å¼•ä½¿ç”¨éªŒè¯**
   ```sql
   EXPLAIN ANALYZE
   SELECT * FROM tasks 
   WHERE status = 'open' 
   ORDER BY created_at DESC 
   LIMIT 20;
   ```
   - æ£€æŸ¥æ˜¯å¦ä½¿ç”¨äº†é¢„æœŸçš„ç´¢å¼•
   - æ£€æŸ¥æŸ¥è¯¢è®¡åˆ’æ˜¯å¦æœ€ä¼˜

### åŠŸèƒ½æµ‹è¯•

1. **åˆ†é¡µåŠŸèƒ½æµ‹è¯•**
   - æµ‹è¯•æ·±åˆ†é¡µæ€§èƒ½ï¼ˆç¬¬ 100 é¡µï¼‰
   - æµ‹è¯•æ¸¸æ ‡åˆ†é¡µæ­£ç¡®æ€§ï¼ˆæ•°æ®ä¸é‡å¤ã€ä¸é—æ¼ï¼‰
   - æµ‹è¯•è¾¹ç•Œæƒ…å†µï¼ˆç©ºç»“æœã€å•é¡µç»“æœç­‰ï¼‰

2. **ç¼“å­˜åŠŸèƒ½æµ‹è¯•**
   - æµ‹è¯•ç¼“å­˜å‘½ä¸­ç‡ï¼ˆåº”è¯¥ > 70%ï¼‰
   - æµ‹è¯•ç¼“å­˜å¤±æ•ˆï¼ˆæ•°æ®æ›´æ–°åç¼“å­˜æ˜¯å¦æ­£ç¡®å¤±æ•ˆï¼‰
   - æµ‹è¯•ç¼“å­˜é¢„çƒ­ï¼ˆæœåŠ¡å¯åŠ¨åå¸¸ç”¨æŸ¥è¯¢æ˜¯å¦å·²ç¼“å­˜ï¼‰

3. **æœç´¢åŠŸèƒ½æµ‹è¯•**
   - æµ‹è¯• pg_trgm å’Œå…¨æ–‡æœç´¢çš„å‡†ç¡®æ€§
   - æµ‹è¯•ä¸­æ–‡å’Œè‹±æ–‡æœç´¢æ•ˆæœ
   - æµ‹è¯•ç‰¹æ®Šå­—ç¬¦å¤„ç†

---

## ğŸ“Š é¢„æœŸæ•ˆæœ

### æ€§èƒ½æå‡é¢„æœŸ

| åŠŸèƒ½ | ä¼˜åŒ–å‰ | ä¼˜åŒ–å | æå‡ |
|------|--------|--------|------|
| ä»»åŠ¡åˆ—è¡¨æŸ¥è¯¢ï¼ˆ100æ¡ï¼‰ | 200-500ms | 50-100ms | 4-5å€ |
| å…³é”®è¯æœç´¢ | 500-2000ms | 50-150ms | 10-20å€ |
| ç”¨æˆ·ç”³è¯·åˆ—è¡¨ | 300-800ms | 50-100ms | 6-8å€ |
| æ·±åˆ†é¡µï¼ˆç¬¬100é¡µï¼‰ | 1000-3000ms | 100-200ms | 10-15å€ |

### æ•°æ®åº“è´Ÿè½½é™ä½

- æŸ¥è¯¢æ¬¡æ•°å‡å°‘ 60-80%
- æ•°æ®åº“ CPU ä½¿ç”¨ç‡é™ä½ 30-50%
- å“åº”æ—¶é—´ P95 é™ä½ 50-70%

---

## ğŸ” ç›‘æ§æŒ‡æ ‡

### éœ€è¦ç›‘æ§çš„æŒ‡æ ‡

1. **æŸ¥è¯¢æ€§èƒ½**
   - å¹³å‡æŸ¥è¯¢æ—¶é—´
   - P95/P99 æŸ¥è¯¢æ—¶é—´
   - æ…¢æŸ¥è¯¢æ•°é‡

2. **ç¼“å­˜æ•ˆæœ**
   - ç¼“å­˜å‘½ä¸­ç‡
   - ç¼“å­˜å¤§å°
   - ç¼“å­˜å¤±æ•ˆé¢‘ç‡

3. **æ•°æ®åº“è´Ÿè½½**
   - æŸ¥è¯¢ QPS
   - è¿æ¥æ•°
   - CPU/å†…å­˜ä½¿ç”¨ç‡

### ç›‘æ§å·¥å…·å»ºè®®

- PostgreSQL: `pg_stat_statements`
- Redis: `INFO stats`
- åº”ç”¨å±‚: è‡ªå®šä¹‰æ€§èƒ½ç›‘æ§

---

## ğŸ“š å‚è€ƒèµ„æ–™

1. [SQLAlchemy æ€§èƒ½ä¼˜åŒ–æŒ‡å—](https://docs.sqlalchemy.org/en/14/faq/performance.html)
2. [PostgreSQL ç´¢å¼•ä¼˜åŒ–](https://www.postgresql.org/docs/current/indexes.html)
3. [Redis ç¼“å­˜æœ€ä½³å®è·µ](https://redis.io/docs/manual/patterns/)

---

## âœ… æ£€æŸ¥æ¸…å•

### ä»£ç å®æ–½æ£€æŸ¥

- [ ] æ‰€æœ‰ N+1 æŸ¥è¯¢å·²è§£å†³ï¼ˆä½¿ç”¨ selectinload æˆ–æ‰¹é‡æŸ¥è¯¢ï¼‰
- [ ] åˆ—è¡¨æŸ¥è¯¢å’Œæ€»æ•°æŸ¥è¯¢å…±ç”¨åŒä¸€ä¸ª `base_query`ï¼ˆé¿å…æ•°æ®ä¸ä¸€è‡´ï¼‰
- [ ] æ¸¸æ ‡åˆ†é¡µåªåœ¨æŒ‰ `created_at` æ’åºæ—¶ä½¿ç”¨ï¼ˆå…¶ä»–æ’åºç”¨ offset/limitï¼‰
- [ ] `conversation_key` å®Œå…¨ç”±æ•°æ®åº“è§¦å‘å™¨ç»´æŠ¤ï¼ˆåº”ç”¨å±‚ä¸æ‰‹åŠ¨è®¾ç½®ï¼‰
- [ ] å¿…è¦çš„ç´¢å¼•å·²åˆ›å»ºï¼ˆä»»åŠ¡ã€ç”³è¯·ã€æ¶ˆæ¯ã€é€šçŸ¥è¡¨ï¼‰
- [ ] ç¼“å­˜ç­–ç•¥å·²ä¼˜åŒ–ï¼ˆç¼“å­˜é”®ä½¿ç”¨å“ˆå¸Œï¼Œæ”¯æŒç‰ˆæœ¬å·ï¼‰
- [ ] åˆ†é¡µæŸ¥è¯¢æ€§èƒ½å·²æå‡ï¼ˆæ¸¸æ ‡åˆ†é¡µæˆ– offset/limit ä¼˜åŒ–ï¼‰

### æ•°æ®åº“ç´¢å¼•éªŒè¯ï¼ˆå¿…é¡»ä½¿ç”¨ EXPLAIN ANALYZEï¼‰

- [ ] ä»»åŠ¡åˆ—è¡¨æŸ¥è¯¢ä½¿ç”¨äº† `ix_tasks_status_created_id` ç´¢å¼•
- [ ] ä»»åŠ¡ç±»å‹+åœ°ç‚¹ç­›é€‰æŸ¥è¯¢ä½¿ç”¨äº† `ix_tasks_type_location_status` ç´¢å¼•
- [ ] ç”¨æˆ·ä»»åŠ¡æŸ¥è¯¢ä½¿ç”¨äº† `ix_tasks_poster_status_created` æˆ– `ix_tasks_taker_status_created` ç´¢å¼•
- [ ] å…³é”®è¯æœç´¢ä½¿ç”¨äº† `idx_tasks_title_trgm` æˆ– `idx_tasks_search` ç´¢å¼•
- [ ] ç”³è¯·åˆ—è¡¨æŸ¥è¯¢ä½¿ç”¨äº† `ix_applications_applicant_created` ç´¢å¼•
- [ ] å¯¹è¯æ¶ˆæ¯æŸ¥è¯¢ä½¿ç”¨äº† `ix_messages_conversation_created` ç´¢å¼•
- [ ] é€šçŸ¥æŸ¥è¯¢ä½¿ç”¨äº† `ix_notifications_user_read_created` ç´¢å¼•
- [ ] æ‰€æœ‰æŸ¥è¯¢è®¡åˆ’ä¸­æ²¡æœ‰å‡ºç° "Seq Scan"ï¼ˆå…¨è¡¨æ‰«æï¼‰
- [ ] ç¡®è®¤æŸ¥è¯¢æ¡ä»¶ä¸éƒ¨åˆ†ç´¢å¼•çš„ WHERE å­å¥ä¿æŒä¸€è‡´ï¼ˆå¦‚ `status = 'open'` å¯¹åº” `WHERE status IN ('open', 'taken')`ï¼‰
- [ ] å…³é”®è¯æœç´¢æ’åºå·²æ·»åŠ ç¨³å®šçš„ tie-breakerï¼ˆcreated_at + idï¼‰
- [ ] Redis KEYS å‘½ä»¤æ€§èƒ½å·²ç›‘æ§ï¼ˆè€—æ—¶ã€æ…¢æ—¥å¿—ã€key æ•°é‡ï¼‰

### åŠŸèƒ½æµ‹è¯•

- [ ] å…³é”®è¯æœç´¢å·²ä¼˜åŒ–ï¼ˆpg_trgm æˆ–å…¨æ–‡æœç´¢ï¼‰
- [ ] åˆ†é¡µåŠŸèƒ½æµ‹è¯•é€šè¿‡ï¼ˆæ•°æ®ä¸é‡å¤ã€ä¸é—æ¼ï¼‰
- [ ] ç¼“å­˜åŠŸèƒ½æµ‹è¯•é€šè¿‡ï¼ˆå‘½ä¸­ç‡ > 70%ï¼‰
- [ ] æ€§èƒ½æµ‹è¯•å·²é€šè¿‡ï¼ˆå•è¯·æ±‚å’Œå¹¶å‘å‹æµ‹ï¼‰

### ç›‘æ§å’Œæ–‡æ¡£

- [ ] ç›‘æ§æŒ‡æ ‡å·²è®¾ç½®ï¼ˆæŸ¥è¯¢æ€§èƒ½ã€ç¼“å­˜æ•ˆæœã€æ•°æ®åº“è´Ÿè½½ï¼‰
- [ ] æ…¢æŸ¥è¯¢æ—¥å¿—å·²é…ç½®
- [ ] æ–‡æ¡£å·²æ›´æ–°ï¼ˆè®°å½•å®é™…æ•ˆæœå’Œé‡åˆ°çš„é—®é¢˜ï¼‰

---

**æ–‡æ¡£ç»´æŠ¤**: è¯·åœ¨å®æ–½ä¼˜åŒ–åæ›´æ–°æœ¬æ–‡æ¡£ï¼Œè®°å½•å®é™…æ•ˆæœå’Œé‡åˆ°çš„é—®é¢˜ã€‚

