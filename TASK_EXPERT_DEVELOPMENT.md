# 任务达人功能开发日志

## 一、需求概述

任务达人功能允许平台用户申请成为任务达人，管理员审核通过后，任务达人可以发布自己的服务菜单。其他用户可以向任务达人的特定服务发起申请，任务达人同意后，系统会自动创建一个任务，该任务会出现在任务聊天页面中。

## 二、核心业务流程

### 2.1 任务达人申请流程

1. **用户申请成为任务达人**
   - 平台用户提交申请（包含个人简介、技能说明等）
   - 申请状态：`pending`（待审核）

2. **管理员审核**
   - 管理员查看申请列表
   - 管理员可以批准或拒绝申请
   - 批准后，创建任务达人记录

3. **任务达人创建**
   - 任务达人记录与用户记录关联（使用相同的用户ID）
   - 任务达人状态：`active`（激活）

### 2.2 服务菜单管理

1. **任务达人发布服务**
   - 服务名称
   - 服务介绍/描述
   - 相关图片（支持多张）
   - 价格（基础价格）
   - 服务状态：`active`（上架）/ `inactive`（下架）

### 2.3 用户申请服务流程

1. **用户浏览任务达人服务**
   - 查看任务达人主页
   - 浏览服务菜单列表

2. **用户申请特定服务**
   - 选择服务
   - 填写申请信息（可选留言）
   - 可进行议价（提出期望价格）
   - 提交申请

3. **任务达人收到申请**
   - 任务达人收到通知
   - 查看申请详情
   - 可以同意、拒绝或再次议价

4. **任务达人再次议价（可选）**
   - 如果任务达人选择再次议价，提出新的价格
   - 申请状态变为 `negotiating`（议价中）
   - 用户收到通知，可以同意或拒绝议价
   - 用户同意议价后，状态变为 `price_agreed`（价格已达成一致）

5. **任务达人同意申请或用户同意议价**
   - 当申请状态为 `pending`（无议价）或 `price_agreed`（议价已达成）时，任务达人可以直接同意
   - 或者用户同意任务达人的再次议价后，系统自动创建任务
   - 任务类型：`其他`
   - 任务标题：服务名称
   - 任务描述：服务描述
   - 任务金额：最终确定的价格（用户议价价格、任务达人再次议价价格或服务基础价格）
   - 发布人：申请用户
   - 接收方：任务达人
   - 任务状态：`in_progress`（进行中）

6. **任务出现在聊天页面**
   - 任务创建后，自动出现在任务聊天页面
   - 申请用户和任务达人可以开始聊天

## 三、数据库设计

**重要说明：以下为唯一权威DDL定义，所有实现必须以此为准。历史版本已废弃，请勿使用。**

### 3.1 任务达人申请表（TaskExpertApplication）

用于存储用户申请成为任务达人的记录。

```sql
CREATE TABLE task_expert_applications (
    id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    user_id VARCHAR(8) NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    application_message TEXT,  -- 申请说明
    status VARCHAR(20) DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'rejected')),  -- pending, approved, rejected
    reviewed_by VARCHAR(5) REFERENCES admin_users(id),  -- 审核管理员ID（注意：admin_users.id长度必须为VARCHAR(5)）
    reviewed_at TIMESTAMPTZ,  -- 审核时间
    review_comment TEXT,  -- 审核意见
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- 索引
CREATE INDEX idx_task_expert_applications_user_id ON task_expert_applications(user_id);
CREATE INDEX idx_task_expert_applications_status ON task_expert_applications(status);
CREATE INDEX idx_task_expert_applications_reviewed_by ON task_expert_applications(reviewed_by);

-- 部分唯一索引：确保一个用户只能有一个待审核的申请
CREATE UNIQUE INDEX uq_expert_app_pending
ON task_expert_applications (user_id, status)
WHERE status = 'pending';
```

**字段说明：**
- `user_id`: 申请用户的ID（外键关联users表）
- `application_message`: 申请说明（可选）
- `status`: 申请状态（pending=待审核, approved=已批准, rejected=已拒绝）
- `reviewed_by`: 审核管理员ID
- `reviewed_at`: 审核时间
- `review_comment`: 审核意见
- `created_at`: 申请创建时间
- `updated_at`: 最后更新时间

### 3.2 任务达人表（TaskExpert）

存储已批准的任务达人信息。任务达人的ID与用户ID相同，实现一对一关联。

```sql
CREATE TABLE task_experts (
    id VARCHAR(8) PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,  -- 与用户ID相同
    expert_name VARCHAR(100),  -- 任务达人名称（可不同于用户名）
    bio TEXT,  -- 个人简介
    avatar TEXT,  -- 头像（可覆盖用户默认头像，使用TEXT以支持长CDN URL）
    status VARCHAR(20) DEFAULT 'active' CHECK (status IN ('active', 'inactive', 'suspended')),  -- active, inactive, suspended
    rating DECIMAL(3,2) DEFAULT 0.00 CHECK (rating >= 0.00 AND rating <= 5.00),  -- 平均评分（0.00-5.00）
    total_services INTEGER DEFAULT 0,  -- 服务总数
    completed_tasks INTEGER DEFAULT 0,  -- 完成任务数
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    approved_by VARCHAR(5) REFERENCES admin_users(id),  -- 批准的管理员ID（注意：admin_users.id长度必须为VARCHAR(5)）
    approved_at TIMESTAMPTZ  -- 批准时间
);

-- 注意：admin_users表定义（确保外键长度一致）
-- CREATE TABLE admin_users (
--     id VARCHAR(5) PRIMARY KEY,  -- 管理员ID，长度固定为5
--     username VARCHAR(50) NOT NULL,
--     -- ... 其他字段
-- );

-- 索引
CREATE INDEX idx_task_experts_status ON task_experts(status);
CREATE INDEX idx_task_experts_rating ON task_experts(rating);
```

**字段说明：**
- `id`: 任务达人ID，与用户ID相同（主键，外键关联users表）
- `expert_name`: 任务达人显示名称（可选，默认使用用户名）
- `bio`: 个人简介
- `avatar`: 头像URL（可选，默认使用用户头像）
- `status`: 状态（active=激活, inactive=停用, suspended=暂停）
- `rating`: 平均评分
- `total_services`: 发布的服务总数
- `completed_tasks`: 完成的任务数
- `created_at`: 创建时间
- `updated_at`: 更新时间
- `approved_by`: 批准的管理员ID
- `approved_at`: 批准时间

**设计说明：**
- 使用用户ID作为主键，确保一个用户只能有一个任务达人身份
- 通过外键约束确保用户删除时，任务达人记录也被删除

### 3.3 任务达人服务菜单表（TaskExpertService）

存储任务达人发布的服务/产品信息。

```sql
CREATE TABLE task_expert_services (
    id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    expert_id VARCHAR(8) NOT NULL REFERENCES task_experts(id) ON DELETE CASCADE,
    service_name VARCHAR(200) NOT NULL,  -- 服务名称
    description TEXT NOT NULL,  -- 服务描述
    images JSONB,  -- JSON数组，存储图片URL列表（使用PostgreSQL JSONB类型）
    base_price DECIMAL(12, 2) NOT NULL,  -- 基础价格
    currency VARCHAR(3) DEFAULT 'GBP' CHECK (currency ~ '^[A-Z]{3}$'),  -- 货币类型（ISO 4217格式）
    status VARCHAR(20) DEFAULT 'active' CHECK (status IN ('active', 'inactive')),  -- active, inactive
    display_order INTEGER DEFAULT 0,  -- 显示顺序
    view_count INTEGER DEFAULT 0,  -- 浏览次数
    application_count INTEGER DEFAULT 0,  -- 申请次数
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

-- 索引
CREATE INDEX idx_task_expert_services_expert_id ON task_expert_services(expert_id);
CREATE INDEX idx_task_expert_services_status ON task_expert_services(status);
CREATE INDEX idx_task_expert_services_expert_status ON task_expert_services(expert_id, status);
```

**字段说明：**
- `id`: 服务ID（自增主键）
- `expert_id`: 任务达人ID（外键关联task_experts表）
- `service_name`: 服务名称
- `description`: 服务描述
- `images`: 图片URL列表（JSON格式，如：`["url1", "url2"]`）
- `base_price`: 基础价格
- `currency`: 货币类型（默认GBP）
- `status`: 状态（active=上架, inactive=下架）
- `display_order`: 显示顺序（用于排序）
- `view_count`: 浏览次数
- `application_count`: 申请次数
- `created_at`: 创建时间
- `updated_at`: 更新时间

### 3.4 服务申请表（ServiceApplication）

存储用户向任务达人服务发起的申请记录。

```sql
CREATE TABLE service_applications (
    id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    service_id INTEGER NOT NULL REFERENCES task_expert_services(id) ON DELETE CASCADE,
    applicant_id VARCHAR(8) NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    expert_id VARCHAR(8) NOT NULL REFERENCES task_experts(id) ON DELETE CASCADE,
    application_message TEXT,  -- 申请留言
    negotiated_price DECIMAL(12, 2),  -- 用户提出的议价价格（可选）
    expert_counter_price DECIMAL(12, 2),  -- 任务达人提出的再次议价价格（可选）
    currency VARCHAR(3) DEFAULT 'GBP' CHECK (currency ~ '^[A-Z]{3}$'),  -- 货币类型（ISO 4217格式）
    status VARCHAR(20) DEFAULT 'pending' CHECK (status IN ('pending', 'negotiating', 'price_agreed', 'approved', 'rejected', 'cancelled')),  -- pending, negotiating, price_agreed, approved, rejected, cancelled
    final_price DECIMAL(12, 2),  -- 最终确定的价格（创建任务时使用）
    task_id INTEGER REFERENCES tasks(id) ON DELETE SET NULL,  -- 关联的任务ID（任务删除时设为NULL，建议任务不物理删除）
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    approved_at TIMESTAMPTZ,  -- 同意时间
    rejected_at TIMESTAMPTZ,  -- 拒绝时间
    price_agreed_at TIMESTAMPTZ  -- 价格达成一致的时间
);

-- 索引
CREATE INDEX idx_service_applications_service_id ON service_applications(service_id);
CREATE INDEX idx_service_applications_applicant_id ON service_applications(applicant_id);
CREATE INDEX idx_service_applications_expert_id ON service_applications(expert_id);
CREATE INDEX idx_service_applications_status ON service_applications(status);
CREATE INDEX idx_service_applications_task_id ON service_applications(task_id);
-- 常用筛选列的索引（可选，根据查询路径决定）
CREATE INDEX idx_service_applications_price_agreed_at ON service_applications(price_agreed_at) WHERE price_agreed_at IS NOT NULL;
CREATE INDEX idx_service_applications_approved_at ON service_applications(approved_at) WHERE approved_at IS NOT NULL;

-- 部分唯一索引：确保同一用户对同一服务只能有一个待处理的申请
CREATE UNIQUE INDEX uq_service_app_pending_combo
ON service_applications (service_id, applicant_id, status)
WHERE status IN ('pending', 'negotiating', 'price_agreed');
```

**字段说明：**
- `id`: 申请ID（自增主键）
- `service_id`: 服务ID（外键关联task_expert_services表）
- `applicant_id`: 申请用户ID（外键关联users表）
- `expert_id`: 任务达人ID（外键关联task_experts表）
- `application_message`: 申请留言（可选）
- `negotiated_price`: 用户提出的议价价格（可选）
- `expert_counter_price`: 任务达人提出的再次议价价格（可选）
- `currency`: 货币类型（默认GBP）
- `status`: 申请状态
  - `pending`: 待处理（用户已申请，任务达人未处理）
  - `negotiating`: 议价中（任务达人提出再次议价，等待用户回应）
  - `price_agreed`: 价格已达成一致（用户同意了任务达人的议价，等待任务达人确认创建任务）
  - `approved`: 已同意（任务已创建）
  - `rejected`: 已拒绝
  - `cancelled`: 已取消
- `final_price`: 最终确定的价格（创建任务时使用）
- `task_id`: 关联的任务ID（任务达人同意后创建的任务）
- `created_at`: 申请创建时间
- `updated_at`: 最后更新时间
- `approved_at`: 同意时间
- `rejected_at`: 拒绝时间
- `price_agreed_at`: 价格达成一致的时间

## 四、数据模型实现

### 4.1 Python模型定义（models.py）

```python
import logging
from sqlalchemy import Column, Integer, String, Text, DateTime, DECIMAL, ForeignKey, Index, UniqueConstraint, func
from sqlalchemy.dialects.postgresql import JSONB
from sqlalchemy.orm import relationship
from app.models import Base
from datetime import datetime, timezone

logger = logging.getLogger(__name__)  # 统一logger定义

def get_utc_time():
    """获取当前UTC时间（用于数据库存储）"""
    return datetime.now(timezone.utc)

class TaskExpertApplication(Base):
    """任务达人申请表"""
    __tablename__ = "task_expert_applications"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(String(8), ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    application_message = Column(Text, nullable=True)
    status = Column(String(20), default="pending")  # pending, approved, rejected
    reviewed_by = Column(String(5), ForeignKey("admin_users.id"), nullable=True)
    reviewed_at = Column(DateTime(timezone=True), nullable=True)  # 审核时间
    review_comment = Column(Text, nullable=True)
    created_at = Column(DateTime(timezone=True), default=get_utc_time, server_default=func.now())
    updated_at = Column(DateTime(timezone=True), default=get_utc_time, onupdate=get_utc_time, server_default=func.now())
    
    # 关系
    user = relationship("User", backref="expert_applications")  # 修复：改为复数，表示一对多关系
    reviewer = relationship("AdminUser", backref="reviewed_expert_applications")
    
    __table_args__ = (
        Index("ix_task_expert_applications_user_id", user_id),
        Index("ix_task_expert_applications_status", status),
        Index("ix_task_expert_applications_reviewed_by", reviewed_by),
        # 部分唯一索引：确保同一用户只能有一个pending申请
        Index(
            "uq_expert_app_pending",
            user_id, status,
            unique=True,
            postgresql_where=(status == "pending")
        ),
    )


class TaskExpert(Base):
    """任务达人表
    
    重要说明：
    - id 字段与用户在 users 表中的 id 相同
    - 通过外键约束确保数据一致性
    - 管理员批准申请时，使用申请中的 user_id 作为任务达人的 id
    """
    __tablename__ = "task_experts"
    
    id = Column(String(8), ForeignKey("users.id", ondelete="CASCADE"), primary_key=True)  # 与用户ID相同
    expert_name = Column(String(100), nullable=True)
    bio = Column(Text, nullable=True)
    avatar = Column(Text, nullable=True)  # 与DDL统一为TEXT，支持长CDN URL
    status = Column(String(20), default="active")  # active, inactive, suspended
    rating = Column(DECIMAL(3, 2), default=0.00)  # 0.00-5.00（CHECK约束在DDL中定义）
    total_services = Column(Integer, default=0)
    completed_tasks = Column(Integer, default=0)
    created_at = Column(DateTime(timezone=True), default=get_utc_time, server_default=func.now())
    updated_at = Column(DateTime(timezone=True), default=get_utc_time, onupdate=get_utc_time, server_default=func.now())
    approved_by = Column(String(5), ForeignKey("admin_users.id"), nullable=True)
    approved_at = Column(DateTime(timezone=True), nullable=True)
    
    # 关系
    user = relationship("User", backref="expert_profile", foreign_keys=[id])
    approver = relationship("AdminUser", backref="approved_experts")
    services = relationship("TaskExpertService", back_populates="expert", cascade="all, delete-orphan")
    
    __table_args__ = (
        Index("ix_task_experts_status", status),
        Index("ix_task_experts_rating", rating),
    )


class TaskExpertService(Base):
    """任务达人服务菜单表"""
    __tablename__ = "task_expert_services"
    
    id = Column(Integer, primary_key=True, index=True)
    expert_id = Column(String(8), ForeignKey("task_experts.id", ondelete="CASCADE"), nullable=False)
    service_name = Column(String(200), nullable=False)
    description = Column(Text, nullable=False)
    images = Column(JSONB, nullable=True)  # JSON数组（使用PostgreSQL JSONB类型）
    base_price = Column(DECIMAL(12, 2), nullable=False)
    currency = Column(String(3), default="GBP")
    status = Column(String(20), default="active")  # active, inactive
    display_order = Column(Integer, default=0)
    view_count = Column(Integer, default=0)
    application_count = Column(Integer, default=0)
    created_at = Column(DateTime(timezone=True), default=get_utc_time, server_default=func.now())
    updated_at = Column(DateTime(timezone=True), default=get_utc_time, onupdate=get_utc_time, server_default=func.now())
    
    # 关系
    expert = relationship("TaskExpert", back_populates="services")
    applications = relationship("ServiceApplication", back_populates="service", cascade="all, delete-orphan")
    
    __table_args__ = (
        Index("ix_task_expert_services_expert_id", expert_id),
        Index("ix_task_expert_services_status", status),
        Index("ix_task_expert_services_expert_status", expert_id, status),
    )


class ServiceApplication(Base):
    """服务申请表"""
    __tablename__ = "service_applications"
    
    id = Column(Integer, primary_key=True, index=True)
    service_id = Column(Integer, ForeignKey("task_expert_services.id", ondelete="CASCADE"), nullable=False)
    applicant_id = Column(String(8), ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    expert_id = Column(String(8), ForeignKey("task_experts.id", ondelete="CASCADE"), nullable=False)
    application_message = Column(Text, nullable=True)
    negotiated_price = Column(DECIMAL(12, 2), nullable=True)  # 用户提出的议价价格
    expert_counter_price = Column(DECIMAL(12, 2), nullable=True)  # 任务达人提出的再次议价价格
    currency = Column(String(3), default="GBP")
    status = Column(String(20), default="pending")  # pending, negotiating, price_agreed, approved, rejected, cancelled
    final_price = Column(DECIMAL(12, 2), nullable=True)
    task_id = Column(Integer, ForeignKey("tasks.id"), nullable=True)
    created_at = Column(DateTime(timezone=True), default=get_utc_time, server_default=func.now())
    updated_at = Column(DateTime(timezone=True), default=get_utc_time, onupdate=get_utc_time, server_default=func.now())
    approved_at = Column(DateTime(timezone=True), nullable=True)
    rejected_at = Column(DateTime(timezone=True), nullable=True)
    price_agreed_at = Column(DateTime(timezone=True), nullable=True)  # 价格达成一致的时间
    
    # 关系
    service = relationship("TaskExpertService", back_populates="applications")
    applicant = relationship("User", foreign_keys=[applicant_id], backref="service_applications")
    expert = relationship("TaskExpert", foreign_keys=[expert_id])
    task = relationship("Task", backref="service_application")
    
    __table_args__ = (
        Index("ix_service_applications_service_id", service_id),
        Index("ix_service_applications_applicant_id", applicant_id),
        Index("ix_service_applications_expert_id", expert_id),
        Index("ix_service_applications_status", status),
        Index("ix_service_applications_task_id", task_id),
        # 部分唯一索引：确保同一用户对同一服务在pending/negotiating/price_agreed状态只能有一条
        Index(
            "uq_service_app_pending_combo",
            service_id, applicant_id, status,
            unique=True,
            postgresql_where=status.in_(["pending", "negotiating", "price_agreed"])
        ),
    )
```

### 4.2 Pydantic Schema定义（schemas.py）

```python
class TaskExpertApplicationCreate(BaseModel):
    application_message: Optional[str] = None


class TaskExpertApplicationOut(BaseModel):
    id: int
    user_id: str
    application_message: Optional[str]
    status: str
    reviewed_by: Optional[str]
    reviewed_at: Optional[datetime]
    review_comment: Optional[str]
    created_at: datetime
    
    class Config:
        from_attributes = True


class TaskExpertCreate(BaseModel):
    expert_name: Optional[str] = None
    bio: Optional[str] = None
    avatar: Optional[str] = None


class TaskExpertOut(BaseModel):
    id: str
    expert_name: Optional[str]
    bio: Optional[str]
    avatar: Optional[str]
    status: str
    rating: float
    total_services: int
    completed_tasks: int
    created_at: datetime
    
    class Config:
        from_attributes = True


class TaskExpertServiceCreate(BaseModel):
    service_name: str
    description: str
    images: Optional[List[str]] = None
    base_price: condecimal(gt=0, max_digits=12, decimal_places=2)  # 使用condecimal与DB的DECIMAL一致
    currency: Literal["GBP"] = "GBP"  # 统一为Literal类型
    display_order: int = 0


class TaskExpertServiceUpdate(BaseModel):
    service_name: Optional[str] = None
    description: Optional[str] = None
    images: Optional[List[str]] = None
    base_price: Optional[condecimal(gt=0, max_digits=12, decimal_places=2)] = None  # 使用condecimal与DB的DECIMAL一致，避免精度丢失
    currency: Optional[Literal["GBP"]] = None  # 统一为Literal类型
    status: Optional[str] = None
    display_order: Optional[int] = None


class TaskExpertServiceOut(BaseModel):
    id: int
    expert_id: str
    service_name: str
    description: str
    images: Optional[List[str]]
    base_price: float
    currency: Literal["GBP"]  # 统一为Literal类型
    status: str
    display_order: int
    view_count: int
    application_count: int
    created_at: datetime
    
    class Config:
        from_attributes = True


class ServiceApplicationOut(BaseModel):
    id: int
    service_id: int
    applicant_id: str
    expert_id: str
    application_message: Optional[str]
    negotiated_price: Optional[float]  # 输出时保持float，输入时使用condecimal
    expert_counter_price: Optional[float]
    currency: Literal["GBP"]  # 统一为Literal类型
    status: str
    final_price: Optional[float]
    task_id: Optional[int]
    created_at: datetime
    approved_at: Optional[datetime]
    price_agreed_at: Optional[datetime]
    
    class Config:
        from_attributes = True


class ServiceApplicationCreate(BaseModel):
    service_id: int
    application_message: Optional[str] = None
    negotiated_price: Optional[condecimal(gt=0, max_digits=12, decimal_places=2)] = None  # 修复：添加校验，必须大于0
    currency: Literal["GBP"] = "GBP"


class CounterOfferRequest(BaseModel):
    """任务达人再次议价请求"""
    counter_price: condecimal(gt=0, max_digits=12, decimal_places=2) = Field(..., description="任务达人提出的议价价格")
    message: Optional[str] = None  # 可选说明


class AcceptCounterOfferRequest(BaseModel):
    """用户同意任务达人议价请求"""
    accept: bool = Field(..., description="是否同意议价")
```

## 五、API接口设计

### 5.1 任务达人申请相关接口

#### 5.1.1 用户申请成为任务达人

**POST** `/api/task-experts/apply`

**请求体：**
```json
{
  "application_message": "我想成为任务达人，我有丰富的..."
}
```

**响应：**
```json
{
  "id": 1,
  "user_id": "12345678",
  "status": "pending",
  "created_at": "2025-01-15T10:00:00Z"
}
```

#### 5.1.2 获取用户的申请状态

**GET** `/api/task-experts/my-application`

**响应：**
```json
{
  "id": 1,
  "user_id": "12345678",
  "status": "pending",
  "created_at": "2025-01-15T10:00:00Z"
}
```

#### 5.1.3 管理员获取申请列表

**GET** `/api/admin/task-expert-applications`

**查询参数：**
- `status`: 筛选状态（pending, approved, rejected）
- `limit`: 每页数量
- `offset`: 偏移量

**响应：**
```json
{
  "total": 10,
  "items": [
    {
      "id": 1,
      "user_id": "12345678",
      "user_name": "张三",
      "application_message": "...",
      "status": "pending",
      "created_at": "2025-01-15T10:00:00Z"
    }
  ]
}
```

#### 5.1.4 管理员审核申请

**POST** `/api/admin/task-expert-applications/{application_id}/review`

**请求体：**
```json
{
  "action": "approve",  // approve 或 reject
  "review_comment": "审核通过"
}
```

**响应（批准时）：**
```json
{
  "message": "申请已批准，任务达人已创建",
  "application_id": 1,
  "expert": {
    "id": "12345678",  // 与用户ID相同
    "expert_name": null,
    "bio": null,
    "status": "active",
    "created_at": "2025-01-15T10:00:00Z"
  }
}
```

**响应（拒绝时）：**
```json
{
  "message": "申请已拒绝",
  "application_id": 1,
  "status": "rejected"
}
```

**业务逻辑（批准时）：**
1. 验证申请状态为 `pending`
2. 验证当前用户是管理员
3. 验证用户是否存在（通过 `user_id` 查询 `users` 表）
4. 验证该用户是否已经是任务达人（检查 `task_experts` 表中是否已存在该 `user_id`）
   - 如果已存在，返回错误："该用户已经是任务达人"
5. 创建任务达人记录：
   - `id`: 使用申请中的 `user_id`（与用户ID相同）
   - `expert_name`: 可选，默认为 `NULL`（使用用户名）
   - `bio`: 可选，默认为 `NULL`
   - `avatar`: 可选，默认为 `NULL`（使用用户头像）
   - `status`: `"active"`
   - `approved_by`: 当前管理员ID
   - `approved_at`: 当前时间
   - `created_at`: 当前时间
6. 更新申请记录：
   - `status`: `"approved"`
   - `reviewed_by`: 当前管理员ID
   - `reviewed_at`: 当前时间
   - `review_comment`: 审核意见
7. 发送通知给申请用户（申请已批准）
8. 返回创建的任务达人信息

**业务逻辑（拒绝时）：**
1. 验证申请状态为 `pending`
2. 验证当前用户是管理员
3. 更新申请记录：
   - `status`: `"rejected"`
   - `reviewed_by`: 当前管理员ID
   - `reviewed_at`: 当前时间
   - `review_comment`: 审核意见
4. 发送通知给申请用户（申请被拒绝）
5. 返回更新后的申请信息

**重要说明：**
- 任务达人记录的 `id` 必须与用户在 `users` 表中的 `id` 相同
- 这确保了任务达人和用户的一对一关系
- 通过外键约束 `REFERENCES users(id)` 保证数据一致性
- 如果用户被删除，任务达人记录也会自动删除（`ON DELETE CASCADE`）

**代码示例（批准申请时创建任务达人）：**

```python
async def review_expert_application(
    db: AsyncSession,
    application_id: int,
    action: str,  # "approve" 或 "reject"
    review_comment: Optional[str],
    current_admin: models.AdminUser
) -> dict:
    """
    管理员审核任务达人申请
    """
    # 1. 获取申请记录（使用FOR UPDATE锁，防止并发）
    application = await db.execute(
        select(TaskExpertApplication)
        .where(TaskExpertApplication.id == application_id)
        .where(TaskExpertApplication.status == "pending")
        .with_for_update()  # 并发安全：行级锁
    )
    application = application.scalar_one_or_none()
    
    if not application:
        raise HTTPException(status_code=404, detail="申请不存在或已处理")
    
    if action == "approve":
        # 2. 验证用户是否存在
        user = await db.execute(
            select(models.User).where(models.User.id == application.user_id)
        )
        user = user.scalar_one_or_none()
        
        if not user:
            raise HTTPException(status_code=404, detail="用户不存在")
        
        # 3. 验证用户是否已经是任务达人（主键约束自然防重）
        existing_expert = await db.execute(
            select(TaskExpert).where(TaskExpert.id == application.user_id)
        )
        if existing_expert.scalar_one_or_none():
            raise HTTPException(status_code=400, detail="该用户已经是任务达人")
        
        # 4. 创建任务达人记录（ID使用用户的ID）
        from app.models import get_utc_time
        from sqlalchemy.exc import IntegrityError
        
        try:
            new_expert = TaskExpert(
                id=application.user_id,  # 重要：使用用户的ID作为任务达人的ID
                expert_name=None,  # 可选，默认为NULL
                bio=None,  # 可选
                avatar=None,  # 可选，使用用户默认头像
                status="active",
                approved_by=current_admin.id,  # 批准的管理员ID
                approved_at=get_utc_time(),
                created_at=get_utc_time()
            )
            
            db.add(new_expert)
            
            # 5. 更新申请记录
            application.status = "approved"
            application.reviewed_by = current_admin.id
            application.reviewed_at = get_utc_time()
            application.review_comment = review_comment
            application.updated_at = get_utc_time()
            
            await db.commit()
            await db.refresh(new_expert)
        except IntegrityError:
            await db.rollback()
            raise HTTPException(status_code=409, detail="该用户已经是任务达人（并发冲突）")
        
        # 6. 发送通知给用户
        from app.task_notifications import send_expert_application_approved_notification
        try:
            await send_expert_application_approved_notification(
                db=db,
                user_id=application.user_id,
                expert_id=new_expert.id
            )
        except Exception as e:
            # 通知失败不影响主流程
            logger.error(f"Failed to send notification: {e}")
        
        return {
            "message": "申请已批准，任务达人已创建",
            "application_id": application_id,
            "expert": new_expert
        }
    
    elif action == "reject":
        # 拒绝申请
        application.status = "rejected"
        application.reviewed_by = current_admin.id
        application.reviewed_at = get_utc_time()
        application.review_comment = review_comment
        application.updated_at = get_utc_time()
        
        await db.commit()
        
        # 发送通知给用户
        from app.task_notifications import send_expert_application_rejected_notification
        try:
            await send_expert_application_rejected_notification(
                db=db,
                user_id=application.user_id,
                review_comment=review_comment
            )
        except Exception as e:
            logger.error(f"Failed to send notification: {e}")
        
        return {
            "message": "申请已拒绝",
            "application_id": application_id,
            "status": "rejected"
        }
```

### 5.2 任务达人管理接口

#### 5.2.1 获取任务达人信息

**GET** `/api/task-experts/{expert_id}`

**响应：**
```json
{
  "id": "12345678",
  "expert_name": "专业设计师",
  "bio": "10年设计经验...",
  "avatar": "https://...",
  "rating": 4.8,
  "total_services": 5,
  "completed_tasks": 20
}
```

#### 5.2.2 任务达人更新个人信息

**PUT** `/api/task-experts/me`

**请求体：**
```json
{
  "expert_name": "新名称",
  "bio": "更新后的简介",
  "avatar": "https://..."
}
```

### 5.3 服务菜单管理接口

#### 5.3.1 任务达人创建服务

**POST** `/api/task-experts/me/services`

**请求体：**
```json
{
  "service_name": "网站设计",
  "description": "提供专业的网站设计服务...",
  "images": ["https://...", "https://..."],
  "base_price": 500.00,
  "currency": "GBP",
  "display_order": 0
}
```

**响应：**
```json
{
  "id": 1,
  "expert_id": "12345678",
  "service_name": "网站设计",
  "description": "...",
  "base_price": 500.00,
  "status": "active",
  "created_at": "2025-01-15T10:00:00Z"
}
```

#### 5.3.2 任务达人获取自己的服务列表

**GET** `/api/task-experts/me/services`

**查询参数：**
- `status`: 筛选状态（active, inactive）
- `limit`: 每页数量
- `offset`: 偏移量

#### 5.3.3 任务达人更新服务

**PUT** `/api/task-experts/me/services/{service_id}`

**请求体：**
```json
{
  "service_name": "更新后的名称",
  "description": "更新后的描述",
  "base_price": 600.00,
  "status": "active"
}
```

#### 5.3.4 任务达人删除服务

**DELETE** `/api/task-experts/me/services/{service_id}`

#### 5.3.5 获取任务达人的公开服务列表

**GET** `/api/task-experts/{expert_id}/services`

**查询参数：**
- `status`: 默认为 `active`（只返回上架的服务）

**响应：**
```json
{
  "expert_id": "12345678",
  "expert_name": "专业设计师",
  "services": [
    {
      "id": 1,
      "service_name": "网站设计",
      "description": "...",
      "images": ["https://..."],
      "base_price": 500.00,
      "currency": "GBP",
      "view_count": 100,
      "application_count": 5
    }
  ]
}
```

#### 5.3.6 获取服务详情

**GET** `/api/task-experts/services/{service_id}`

**响应：**
```json
{
  "id": 1,
  "expert_id": "12345678",
  "expert_name": "专业设计师",
  "service_name": "网站设计",
  "description": "...",
  "images": ["https://..."],
  "base_price": 500.00,
  "currency": "GBP",
  "view_count": 101,
  "application_count": 5
}
```

### 5.4 服务申请相关接口

#### 5.4.1 用户申请服务

**POST** `/api/task-experts/services/{service_id}/apply`

**请求体：**
```json
{
  "application_message": "我想申请这个服务...",
  "negotiated_price": 450.00,  // 可选，议价
  "currency": "GBP"
}
```

**响应：**
```json
{
  "id": 1,
  "service_id": 1,
  "applicant_id": "87654321",
  "status": "pending",
  "created_at": "2025-01-15T10:00:00Z"
}
```

**业务逻辑（完整校验 + 并发安全）：**
```python
async def create_service_application(
    db: AsyncSession,
    service_id: int,
    current_user: models.User,
    application_data: ServiceApplicationCreate
):
    """用户申请服务（完整校验 + 并发安全）"""
    from sqlalchemy import select
    from sqlalchemy.orm import with_for_update
    from decimal import Decimal
    from app.models import get_utc_time
    
    # 1. 获取服务信息（带锁，防止并发修改）
    service = await db.execute(
        select(TaskExpertService)
        .where(TaskExpertService.id == service_id)
        .with_for_update()  # 并发安全：锁定服务记录
    )
    service = service.scalar_one_or_none()
    
    if not service:
        raise HTTPException(status_code=404, detail="服务不存在")
    
    # 2. 校验服务状态必须为active
    if service.status != "active":
        raise HTTPException(status_code=400, detail="服务未上架，无法申请")
    
    # 3. 校验用户不能申请自己的服务
    if service.expert_id == current_user.id:
        raise HTTPException(status_code=400, detail="不能申请自己的服务")
    
    # 4. 校验是否已有待处理的申请（使用部分唯一索引防止重复）
    existing = await db.execute(
        select(ServiceApplication)
        .where(ServiceApplication.service_id == service_id)
        .where(ServiceApplication.applicant_id == current_user.id)
        .where(ServiceApplication.status.in_(["pending", "negotiating", "price_agreed"]))
    )
    if existing.scalar_one_or_none():
        raise HTTPException(status_code=400, detail="您已申请过此服务，请等待处理")
    
    # 5. 校验议价价格
    if application_data.negotiated_price is not None:
        if application_data.negotiated_price <= 0:
            raise HTTPException(status_code=400, detail="议价价格必须大于0")
        # 设置最低价为基础价格的50%
        min_price = service.base_price * Decimal('0.5')
        if application_data.negotiated_price < min_price:
            raise HTTPException(
                status_code=400, 
                detail=f"议价价格不能低于基础价格的50%（最低{min_price}）"
            )
    
    # 6. 创建申请记录
    new_application = ServiceApplication(
        service_id=service_id,
        applicant_id=current_user.id,
        expert_id=service.expert_id,
        application_message=application_data.application_message,
        negotiated_price=application_data.negotiated_price,
        currency=application_data.currency,
        status="pending",
        created_at=get_utc_time()
    )
    db.add(new_application)
    
    # 7. 更新服务统计：申请时+1（原子更新，避免并发丢失）
    # 使用SQL原子更新，而不是Python +=
    from sqlalchemy import update
    from sqlalchemy.exc import IntegrityError
    
    try:
        await db.execute(
            update(TaskExpertService)
            .where(TaskExpertService.id == service_id)
            .values(application_count=TaskExpertService.application_count + 1)
        )
        
        await db.commit()
        await db.refresh(new_application)
    except IntegrityError:
        await db.rollback()
        # 部分唯一索引冲突：并发情况下可能同时创建申请
        raise HTTPException(
            status_code=409, 
            detail="您已申请过此服务，请等待处理（并发冲突）"
        )
    
    # 8. 发送通知给任务达人
    from app.task_notifications import send_service_application_notification
    try:
        await send_service_application_notification(
            db=db,
            expert_id=service.expert_id,
            applicant_id=current_user.id,
            service_id=service_id,
            service_name=service.service_name,
            negotiated_price=application_data.negotiated_price
        )
    except Exception as e:
        logger.error(f"Failed to send notification: {e}")
    
    return new_application
```

#### 5.4.2 任务达人获取收到的申请列表

**GET** `/api/task-experts/me/applications`

**查询参数：**
- `status`: 筛选状态（pending, negotiating, price_agreed, approved, rejected, cancelled）
- `service_id`: 筛选特定服务
- `limit`: 每页数量
- `offset`: 偏移量

**响应：**
```json
{
  "total": 5,
  "items": [
    {
      "id": 1,
      "service_id": 1,
      "service_name": "网站设计",
      "applicant_id": "87654321",
      "applicant_name": "李四",
      "application_message": "...",
      "negotiated_price": 450.00,
      "status": "pending",
      "created_at": "2025-01-15T10:00:00Z"
    }
  ]
}
```

#### 5.4.3 任务达人再次议价

**POST** `/api/task-experts/applications/{application_id}/counter-offer`

**请求体：**
```json
{
  "counter_price": 480.00,  // 任务达人提出的议价价格
  "message": "考虑到项目复杂度，我建议这个价格"  // 可选说明
}
```

**响应：**
```json
{
  "message": "议价已发送，等待用户回应",
  "application_id": 1,
  "status": "negotiating",
  "expert_counter_price": 480.00
}
```

**业务逻辑（完整校验 + 并发安全）：**
```python
async def counter_offer_service_application(
    db: AsyncSession,
    application_id: int,
    current_user: models.User,
    counter_offer: CounterOfferRequest
):
    """任务达人再次议价（完整校验 + 并发安全）"""
    from sqlalchemy import select
    from app.models import get_utc_time
    
    # 1. 获取申请（带锁，防止并发）
    application = await db.execute(
        select(ServiceApplication)
        .where(ServiceApplication.id == application_id)
        .with_for_update()  # 并发安全：行级锁
    )
    application = application.scalar_one_or_none()
    
    if not application:
        raise HTTPException(status_code=404, detail="申请不存在")
    
    # 2. 校验必须是任务达人本人
    if application.expert_id != current_user.id:
        raise HTTPException(status_code=403, detail="只能处理自己的服务申请")
    
    # 3. 校验状态
    if application.status not in ["pending", "negotiating"]:
        raise HTTPException(status_code=400, detail="当前状态不允许议价")
    
    # 4. 校验议价价格（已在Schema中校验，这里再次确认）
    if counter_offer.counter_price <= 0:
        raise HTTPException(status_code=400, detail="议价价格必须大于0")
    
    # 5. 更新申请记录
    application.status = "negotiating"
    application.expert_counter_price = counter_offer.counter_price
    application.updated_at = get_utc_time()
    
    await db.commit()
    await db.refresh(application)
    
    # 6. 发送通知给申请用户
    from app.task_notifications import send_counter_offer_notification
    try:
        await send_counter_offer_notification(
            db=db,
            applicant_id=application.applicant_id,
            expert_id=application.expert_id,
            counter_price=counter_offer.counter_price,
            message=counter_offer.message
        )
    except Exception as e:
        logger.error(f"Failed to send notification: {e}")
    
    return application
```

**简化版业务逻辑说明：**
1. 验证申请状态为 `pending` 或 `negotiating`（允许修改议价）
2. 验证当前用户是任务达人（申请中的 `expert_id`）
3. 验证议价价格大于0
4. 更新申请记录：
   - `status`: `"negotiating"`
   - `expert_counter_price`: 任务达人提出的议价价格
   - `updated_at`: 当前时间
5. 发送通知给申请用户（任务达人提出新的议价）
6. 返回更新后的申请信息

#### 5.4.4 用户同意/拒绝任务达人的议价

**POST** `/api/users/me/service-applications/{application_id}/respond-counter-offer`

**请求体：**
```json
{
  "accept": true  // true=同意议价, false=拒绝议价
}
```

**响应（同意时）：**
```json
{
  "message": "已同意议价，等待任务达人确认创建任务",
  "application_id": 1,
  "status": "price_agreed",
  "final_price": 480.00
}
```

**响应（拒绝时）：**
```json
{
  "message": "已拒绝议价，申请状态恢复为待处理",
  "application_id": 1,
  "status": "pending"
}
```

**业务逻辑（同意时 - 完整校验 + 并发安全）：**
```python
async def respond_to_counter_offer(
    db: AsyncSession,
    application_id: int,
    current_user: models.User,
    request: AcceptCounterOfferRequest
):
    """用户同意/拒绝任务达人的议价（完整校验 + 并发安全）"""
    import logging
    from sqlalchemy import select
    from app.models import get_utc_time
    
    logger = logging.getLogger(__name__)  # logger定义
    
    # 1. 获取申请记录（带锁，防止并发）
    application = await db.execute(
        select(ServiceApplication)
        .where(ServiceApplication.id == application_id)
        .with_for_update()  # 并发安全：行级锁
    )
    application = application.scalar_one_or_none()
    
    if not application:
        raise HTTPException(status_code=404, detail="申请不存在")
    
    # 2. 权限校验：只能处理自己的申请
    if application.applicant_id != current_user.id:
        raise HTTPException(status_code=403, detail="只能处理自己的申请")
    
    # 3. 状态校验：必须是negotiating状态
    if application.status != "negotiating":
        raise HTTPException(status_code=400, detail="当前状态不允许此操作")
    
    # 4. 验证申请中有任务达人的议价价格
    if application.expert_counter_price is None:
        raise HTTPException(status_code=400, detail="任务达人尚未提出议价")
    
    if request.accept:
        # 5. 同意议价：更新状态为price_agreed
        application.status = "price_agreed"
        application.final_price = application.expert_counter_price
        application.price_agreed_at = get_utc_time()
        application.updated_at = get_utc_time()
        
        await db.commit()
        await db.refresh(application)
        
        # 6. 发送通知给任务达人
        from app.task_notifications import send_counter_offer_accepted_notification
        try:
            await send_counter_offer_accepted_notification(
                db=db,
                expert_id=application.expert_id,
                applicant_id=application.applicant_id,
                counter_price=application.expert_counter_price
            )
        except Exception as e:
            logger.error(f"Failed to send notification: {e}")
        
        return {
            "message": "已同意任务达人的议价",
            "application_id": application_id,
            "status": "price_agreed",
            "final_price": application.final_price
        }
    else:
        # 7. 拒绝议价：恢复为pending状态
        application.status = "pending"
        application.expert_counter_price = None  # 清除议价
        application.updated_at = get_utc_time()
        
        await db.commit()
        await db.refresh(application)
        
        # 8. 发送通知给任务达人
        from app.task_notifications import send_counter_offer_rejected_notification
        try:
            await send_counter_offer_rejected_notification(
                db=db,
                expert_id=application.expert_id,
                applicant_id=application.applicant_id
            )
        except Exception as e:
            logger.error(f"Failed to send notification: {e}")
        
        return {
            "message": "已拒绝任务达人的议价",
            "application_id": application_id,
            "status": "pending"
        }
```

**简化版业务逻辑说明：**
- **同意时**：状态从`negotiating`变为`price_agreed`，记录`final_price`和`price_agreed_at`
- **拒绝时**：状态从`negotiating`恢复为`pending`，清除`expert_counter_price`

#### 5.4.5 任务达人同意申请（创建任务）

**POST** `/api/task-experts/applications/{application_id}/approve`

**请求体：**
```json
{}  // 无需参数，使用申请中已确定的价格
```

**响应：**
```json
{
  "message": "申请已同意，任务已创建",
  "application_id": 1,
  "task_id": 123,
  "task": {
    "id": 123,
    "title": "网站设计",
    "description": "...",
    "reward": 480.00,
    "task_type": "其他",
    "poster_id": "87654321",
    "taker_id": "12345678",
    "status": "in_progress"
  }
}
```

**业务逻辑：**
1. 验证申请状态为 `pending` 或 `price_agreed`
   - 如果状态为 `pending`：无议价，使用服务基础价格或用户议价价格
   - 如果状态为 `price_agreed`：用户已同意任务达人的议价，使用 `expert_counter_price`
2. 验证当前用户是任务达人（申请中的 `expert_id`）
3. 确定最终价格：
   - 如果状态为 `price_agreed`，使用 `expert_counter_price`
   - 否则，如果申请中有 `negotiated_price`（用户议价），使用该价格
   - 否则，使用服务的 `base_price`
4. 创建任务：
   - `title`: 服务的 `service_name`
   - `description`: 服务的 `description`
   - `reward`: 最终确定的价格
   - `base_reward`: 服务的 `base_price`
   - `agreed_reward`: 最终确定的价格
   - `task_type`: `"其他"`
   - `poster_id`: 申请用户ID（`applicant_id`）
   - `taker_id`: 任务达人ID（`expert_id`）
   - `status`: `"in_progress"`
   - `images`: 服务的 `images`（JSON格式）
5. 更新申请记录：
   - `status`: `"approved"`
   - `final_price`: 最终确定的价格
   - `task_id`: 创建的任务ID
   - `approved_at`: 当前时间
6. 注意：`application_count`已在创建申请时+1，这里不需要再次+1
7. 发送通知给申请用户（任务已创建）
8. 返回创建的任务信息

#### 5.4.6 任务达人拒绝申请

**POST** `/api/task-experts/applications/{application_id}/reject`

**请求体：**
```json
{
  "reject_reason": "暂时无法接受此申请"  // 可选
}
```

**响应：**
```json
{
  "message": "申请已拒绝",
  "application_id": 1
}
```

**业务逻辑：**
1. 验证申请状态为 `pending`
2. 验证当前用户是任务达人
3. 更新申请记录：
   - `status`: `"rejected"`
   - `rejected_at`: 当前时间
4. 发送通知给申请用户

#### 5.4.7 用户获取自己的申请列表

**GET** `/api/users/me/service-applications`

**查询参数：**
- `status`: 筛选状态
- `limit`: 每页数量
- `offset`: 偏移量

**响应：**
```json
{
  "total": 3,
  "items": [
    {
      "id": 1,
      "service_id": 1,
      "service_name": "网站设计",
      "expert_id": "12345678",
      "expert_name": "专业设计师",
      "status": "approved",
      "task_id": 123,
      "created_at": "2025-01-15T10:00:00Z"
    }
  ]
}
```

## 六、前端页面设计

### 6.1 任务达人申请页面

**路径：** `/task-experts/apply`

**功能：**
- 显示申请表单
- 填写申请说明
- 提交申请
- 显示申请状态（如果已有申请）

### 6.2 任务达人主页

**路径：** `/task-experts/{expert_id}`

**功能：**
- 显示任务达人信息（头像、名称、简介、评分等）
- 显示服务菜单列表（只显示上架的服务）
- 每个服务卡片显示：名称、描述、图片、价格
- 点击服务卡片进入服务详情页

### 6.3 服务详情页

**路径：** `/task-experts/services/{service_id}`

**功能：**
- 显示服务详细信息
- 显示任务达人信息
- "申请服务"按钮
- 申请弹窗：
  - 申请留言输入框
  - 议价选项（复选框 + 价格输入框）
  - 提交按钮

### 6.6 用户申请管理页面

**路径：** `/users/me/service-applications`

**功能：**
- 显示用户的所有服务申请列表
- 申请状态显示：
  - `pending`: 待处理（等待任务达人处理）
  - `negotiating`: 议价中（任务达人提出新价格，需要用户回应）
    - 显示任务达人提出的议价价格
    - 显示"同意议价"和"拒绝议价"按钮
  - `price_agreed`: 价格已达成一致（等待任务达人创建任务）
  - `approved`: 已同意（显示关联的任务链接，可进入任务聊天）
  - `rejected`: 已拒绝
- 申请详情显示：
  - 服务信息
  - 任务达人信息
  - 申请留言
  - 用户议价价格（如果有）
  - 任务达人议价价格（如果有）
  - 最终价格（如果已确定）
- 操作按钮：
  - **同意议价**：同意任务达人的再次议价（适用于 `negotiating` 状态）
  - **拒绝议价**：拒绝任务达人的议价，状态恢复为 `pending`（适用于 `negotiating` 状态）

### 6.4 任务达人管理后台

**路径：** `/task-experts/me/dashboard`

**功能：**
- 个人信息管理
- 服务管理：
  - 服务列表（可编辑、删除、上架/下架）
  - 创建新服务
  - 编辑服务
- 申请管理：
  - 收到的申请列表
  - 申请状态显示：
    - `pending`: 待处理（显示"同意"、"拒绝"、"再次议价"按钮）
    - `negotiating`: 议价中（显示任务达人提出的议价价格，等待用户回应）
    - `price_agreed`: 价格已达成一致（显示"创建任务"按钮）
    - `approved`: 已同意（显示关联的任务链接）
    - `rejected`: 已拒绝
  - 申请详情显示：
    - 用户信息
    - 申请留言
    - 用户议价价格（如果有）
    - 任务达人议价价格（如果有）
    - 最终价格（如果已确定）
  - 操作按钮：
    - **同意申请**：直接创建任务（适用于 `pending` 或 `price_agreed` 状态）
    - **拒绝申请**：拒绝该申请
    - **再次议价**：提出新的价格（适用于 `pending` 或 `negotiating` 状态）
      - 议价弹窗：输入新价格和说明
      - 提交后状态变为 `negotiating`

### 6.5 管理员审核页面

**路径：** `/admin/task-expert-applications`

**功能：**
- 申请列表（筛选、分页）
- 查看申请详情：
  - 用户信息（ID、姓名、邮箱等）
  - 申请说明
  - 申请时间
- 批准操作：
  - 点击"批准"按钮
  - 填写审核意见（可选）
  - 系统自动创建任务达人记录
  - **重要**：任务达人的ID自动设置为用户的ID（从申请中的 `user_id` 获取）
  - 创建成功后显示任务达人信息
- 拒绝操作：
  - 点击"拒绝"按钮
  - 填写审核意见（必填）
  - 更新申请状态为 `rejected`
- 验证逻辑：
  - 如果用户已经是任务达人，显示提示："该用户已经是任务达人"
  - 如果用户不存在，显示错误提示

## 七、任务创建逻辑

### 7.1 任务创建流程

当任务达人同意服务申请时（状态为 `pending` 或 `price_agreed`），系统自动创建任务：

```python
async def approve_service_application(
    db: AsyncSession,
    application_id: int,
    expert_id: str
) -> dict:
    """
    任务达人同意服务申请，创建任务
    
    支持两种状态：
    1. pending: 无议价或用户有议价，直接同意
    2. price_agreed: 用户已同意任务达人的再次议价，创建任务
    """
    # 1. 获取申请记录（使用FOR UPDATE锁，防止并发）
    # 注意：查询不限制status，以便幂等性检查可以访问approved状态
    application = await db.execute(
        select(ServiceApplication)
        .where(ServiceApplication.id == application_id)
        .where(ServiceApplication.expert_id == expert_id)
        .with_for_update()  # 并发安全：行级锁
    )
    application = application.scalar_one_or_none()
    
    if not application:
        raise HTTPException(status_code=404, detail="申请不存在")
    
    # 幂等性检查：如果已创建任务，直接返回
    if application.status == "approved" and application.task_id:
        from app.models import Task
        task = await db.execute(
            select(Task).where(Task.id == application.task_id)
        )
        task = task.scalar_one_or_none()
        return {
            "message": "任务已创建",
            "application_id": application_id,
            "task_id": application.task_id,
            "task": task
        }
    
    # 2. 校验状态：仅允许pending或price_agreed状态创建任务
    if application.status not in ("pending", "price_agreed"):
        raise HTTPException(status_code=409, detail="当前状态不允许创建任务")
    
    # 3. 获取服务信息
    service = await db.execute(
        select(TaskExpertService)
        .where(TaskExpertService.id == application.service_id)
    )
    service = service.scalar_one_or_none()
    
    if not service:
        raise HTTPException(status_code=404, detail="服务不存在")
    
    # 3.1 校验服务状态必须为active
    if service.status != "active":
        raise HTTPException(status_code=400, detail="服务未上架，无法创建任务")
    
    # 4. 确定最终价格
    if application.status == "price_agreed":
        # 用户已同意任务达人的议价，使用任务达人的议价价格
        if application.expert_counter_price is None:
            raise HTTPException(status_code=400, detail="议价价格不存在")
        price = float(application.expert_counter_price)
    elif application.negotiated_price is not None:
        # 用户提出的议价价格
        price = float(application.negotiated_price)
    else:
        # 使用服务基础价格
        price = float(service.base_price)
    
    # 4. 创建任务
    from app.models import Task
    from app.models import get_utc_time
    from datetime import timedelta
    
    # 设置截止日期（默认7天后）
    deadline = get_utc_time() + timedelta(days=7)
    
    # 处理图片（JSONB类型，直接使用list，不需要json.dumps）
    # service.images已经是list类型（JSONB自动反序列化），直接使用
    images_list = service.images if service.images else None
    
    new_task = Task(
        title=service.service_name,
        description=service.description,
        deadline=deadline,
        reward=price,
        base_reward=service.base_price,
        agreed_reward=price,
        currency=application.currency or service.currency,
        location="线上",  # 任务达人服务默认线上
        task_type="其他",
        poster_id=application.applicant_id,  # 申请用户是发布人
        taker_id=application.expert_id,  # 任务达人接收方
        status="in_progress",
        images=images_list,  # 直接使用list，ORM会自动处理JSONB序列化（Task.images也应为JSONB类型）
        created_at=get_utc_time(),
        accepted_at=get_utc_time()
    )
    
    db.add(new_task)
    await db.flush()  # 获取任务ID
    
    # 5. 更新申请记录
    application.status = "approved"
    application.final_price = price
    application.task_id = new_task.id
    application.approved_at = get_utc_time()
    application.updated_at = get_utc_time()
    
    # 如果之前有议价，保留议价历史（不删除 expert_counter_price 和 negotiated_price）
    
    # 7. 注意：application_count在创建申请时已+1，这里不需要再次+1
    # 如果需要统计"成交次数"，应使用单独的order_count字段
    
    await db.commit()
    await db.refresh(new_task)
    
    # 8. 发送通知给申请用户（任务已创建）
    from app.task_notifications import send_service_application_approved_notification
    try:
        await send_service_application_approved_notification(
            db=db,
            applicant_id=application.applicant_id,
            expert_id=application.expert_id,
            task_id=new_task.id,
            service_name=service.service_name
        )
    except Exception as e:
        # 通知失败不影响主流程
        logger.error(f"Failed to send notification: {e}")
    
    return {
        "message": "申请已同意，任务已创建",
        "application_id": application_id,
        "task_id": new_task.id,
        "task": new_task
    }
```

### 7.2 任务字段映射

| 任务字段 | 数据来源 | 说明 |
|---------|---------|------|
| `title` | `service.service_name` | 服务名称 |
| `description` | `service.description` | 服务描述 |
| `reward` | `final_price` | 最终确定的价格 |
| `base_reward` | `service.base_price` | 服务基础价格 |
| `agreed_reward` | `final_price` | 最终确定的价格 |
| `currency` | `application.currency` 或 `service.currency` | 货币类型 |
| `location` | `"线上"` | 默认线上 |
| `task_type` | `"其他"` | 固定为"其他" |
| `poster_id` | `application.applicant_id` | 申请用户 |
| `taker_id` | `application.expert_id` | 任务达人 |
| `status` | `"in_progress"` | 直接进入进行中状态 |
| `images` | `service.images` | 服务图片（JSONB类型，list格式） |
| `deadline` | 当前时间 + 7天 | 默认7天后截止 |
| `accepted_at` | 当前时间 | 立即接受 |

### 7.3 任务表（Task）完整DDL和ORM定义

**重要**：本文档中创建任务时使用的字段，需要确保Task表支持以下字段和类型。

**DDL定义（PostgreSQL）：**

```sql
-- Task表关键字段（与本功能相关）
-- 注意：这是本功能所需的最小字段集合，实际Task表可能包含更多字段

CREATE TABLE tasks (
    id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    title VARCHAR(100) NOT NULL,
    description TEXT NOT NULL,
    deadline TIMESTAMPTZ NOT NULL,  -- 必须为TIMESTAMPTZ
    reward DECIMAL(12, 2) NOT NULL,
    base_reward DECIMAL(12, 2) NOT NULL,
    agreed_reward DECIMAL(12, 2),
    currency VARCHAR(3) DEFAULT 'GBP' CHECK (currency ~ '^[A-Z]{3}$'),  -- ISO 4217格式
    location VARCHAR(100) NOT NULL,
    task_type VARCHAR(50) NOT NULL,  -- 本功能固定为"其他"
    poster_id VARCHAR(8) REFERENCES users(id) ON DELETE CASCADE,
    taker_id VARCHAR(8) REFERENCES users(id) ON DELETE SET NULL,
    status VARCHAR(20) DEFAULT 'open' CHECK (status IN ('open', 'in_progress', 'completed', 'cancelled')),
    images JSONB,  -- 必须为JSONB类型，与TaskExpertService.images一致
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,  -- 必须为TIMESTAMPTZ
    accepted_at TIMESTAMPTZ,  -- 必须为TIMESTAMPTZ
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
    -- ... 其他字段（如completed_at, cancelled_at等）
    -- 注意：
    -- 1. 本功能创建任务时，status会显式设置为'in_progress'，不使用默认值'open'
    -- 2. updated_at在ORM中通过onupdate自动更新，原生SQL更新需手动设置
);

-- 索引（必须在CREATE TABLE之后单独创建）
CREATE INDEX idx_tasks_poster_id ON tasks(poster_id);
CREATE INDEX idx_tasks_taker_id ON tasks(taker_id);
CREATE INDEX idx_tasks_status ON tasks(status);
CREATE INDEX idx_tasks_created_at ON tasks(created_at);
```

**ORM模型片段（SQLAlchemy）：**

```python
from sqlalchemy import Column, Integer, String, Text, DECIMAL, DateTime, ForeignKey, Index, CheckConstraint
from sqlalchemy.dialects.postgresql import JSONB
from sqlalchemy.sql import func
from app.models import Base, get_utc_time

class Task(Base):
    """任务表（与本功能相关的关键字段）"""
    __tablename__ = "tasks"
    
    id = Column(Integer, primary_key=True)
    title = Column(String(100), nullable=False)
    description = Column(Text, nullable=False)
    deadline = Column(DateTime(timezone=True), nullable=False)  # TIMESTAMPTZ
    reward = Column(DECIMAL(12, 2), nullable=False)
    base_reward = Column(DECIMAL(12, 2), nullable=False)
    agreed_reward = Column(DECIMAL(12, 2), nullable=True)
    currency = Column(String(3), default="GBP", nullable=False)
    location = Column(String(100), nullable=False)
    task_type = Column(String(50), nullable=False)
    poster_id = Column(String(8), ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    taker_id = Column(String(8), ForeignKey("users.id", ondelete="SET NULL"), nullable=True)
    status = Column(String(20), default="open", nullable=False)
    images = Column(JSONB, nullable=True)  # JSONB类型，与TaskExpertService.images一致
    created_at = Column(DateTime(timezone=True), default=get_utc_time, server_default=func.now())
    accepted_at = Column(DateTime(timezone=True), nullable=True)  # TIMESTAMPTZ
    updated_at = Column(DateTime(timezone=True), default=get_utc_time, onupdate=get_utc_time, server_default=func.now())
    
    __table_args__ = (
        Index("idx_tasks_poster_id", poster_id),
        Index("idx_tasks_taker_id", taker_id),
        Index("idx_tasks_status", status),
        Index("idx_tasks_created_at", created_at),
        CheckConstraint("currency ~ '^[A-Z]{3}$'", name="ck_tasks_currency"),
        CheckConstraint("status IN ('open', 'in_progress', 'completed', 'cancelled')", name="ck_tasks_status"),
    )
```

**迁移脚本（如果Task表尚未使用JSONB和TIMESTAMPTZ）：**

```sql
-- 迁移images字段为JSONB（如果当前是TEXT类型）
ALTER TABLE tasks 
  ALTER COLUMN images TYPE JSONB USING images::jsonb;

-- 迁移时间字段为TIMESTAMPTZ（如果当前是TIMESTAMP类型）
ALTER TABLE tasks 
  ALTER COLUMN deadline TYPE TIMESTAMPTZ USING deadline AT TIME ZONE 'UTC',
  ALTER COLUMN created_at TYPE TIMESTAMPTZ USING created_at AT TIME ZONE 'UTC',
  ALTER COLUMN accepted_at TYPE TIMESTAMPTZ USING accepted_at AT TIME ZONE 'UTC',
  ALTER COLUMN updated_at TYPE TIMESTAMPTZ USING updated_at AT TIME ZONE 'UTC';

-- 添加CHECK约束（如果尚未添加）
ALTER TABLE tasks 
  ADD CONSTRAINT ck_tasks_currency CHECK (currency ~ '^[A-Z]{3}$');

ALTER TABLE tasks 
  ADD CONSTRAINT ck_tasks_status CHECK (status IN ('open', 'in_progress', 'completed', 'cancelled'));
```

**字段类型要求总结：**
- `images`: 必须为 `JSONB` 类型（与 `TaskExpertService.images` 一致）
- `deadline`, `created_at`, `accepted_at`, `updated_at`: 必须为 `TIMESTAMPTZ` 类型
- `currency`: `VARCHAR(3)`，默认 `'GBP'`，带CHECK约束
- `task_type`: 必须支持 `"其他"` 值
- `status`: 必须支持 `"in_progress"` 值

## 八、任务聊天页面集成

### 8.1 任务自动出现在聊天页面

任务创建后，会自动出现在任务聊天页面（`/messages`）中，因为：

1. **任务查询逻辑**：任务聊天页面会查询所有与当前用户相关的任务（`poster_id` 或 `taker_id` 等于当前用户ID）
2. **新任务自动显示**：由于任务创建时已经设置了 `poster_id` 和 `taker_id`，任务会立即出现在双方的聊天列表中

### 8.2 聊天功能

- 申请用户和任务达人可以在任务聊天页面中正常聊天
- 支持文本消息、图片消息
- 支持任务状态查看和操作（完成、取消等）
- 支持评价功能

## 九、通知系统

### 9.1 需要发送的通知

1. **用户申请成为任务达人**
   - 发送给管理员（新申请通知）

2. **管理员批准/拒绝申请**
   - 发送给申请用户（申请结果通知）

3. **用户申请服务**
   - 发送给任务达人（新服务申请通知）
   - 如果用户有议价，在通知中显示议价价格

4. **任务达人再次议价**
   - 发送给申请用户（任务达人提出新的议价价格）
   - 通知内容包含：任务达人提出的新价格和说明（如果有）

5. **用户同意/拒绝任务达人的议价**
   - 发送给任务达人（用户回应议价的结果）
   - 如果同意，通知内容包含：用户已同意议价，可以创建任务

6. **任务达人同意服务申请（创建任务）**
   - 发送给申请用户（申请结果通知）
   - 通知内容包含：任务已创建，可以进入任务聊天页面
   - 通知中包含任务链接

7. **任务达人拒绝服务申请**
   - 发送给申请用户（申请被拒绝通知）

## 十、开发步骤

### 阶段一：数据库和模型

1. ✅ 创建数据库迁移脚本
2. ✅ 定义SQLAlchemy模型
3. ✅ 定义Pydantic Schema
4. ✅ 运行数据库迁移

### 阶段二：后端API开发

1. ✅ 任务达人申请相关API
2. ✅ 管理员审核API
3. ✅ 任务达人管理API
4. ✅ 服务菜单管理API
5. ✅ 服务申请相关API
6. ✅ 任务创建逻辑

### 阶段三：前端页面开发

1. ✅ 任务达人申请页面
2. ✅ 任务达人主页
3. ✅ 服务详情页
4. ✅ 任务达人管理后台
5. ✅ 管理员审核页面

### 阶段四：通知和集成

1. 🔄 实现通知逻辑（进行中 - 已提供接口示例，需落地实现）
2. ✅ 集成到任务聊天页面
3. 🔄 测试完整流程（待通知逻辑完成后）

### 阶段五：测试和优化

1. ✅ 单元测试
2. ✅ 集成测试
3. ✅ 性能优化
4. ✅ 用户体验优化

## 十一、注意事项

### 11.1 数据一致性

- **任务达人ID与用户ID一致**：
  - 任务达人记录的 `id` 必须与用户在 `users` 表中的 `id` 完全相同
  - 管理员批准申请时，使用申请中的 `user_id` 作为任务达人的 `id`
  - 通过外键约束 `REFERENCES users(id)` 和主键约束确保一对一关系
  - 这确保了每个用户最多只能有一个任务达人身份
- **关联已批准的申请**：
  - 创建任务达人时，通过 `approved_by` 字段关联批准的管理员
  - 通过 `approved_at` 字段记录批准时间
  - 申请记录中的 `reviewed_by` 和 `reviewed_at` 字段记录了审核信息
- **级联删除**：
  - 删除用户时，自动删除关联的任务达人记录和服务（`ON DELETE CASCADE`）
  - 删除服务时，自动删除关联的申请记录

### 11.2 权限控制

- 只有任务达人可以管理自己的服务
- 只有任务达人可以处理收到的服务申请
- 只有管理员可以审核任务达人申请
- 用户只能申请上架的服务

### 11.3 价格处理

- 使用 `DECIMAL` 类型存储价格，避免精度问题
- 用户申请时可以提出议价（可选）
- 任务达人可以提出再次议价（可选）
- 价格确定优先级：
  1. 如果状态为 `price_agreed`，使用任务达人的议价价格（`expert_counter_price`）
  2. 如果用户有议价（`negotiated_price`），使用用户议价价格
  3. 否则，使用服务基础价格（`base_price`）
- 议价历史保留：创建任务后，不删除 `negotiated_price` 和 `expert_counter_price`，保留议价历史记录

### 11.4 任务类型

- 任务类型固定为 `"其他"`
- 确保前端任务类型列表包含 `"其他"` 选项

### 11.5 申请状态流转

申请状态流转图：

```
pending (待处理)
  ├─→ approved (同意) → 创建任务
  ├─→ rejected (拒绝)
  └─→ negotiating (议价中) → 任务达人提出再次议价
       ├─→ price_agreed (价格已达成一致) → 任务达人同意 → 创建任务
       └─→ pending (拒绝议价，恢复待处理)
```

**状态说明：**
- `pending`: 初始状态，用户已申请，等待任务达人处理
- `negotiating`: 任务达人提出再次议价，等待用户回应
- `price_agreed`: 用户同意任务达人的议价，等待任务达人创建任务
- `approved`: 任务已创建
- `rejected`: 申请被拒绝
- `cancelled`: 申请被取消（用户主动取消）

**状态转换规则：**
1. 只有 `pending` 或 `negotiating` 状态的申请，任务达人才可以再次议价
2. 只有 `negotiating` 状态的申请，用户才可以同意/拒绝议价
3. 只有 `pending` 或 `price_agreed` 状态的申请，任务达人才可以同意并创建任务
4. 只有 `pending` 状态的申请，任务达人才可以拒绝

### 11.6 图片处理

- 服务图片存储为JSON数组格式
- 创建任务时，将服务图片复制到任务的 `images` 字段

## 十二、关键修复与改进（必须立即修复）

### 12.1 部分唯一索引迁移脚本 ⚠️ 高优先级

**状态**：ORM模型中已实现部分唯一索引（见4.1节），但需要确保数据库中存在对应的索引。

**说明**：以下索引已在ORM模型中定义：
- `TaskExpertApplication` 的 `uq_expert_app_pending`（仅 status='pending' 唯一）
- `ServiceApplication` 的 `uq_service_app_pending_combo`（pending/negotiating/price_agreed 唯一）

**需要执行**：运行迁移脚本确保线上数据库存在这些索引。

**修复方案（PostgreSQL + SQLAlchemy）：**

**注意**：SQLAlchemy的`UniqueConstraint`不支持`postgresql_where`参数，必须使用`Index(..., unique=True, postgresql_where=...)`。

**✅ 正确做法（已在ORM模型中实现，见4.1节）：**
```python
# 已在TaskExpertApplication和ServiceApplication模型中实现
# 使用Index(..., unique=True, postgresql_where=...)
# 无需额外添加
```

**❌ 错误做法（不要使用）：**
```python
# UniqueConstraint不支持postgresql_where，以下代码不会生效
UniqueConstraint(
    user_id, status,
    name="uq_expert_app_pending",
    postgresql_where=(status == "pending")  # ❌ SQLAlchemy会忽略where条件
)
```

**迁移脚本（推荐使用SQL直接创建）：**

```sql
-- 确保同一用户只能有一个pending申请
CREATE UNIQUE INDEX uq_expert_app_pending
ON task_expert_applications (user_id, status)
WHERE status = 'pending';

-- 确保同一用户对同一服务在pending/negotiating/price_agreed状态只能有一条
CREATE UNIQUE INDEX uq_service_app_pending_combo
ON service_applications (service_id, applicant_id, status)
WHERE status IN ('pending', 'negotiating', 'price_agreed');
```

**注意**：ORM中使用`Index(..., unique=True, postgresql_where=...)`，但实际创建索引时建议使用SQL脚本，确保数据库层面正确创建。

### 12.2 时间/时区策略修复 ⚠️ 高优先级 ✅ 已统一

**问题**：使用 `TIMESTAMP`（无时区）和 `get_uk_time_naive()`，夏令时切换会产生歧义，跨区域难以统一。

**状态**：所有DDL已统一为TIMESTAMPTZ，所有代码已统一使用get_utc_time()。以下为历史迁移脚本（仅用于已有数据库）。

**修复方案：**

1. **数据库列改为 TIMESTAMPTZ：**
```sql
-- 迁移脚本
ALTER TABLE task_expert_applications 
  ALTER COLUMN created_at TYPE TIMESTAMPTZ USING created_at AT TIME ZONE 'UTC',
  ALTER COLUMN updated_at TYPE TIMESTAMPTZ USING updated_at AT TIME ZONE 'UTC',
  ALTER COLUMN reviewed_at TYPE TIMESTAMPTZ USING reviewed_at AT TIME ZONE 'UTC';

-- 其他表同样处理
ALTER TABLE task_experts 
  ALTER COLUMN created_at TYPE TIMESTAMPTZ USING created_at AT TIME ZONE 'UTC',
  ALTER COLUMN updated_at TYPE TIMESTAMPTZ USING updated_at AT TIME ZONE 'UTC',
  ALTER COLUMN approved_at TYPE TIMESTAMPTZ USING approved_at AT TIME ZONE 'UTC';

ALTER TABLE task_expert_services 
  ALTER COLUMN created_at TYPE TIMESTAMPTZ USING created_at AT TIME ZONE 'UTC',
  ALTER COLUMN updated_at TYPE TIMESTAMPTZ USING updated_at AT TIME ZONE 'UTC';

ALTER TABLE service_applications 
  ALTER COLUMN created_at TYPE TIMESTAMPTZ USING created_at AT TIME ZONE 'UTC',
  ALTER COLUMN updated_at TYPE TIMESTAMPTZ USING updated_at AT TIME ZONE 'UTC',
  ALTER COLUMN approved_at TYPE TIMESTAMPTZ USING approved_at AT TIME ZONE 'UTC',
  ALTER COLUMN rejected_at TYPE TIMESTAMPTZ USING rejected_at AT TIME ZONE 'UTC',
  ALTER COLUMN price_agreed_at TYPE TIMESTAMPTZ USING price_agreed_at AT TIME ZONE 'UTC';
```

2. **ORM模型使用带时区的DateTime：**
```python
from sqlalchemy import DateTime, func
from datetime import datetime, timezone

# 统一使用UTC时间
def get_utc_time():
    """获取当前UTC时间（用于数据库存储）"""
    return datetime.now(timezone.utc)

# 模型定义
class TaskExpertApplication(Base):
    # ...
    created_at = Column(DateTime(timezone=True), default=get_utc_time, server_default=func.now())
    updated_at = Column(DateTime(timezone=True), default=get_utc_time, onupdate=get_utc_time, server_default=func.now())
    reviewed_at = Column(DateTime(timezone=True), nullable=True)
```

3. **应用层统一使用UTC，展示时转换为Europe/London：**
```python
from datetime import datetime, timezone
import pytz

def format_for_display(utc_dt: datetime) -> str:
    """将UTC时间转换为英国时间并格式化显示"""
    if utc_dt.tzinfo is None:
        utc_dt = utc_dt.replace(tzinfo=timezone.utc)
    uk_tz = pytz.timezone("Europe/London")
    uk_time = utc_dt.astimezone(uk_tz)
    return uk_time.strftime("%Y-%m-%d %H:%M:%S %Z")
```

### 12.3 金额字段校验不足 ⚠️ 高优先级

**问题**：`ServiceApplicationCreate.negotiated_price` 没有校验，可能接受非正数或极小数。

**修复方案：**

```python
from pydantic import Field, condecimal
from decimal import Decimal

class ServiceApplicationCreate(BaseModel):
    service_id: int
    application_message: Optional[str] = None
    negotiated_price: Optional[condecimal(gt=0, max_digits=12, decimal_places=2)] = None
    currency: Literal["GBP"] = "GBP"  # 限制为GBP，后续可扩展

class CounterOfferRequest(BaseModel):
    """任务达人再次议价请求"""
    counter_price: condecimal(gt=0, max_digits=12, decimal_places=2) = Field(..., description="任务达人提出的议价价格")
    message: Optional[str] = None
```

**服务端额外校验：**

```python
async def create_service_application(
    db: AsyncSession,
    service_id: int,
    applicant_id: str,
    negotiated_price: Optional[Decimal] = None
):
    # 获取服务信息
    service = await db.execute(
        select(TaskExpertService).where(TaskExpertService.id == service_id)
    )
    service = service.scalar_one_or_none()
    
    if not service or service.status != "active":
        raise HTTPException(status_code=400, detail="服务不存在或未上架")
    
    # 校验议价价格
    if negotiated_price is not None:
        if negotiated_price <= 0:
            raise HTTPException(status_code=400, detail="议价价格必须大于0")
        # 可选：设置最低价为基础价格的某个比例（如50%）
        min_price = service.base_price * Decimal('0.5')
        if negotiated_price < min_price:
            raise HTTPException(
                status_code=400, 
                detail=f"议价价格不能低于基础价格的50%（最低{min_price}）"
            )
    
    # 校验用户不能申请自己的服务
    if service.expert_id == applicant_id:
        raise HTTPException(status_code=400, detail="不能申请自己的服务")
    
    # ... 创建申请逻辑
```

### 12.4 application_count 语义修复 ⚠️ 中优先级 ✅ 已修复

**问题**：字段注释写"申请次数"，但只在"同意并创建任务"时+1，实际统计的是"成交次数"。

**修复方案（已采用方案1）：**

```python
# ✅ 方案1：在创建申请时就+1（已采用，使用SQL原子更新）
async def create_service_application(...):
    # ... 创建申请逻辑
    
    # 更新服务统计：申请时+1（使用SQL原子更新，避免并发丢失）
    from sqlalchemy import update
    await db.execute(
        update(TaskExpertService)
        .where(TaskExpertService.id == service_id)
        .values(application_count=TaskExpertService.application_count + 1)
    )
    
    await db.commit()

# 注意：在"同意并创建任务"时不再+1，因为申请时已经统计过了
# 如果需要统计"成交次数"，应添加单独的order_count字段：
# order_count = Column(Integer, default=0)  # 成交次数（同意并创建任务时+1）
```

### 12.5 图片字段类型修复 ⚠️ 中优先级

**问题**：DB存TEXT（JSON字符串），Pydantic是List[str]，容易出现双重转义/类型错误。

**修复方案：**

```python
from sqlalchemy.dialects.postgresql import JSONB

class TaskExpertService(Base):
    # ...
    images = Column(JSONB, nullable=True)  # 使用PostgreSQL JSONB类型
```

**迁移脚本：**

```sql
-- 将TEXT类型的JSON转换为JSONB
ALTER TABLE task_expert_services 
  ALTER COLUMN images TYPE JSONB USING images::jsonb;

-- 如果images字段为空或无效JSON，设置为NULL
UPDATE task_expert_services 
SET images = NULL 
WHERE images IS NULL OR images = '' OR NOT (images::text ~ '^[\s]*[\[\{]');
```

**ORM自动处理序列化：**

```python
# SQLAlchemy会自动处理JSONB和Python list的转换
service.images = ["url1", "url2"]  # 直接赋值list
# 存储时自动转换为JSONB
# 读取时自动转换为list
```

### 12.6 并发审批/创建任务的竞态修复 ⚠️ 高优先级

**问题**：管理员审核和任务达人同意申请可能并发触发，没有FOR UPDATE锁和幂等保护。

**修复方案：**

```python
from sqlalchemy import select
from sqlalchemy.orm import with_for_update

# 1. 管理员审核申请（并发安全）
async def review_expert_application(
    db: AsyncSession,
    application_id: int,
    action: str,
    current_admin: models.AdminUser
):
    # 使用FOR UPDATE锁
    application = await db.execute(
        select(TaskExpertApplication)
        .where(TaskExpertApplication.id == application_id)
        .where(TaskExpertApplication.status == "pending")
        .with_for_update()  # 行级锁，防止并发
    )
    application = application.scalar_one_or_none()
    
    if not application:
        raise HTTPException(status_code=404, detail="申请不存在或已处理")
    
    if action == "approve":
        # 检查是否已经是任务达人（主键冲突自然防重）
        existing_expert = await db.execute(
            select(TaskExpert).where(TaskExpert.id == application.user_id)
        )
        if existing_expert.scalar_one_or_none():
            raise HTTPException(status_code=400, detail="该用户已经是任务达人")
        
        # 创建任务达人（主键约束确保唯一性）
        try:
            new_expert = TaskExpert(
                id=application.user_id,
                # ...
            )
            db.add(new_expert)
            application.status = "approved"
            # ...
            await db.commit()
        except IntegrityError:
            await db.rollback()
            raise HTTPException(status_code=409, detail="该用户已经是任务达人")

# 2. 任务达人同意申请（并发安全 + 幂等）
async def approve_service_application(
    db: AsyncSession,
    application_id: int,
    expert_id: str
):
    # 使用FOR UPDATE锁
    application = await db.execute(
        select(ServiceApplication)
        .where(ServiceApplication.id == application_id)
        .where(ServiceApplication.expert_id == expert_id)
        .where(ServiceApplication.status.in_(["pending", "price_agreed"]))
        .with_for_update()  # 行级锁
    )
    application = application.scalar_one_or_none()
    
    if not application:
        raise HTTPException(status_code=404, detail="申请不存在或状态不正确")
    
    # 幂等性检查：如果已创建任务，直接返回
    if application.status == "approved" and application.task_id:
        return {
            "message": "任务已创建",
            "application_id": application_id,
            "task_id": application.task_id,
            "task": await get_task(db, application.task_id)
        }
    
    # ... 创建任务逻辑
    # 在同一个事务中完成所有操作，确保原子性
```

### 12.7 权限/业务校验缺口修复 ⚠️ 高优先级

**问题**：文档写了规则，但API示例缺少强校验。

**修复方案：**

```python
# 用户申请服务时的完整校验
async def create_service_application(
    db: AsyncSession,
    service_id: int,
    current_user: models.User,
    application_data: ServiceApplicationCreate
):
    # 1. 获取服务信息
    service = await db.execute(
        select(TaskExpertService)
        .where(TaskExpertService.id == service_id)
    )
    service = service.scalar_one_or_none()
    
    if not service:
        raise HTTPException(status_code=404, detail="服务不存在")
    
    # 2. 校验服务状态必须为active
    if service.status != "active":
        raise HTTPException(status_code=400, detail="服务未上架，无法申请")
    
    # 3. 校验用户不能申请自己的服务
    if service.expert_id == current_user.id:
        raise HTTPException(status_code=400, detail="不能申请自己的服务")
    
    # 4. 校验是否已有待处理的申请
    existing = await db.execute(
        select(ServiceApplication)
        .where(ServiceApplication.service_id == service_id)
        .where(ServiceApplication.applicant_id == current_user.id)
        .where(ServiceApplication.status.in_(["pending", "negotiating", "price_agreed"]))
    )
    if existing.scalar_one_or_none():
        raise HTTPException(status_code=400, detail="您已申请过此服务，请等待处理")
    
    # 5. 校验议价价格
    if application_data.negotiated_price is not None:
        if application_data.negotiated_price <= 0:
            raise HTTPException(status_code=400, detail="议价价格必须大于0")
        # 设置最低价为基础价格的50%
        min_price = service.base_price * Decimal('0.5')
        if application_data.negotiated_price < min_price:
            raise HTTPException(
                status_code=400, 
                detail=f"议价价格不能低于基础价格的50%（最低{min_price}）"
            )
    
    # 6. 创建申请记录
    from app.models import get_utc_time
    new_application = ServiceApplication(
        service_id=service_id,
        applicant_id=current_user.id,
        expert_id=service.expert_id,
        application_message=application_data.application_message,
        negotiated_price=application_data.negotiated_price,
        currency=application_data.currency,
        status="pending",
        created_at=get_utc_time()
    )
    db.add(new_application)
    
    # 7. 更新服务统计：申请时+1（使用SQL原子更新，避免并发丢失）
    from sqlalchemy import update
    await db.execute(
        update(TaskExpertService)
        .where(TaskExpertService.id == service_id)
        .values(application_count=TaskExpertService.application_count + 1)
    )
    
    await db.commit()
    await db.refresh(new_application)
    
    # 8. 发送通知给任务达人
    from app.task_notifications import send_service_application_notification
    try:
        await send_service_application_notification(
            db=db,
            expert_id=service.expert_id,
            applicant_id=current_user.id,
            service_id=service_id,
            service_name=service.service_name,
            negotiated_price=application_data.negotiated_price
        )
    except Exception as e:
        logger.error(f"Failed to send notification: {e}")
    
    return new_application

# 任务达人再次议价时的校验
async def counter_offer_service_application(
    db: AsyncSession,
    application_id: int,
    current_user: models.User,
    counter_offer: CounterOfferRequest
):
    # 1. 获取申请（带锁）
    application = await db.execute(
        select(ServiceApplication)
        .where(ServiceApplication.id == application_id)
        .with_for_update()
    )
    application = application.scalar_one_or_none()
    
    if not application:
        raise HTTPException(status_code=404, detail="申请不存在")
    
    # 2. 校验必须是任务达人本人
    if application.expert_id != current_user.id:
        raise HTTPException(status_code=403, detail="只能处理自己的服务申请")
    
    # 3. 校验状态
    if application.status not in ["pending", "negotiating"]:
        raise HTTPException(status_code=400, detail="当前状态不允许议价")
    
    # 4. 校验议价价格
    if counter_offer.counter_price <= 0:
        raise HTTPException(status_code=400, detail="议价价格必须大于0")
    
    # ... 更新申请逻辑
```

### 12.8 通知逻辑实现 ⚠️ 中优先级 ✅ 已提供接口示例

**状态**：已更新阶段四状态为"进行中"，并提供完整的通知接口实现示例（见12.8节）。

**注意**：所有关键流程代码示例中已添加通知调用，使用try-except确保通知失败不影响主流程。

### 12.9 其他重要改进

#### 12.9.1 状态值收敛为枚举 + CHECK约束 ✅ 推荐执行

**迁移脚本：**

```sql
-- 方案1：使用CHECK约束（推荐，更灵活）
ALTER TABLE task_expert_applications 
  ADD CONSTRAINT ck_expert_app_status 
  CHECK (status IN ('pending', 'approved', 'rejected'));

ALTER TABLE service_applications 
  ADD CONSTRAINT ck_service_app_status 
  CHECK (status IN ('pending', 'negotiating', 'price_agreed', 'approved', 'rejected', 'cancelled'));

ALTER TABLE task_experts 
  ADD CONSTRAINT ck_expert_status 
  CHECK (status IN ('active', 'inactive', 'suspended'));

ALTER TABLE task_expert_services 
  ADD CONSTRAINT ck_service_status 
  CHECK (status IN ('active', 'inactive'));

-- currency校验为ISO 4217（3位大写字母）
ALTER TABLE task_expert_services 
  ADD CONSTRAINT ck_currency 
  CHECK (currency ~ '^[A-Z]{3}$');

ALTER TABLE service_applications 
  ADD CONSTRAINT ck_currency 
  CHECK (currency ~ '^[A-Z]{3}$');

-- 方案2：使用PostgreSQL枚举类型（可选，更严格但迁移复杂）
-- CREATE TYPE application_status AS ENUM ('pending', 'approved', 'rejected');
-- CREATE TYPE service_application_status AS ENUM ('pending', 'negotiating', 'price_agreed', 'approved', 'rejected', 'cancelled');
-- CREATE TYPE expert_status AS ENUM ('active', 'inactive', 'suspended');
-- CREATE TYPE service_status AS ENUM ('active', 'inactive');
-- 然后修改列类型：ALTER TABLE ... ALTER COLUMN status TYPE application_status USING status::application_status;
```

#### 12.9.2 SERIAL改为Identity ✅ 推荐执行

**迁移脚本（PostgreSQL 10+）：**

```sql
-- 现有表迁移为Identity
ALTER TABLE task_expert_applications 
  ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY;

ALTER TABLE task_expert_services 
  ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY;

ALTER TABLE service_applications 
  ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY;

-- 新表直接使用Identity
-- CREATE TABLE ... (
--     id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
--     ...
-- );
```

#### 12.9.3 分页/排序一致性

```python
# API响应统一格式
class PaginatedResponse(BaseModel):
    total: int
    items: List[Any]
    limit: int
    offset: int
    has_more: bool

# 统一默认排序
async def get_service_applications(
    db: AsyncSession,
    expert_id: str,
    limit: int = 20,
    offset: int = 0
):
    query = (
        select(ServiceApplication)
        .where(ServiceApplication.expert_id == expert_id)
        .order_by(ServiceApplication.created_at.desc())  # 统一按创建时间倒序
        .limit(limit)
        .offset(offset)
    )
    # ...
```

#### 12.9.4 用户取消申请的API ✅ 已完善

**完整实现（包含权限校验、状态校验、幂等性、并发安全）：**

```python
@router.post("/users/me/service-applications/{application_id}/cancel")
async def cancel_service_application(
    application_id: int,
    current_user: models.User = Depends(get_current_user_secure_async_csrf),
    db: AsyncSession = Depends(get_async_db_dependency),
):
    """用户取消自己的服务申请（完整校验 + 并发安全 + 幂等性）"""
    import logging
    from sqlalchemy import select
    from app.models import get_utc_time
    
    logger = logging.getLogger(__name__)
    
    # 1. 获取申请记录（带锁，防止并发）
    application = await db.execute(
        select(ServiceApplication)
        .where(ServiceApplication.id == application_id)
        .with_for_update()  # 并发安全：行级锁
    )
    application = application.scalar_one_or_none()
    
    if not application:
        raise HTTPException(status_code=404, detail="申请不存在")
    
    # 2. 权限校验：只能取消自己的申请
    if application.applicant_id != current_user.id:
        raise HTTPException(status_code=403, detail="只能取消自己的申请")
    
    # 3. 幂等性检查：如果已经是cancelled状态，直接返回
    if application.status == "cancelled":
        return {
            "message": "申请已取消",
            "application_id": application_id,
            "status": "cancelled"
        }
    
    # 4. 状态校验：只能取消特定状态的申请
    allowed_statuses = ["pending", "negotiating", "price_agreed"]
    if application.status not in allowed_statuses:
        raise HTTPException(
            status_code=400, 
            detail=f"当前状态（{application.status}）不允许取消，只能取消以下状态的申请：{', '.join(allowed_statuses)}"
        )
    
    # 5. 更新状态
    application.status = "cancelled"
    application.updated_at = get_utc_time()
    
    await db.commit()
    await db.refresh(application)
    
    # 6. 发送通知给任务达人（可选）
    from app.task_notifications import send_service_application_cancelled_notification
    try:
        await send_service_application_cancelled_notification(
            db=db,
            expert_id=application.expert_id,
            applicant_id=application.applicant_id,
            service_id=application.service_id
        )
    except Exception as e:
        logger.error(f"Failed to send notification: {e}")
    
    return {
        "message": "申请已取消",
        "application_id": application_id,
        "status": "cancelled"
    }
```

**允许取消的状态列表：**
- `pending`: 待处理状态
- `negotiating`: 议价中状态
- `price_agreed`: 价格已达成一致状态

**不允许取消的状态：**
- `approved`: 已同意（任务已创建，不能取消申请）
- `rejected`: 已拒绝（已结束）
- `cancelled`: 已取消（幂等返回）

**权限要求：**
- 只有申请人（`applicant_id`）可以取消自己的申请
- 任务达人不能取消申请（只能拒绝）

#### 12.9.5 avatar字段大小调整 ✅ 已统一为TEXT

**问题**：VARCHAR(200)可能偏小，CDN URL带query参数容易超长。

**状态**：DDL和ORM已统一为TEXT类型。

**迁移脚本（仅用于已有数据库）：**

```sql
-- 将VARCHAR(200)改为TEXT
ALTER TABLE task_experts 
  ALTER COLUMN avatar TYPE TEXT;

-- 同时添加rating的CHECK约束（如果尚未添加）
ALTER TABLE task_experts
  ADD CONSTRAINT chk_task_experts_rating_range
  CHECK (rating >= 0.00 AND rating <= 5.00);
```

#### 12.9.6 updated_at自动更新策略统一 ✅ 已说明

**问题**：DDL使用`DEFAULT CURRENT_TIMESTAMP`无法在UPDATE时自动更新，ORM使用`onupdate`，混用会导致不一致。

**方案A（应用层统一 - 已采用）：**
- ORM模型字段使用`onupdate=get_utc_time()`
- **所有写操作必须走ORM**，确保updated_at自动更新
- **原生SQL更新需手动设置**`updated_at = CURRENT_TIMESTAMP`，否则不会自动更新
- 建议在代码审查中检查是否有原生SQL更新，确保手动设置updated_at

**方案B（数据库触发器统一 - 可选）：**
```sql
-- 创建触发器函数
CREATE OR REPLACE FUNCTION touch_updated_at()
RETURNS trigger AS $$
BEGIN
  NEW.updated_at = CURRENT_TIMESTAMP;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 给涉及频繁更新的表挂触发器
DROP TRIGGER IF EXISTS trg_task_expert_applications_updated_at ON task_expert_applications;
CREATE TRIGGER trg_task_expert_applications_updated_at
BEFORE UPDATE ON task_expert_applications
FOR EACH ROW EXECUTE FUNCTION touch_updated_at();

DROP TRIGGER IF EXISTS trg_task_experts_updated_at ON task_experts;
CREATE TRIGGER trg_task_experts_updated_at
BEFORE UPDATE ON task_experts
FOR EACH ROW EXECUTE FUNCTION touch_updated_at();

DROP TRIGGER IF EXISTS trg_task_expert_services_updated_at ON task_expert_services;
CREATE TRIGGER trg_task_expert_services_updated_at
BEFORE UPDATE ON task_expert_services
FOR EACH ROW EXECUTE FUNCTION touch_updated_at();

DROP TRIGGER IF EXISTS trg_service_applications_updated_at ON service_applications;
CREATE TRIGGER trg_service_applications_updated_at
BEFORE UPDATE ON service_applications
FOR EACH ROW EXECUTE FUNCTION touch_updated_at();

DROP TRIGGER IF EXISTS trg_tasks_updated_at ON tasks;
CREATE TRIGGER trg_tasks_updated_at
BEFORE UPDATE ON tasks
FOR EACH ROW EXECUTE FUNCTION touch_updated_at();
```

**注意**：当前采用方案A，如需统一原生SQL更新，可切换到方案B。

#### 12.9.7 评分与累计字段维护策略

```python
# 在相关操作时更新统计
async def complete_task_for_expert(db: AsyncSession, task_id: int):
    """任务完成时更新任务达人统计"""
    task = await get_task(db, task_id)
    if task.taker_id:  # 任务达人是接收方
        expert = await get_expert(db, task.taker_id)
        expert.completed_tasks += 1
        # 更新评分（基于所有评价的平均值）
        # ... 计算逻辑
        await db.commit()

async def publish_service(db: AsyncSession, expert_id: str):
    """发布服务时更新统计"""
    expert = await get_expert(db, expert_id)
    expert.total_services += 1
    await db.commit()
```

## 十三、后续优化方向

1. **服务分类**：为服务添加分类标签
2. **服务评价**：用户可以对服务进行评价
3. **服务搜索**：支持按关键词搜索服务
4. **推荐系统**：根据用户行为推荐相关服务
5. **服务套餐**：支持多个服务组合成套餐
6. **预约功能**：支持预约特定时间段的服务
7. **服务统计**：任务达人查看服务数据统计
8. **风控与滥用防护**：最小接单价、频次限流、黑名单机制
9. **软删除/归档**：考虑合规与审计，引入软删除机制

## 十四、修复完成清单 ✅

### 已修复的关键问题（Blocking级别）

1. ✅ **重复字段reviewed_at**：已删除TaskExpertApplication中重复的定义，只保留带时区版本
2. ✅ **UTC/时区方案统一**：
   - 所有`get_uk_time_naive()`已改为`get_utc_time()`
   - 所有DateTime字段改为`DateTime(timezone=True)`
   - 所有DDL中的TIMESTAMP已改为TIMESTAMPTZ（包括tasks表）
   - 所有代码示例已统一使用UTC时间
   - 已删除所有旧版TIMESTAMP/TEXT DDL，只保留JSONB + TIMESTAMPTZ版本
3. ✅ **部分唯一约束写法**：
   - 已改为`Index(..., unique=True, postgresql_where=...)`（不再使用UniqueConstraint）
   - 已提供SQL迁移脚本作为推荐方案
4. ✅ **Schema统一**：
   - 已删除重复的ServiceApplicationCreate，只保留带`condecimal(gt=0)`校验的版本
   - 所有currency字段统一为`Literal["GBP"]`（TaskExpertServiceCreate、TaskExpertServiceUpdate、ServiceApplicationCreate等）
   - Field语法已修正为`Field(..., description=...)`
5. ✅ **reviewed_at字段对齐**：已从TaskExpert、TaskExpertService、ServiceApplication中移除（这些表不需要reviewed_at）
6. ✅ **application_count语义**：
   - 已修复：在创建申请时+1（使用SQL原子更新）
   - 在创建任务时不再+1
   - 所有相关代码示例已更新为SQL原子更新（不再使用`+= 1`）
7. ✅ **images字段类型**：
   - DDL已统一为JSONB（已删除旧版TEXT定义）
   - 创建任务时直接使用list，不再手动json.dumps
   - 已添加Task表完整DDL和ORM定义（7.3节）
8. ✅ **并发控制**：
   - 所有主流程代码示例已添加`with_for_update()`锁
   - 管理员审核、任务达人同意申请、用户申请服务等都已实现并发安全
   - 已实现幂等性检查
9. ✅ **业务校验完整嵌入**：
   - 用户申请服务：完整校验（服务状态、不能申请自己、重复申请、议价价格）
   - 任务达人再次议价：完整校验（身份、状态、价格）
   - 任务达人同意申请：完整校验（服务状态、幂等性）
   - 取消申请：完整校验（权限、状态、幂等性）
10. ✅ **通知逻辑**：
   - 已更新阶段四状态为"进行中"
   - 已提供完整的通知接口实现示例（12.8节）
   - 所有关键流程已添加通知调用
11. ✅ **部分唯一索引**：已在ORM中实现（使用Index），文档已更新说明
12. ✅ **关系命名**：已改为复数形式（expert_applications）
13. ✅ **tasks表契约**：已添加Task表完整DDL和ORM定义（7.3节），包含所有必需字段和类型
14. ✅ **计数原子更新**：application_count使用SQL原子更新（`UPDATE ... SET count = count + 1`），所有示例已更新
15. ✅ **取消接口**：已完善权限校验、状态校验、幂等性检查（12.9.4节）

### 需要执行的数据库迁移（必须执行）

**推荐执行顺序（减少回滚风险）：**

1. **时区迁移**：执行12.2节的TIMESTAMPTZ迁移脚本（所有表，包括tasks表）
   - 先迁移时间字段，确保数据一致性
2. **JSONB迁移**：执行12.5节的images字段迁移脚本（task_expert_services和tasks表）
   - 在时区迁移后进行，避免类型冲突
3. **部分唯一索引**：执行12.1节的索引创建脚本
   - 在数据迁移完成后创建索引，提高性能
4. **CHECK约束**：执行12.9.1节的状态值CHECK约束（推荐）
   - 在索引创建后添加约束，确保数据质量
5. **Identity迁移**：执行12.9.2节的SERIAL改为Identity（可选但推荐）
   - 最后进行，因为涉及主键修改
6. **avatar字段**：执行12.9.5节的VARCHAR(200)改为TEXT（可选但推荐）
   - 与Identity迁移一起进行，影响较小

**注意**：新建表直接使用IDENTITY、JSONB、TIMESTAMPTZ和CHECK约束，无需迁移。

### 代码实现检查清单

- ✅ 所有时间相关代码使用`get_utc_time()`，不再使用`get_uk_time_naive()`
- ✅ 所有关键流程使用`with_for_update()`实现并发安全
- ✅ application_count使用SQL原子更新（`UPDATE ... SET count = count + 1`）
- ✅ 所有业务校验已嵌入主流程代码
- ✅ 通知逻辑接口已提供，所有关键流程已添加通知调用
- ✅ images字段统一为JSONB，直接使用list，不再手动json.dumps
- ✅ Task表images字段必须为JSONB类型（见7.3节说明）
- ✅ Task表DateTime字段必须为TIMESTAMPTZ类型（见7.3节说明）
- ✅ 所有代码示例已添加logger定义（`import logging; logger = logging.getLogger(__name__)`）
- ✅ ORM与DDL字段类型已统一（avatar为Text，images为JSONB）
- ✅ 接口文档status枚举已完整（包含所有6种状态）
- ✅ updated_at策略已明确（ORM使用onupdate，原生SQL需手动设置）
- ✅ 幂等分支已修复（approve_service_application查询不限制status，幂等检查可达）
- ✅ 并发冲突处理已完善（create_service_application添加IntegrityError捕获）
- ✅ 更新接口金额类型已统一（TaskExpertServiceUpdate.base_price使用condecimal）
- ✅ 错误示例已删除（UniqueConstraint + postgresql_where已标注为错误做法）
- ✅ 取消接口已完善（包含权限校验、状态校验、幂等性、并发安全）

### 重要提醒

1. **Task表结构**：必须确保Task表支持本功能所需的所有字段和类型（见7.3节）
2. **并发安全**：所有涉及状态变更的操作必须使用`with_for_update()`锁
3. **原子更新**：计数字段必须使用SQL原子更新，避免并发丢失
4. **通知系统**：通知失败不应影响主流程，使用try-except包裹
5. **时间统一**：所有时间存储和操作统一使用UTC，展示时再转换为用户时区
6. **updated_at更新**：所有写操作必须走ORM，原生SQL更新需手动设置updated_at
7. **并发冲突**：创建申请时需捕获IntegrityError，返回友好的409错误
8. **幂等性**：关键操作（批准申请、创建任务）需实现幂等性检查


