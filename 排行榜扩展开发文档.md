# æ’è¡Œæ¦œæ‰©å±•å¼€å‘æ–‡æ¡£

## ç›®å½•
1. [æ¦‚è¿°](#æ¦‚è¿°)
2. [ç°æœ‰æ’è¡Œæ¦œæ¶æ„](#ç°æœ‰æ’è¡Œæ¦œæ¶æ„)
3. [æ‰©å±•æ’è¡Œæ¦œç±»å‹](#æ‰©å±•æ’è¡Œæ¦œç±»å‹)
4. [åç«¯å®ç°æŒ‡å—](#åç«¯å®ç°æŒ‡å—)
5. [å‰ç«¯å®ç°æŒ‡å—](#å‰ç«¯å®ç°æŒ‡å—)
6. [æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–](#æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–)
7. [APIè®¾è®¡è§„èŒƒ](#apiè®¾è®¡è§„èŒƒ)
8. [å®æ–½è®¡åˆ’](#å®æ–½è®¡åˆ’)

---

## æ¦‚è¿°

æœ¬æ–‡æ¡£æè¿°äº†å¦‚ä½•æ‰©å±•LinkUå¹³å°çš„æ’è¡Œæ¦œåŠŸèƒ½ï¼ŒåŒ…æ‹¬ä»»åŠ¡ç›¸å…³æ’è¡Œæ¦œã€å•†å®¶åˆ†ç±»æ’è¡Œæ¦œç­‰å¤šç§ç±»å‹çš„æ’è¡Œæ¦œå®ç°æ–¹æ¡ˆã€‚

### ç°æœ‰æ’è¡Œæ¦œåŠŸèƒ½

å½“å‰ç³»ç»Ÿå·²å®ç°ä»¥ä¸‹è®ºå›æ’è¡Œæ¦œï¼š
- **å‘å¸–æ’è¡Œæ¦œ** (`/api/forum/leaderboard/posts`) - æŒ‰å‘å¸–æ•°é‡æ’åº
- **å›å¤æ’è¡Œæ¦œ** (`/api/forum/leaderboard/replies`) - æŒ‰å›å¤æ•°é‡æ’åº
- **è·èµæ’è¡Œæ¦œ** (`/api/forum/leaderboard/likes`) - æŒ‰è·å¾—ç‚¹èµæ•°æ’åº

æ‰€æœ‰æ’è¡Œæ¦œæ”¯æŒæ—¶é—´å‘¨æœŸç­›é€‰ï¼š`all`ï¼ˆå…¨éƒ¨ï¼‰ã€`today`ï¼ˆä»Šå¤©ï¼‰ã€`week`ï¼ˆæœ¬å‘¨ï¼‰ã€`month`ï¼ˆæœ¬æœˆï¼‰

---

## ç°æœ‰æ’è¡Œæ¦œæ¶æ„

### åç«¯æ¶æ„

**æ–‡ä»¶ä½ç½®**: `backend/app/forum_routes.py`

**åŸºæœ¬ç»“æ„**:
```python
@router.get("/leaderboard/{type}")
async def get_leaderboard(
    period: str = Query("all", regex="^(all|today|week|month)$"),
    limit: int = Query(10, ge=1, le=50),
    db: AsyncSession = Depends(get_async_db_dependency),
):
    # 1. è®¾ç½®æ—¶é—´èŒƒå›´
    # 2. æ„å»ºæŸ¥è¯¢ï¼ˆèšåˆã€åˆ†ç»„ã€æ’åºï¼‰
    # 3. è·å–ç”¨æˆ·ä¿¡æ¯
    # 4. è¿”å›æ ¼å¼åŒ–æ•°æ®
```

### å‰ç«¯æ¶æ„

**æ–‡ä»¶ä½ç½®**: `frontend/src/pages/ForumLeaderboard.tsx`

**å…³é”®ç»„ä»¶**:
- Tabåˆ‡æ¢ä¸åŒæ’è¡Œæ¦œç±»å‹
- æ—¶é—´å‘¨æœŸé€‰æ‹©å™¨
- å‰ä¸‰åé¢†å¥–å°å±•ç¤º
- å…¶ä½™ç”¨æˆ·åˆ—è¡¨å±•ç¤º

---

## æ‰©å±•æ’è¡Œæ¦œç±»å‹

### 1. ä»»åŠ¡ç›¸å…³æ’è¡Œæ¦œ

#### 1.1 è¾¾äººå¥½è¯„æ¦œï¼ˆExpert Rating Leaderboardï¼‰

**æè¿°**: åŸºäºç”¨æˆ·æ”¶åˆ°çš„è¯„ä»·å¹³å‡åˆ†å’Œè¯„ä»·æ•°é‡ï¼Œå±•ç¤ºæœ€å—å¥½è¯„çš„ä»»åŠ¡è¾¾äººã€‚

**æ’åºè§„åˆ™**:
- ä¸»è¦æŒ‡æ ‡ï¼šå¹³å‡è¯„åˆ†ï¼ˆavg_ratingï¼‰
- æ¬¡è¦æŒ‡æ ‡ï¼šè¯„ä»·æ•°é‡ï¼ˆreview_countï¼‰
- è®¡ç®—å…¬å¼ï¼š`score = avg_rating * (1 + log(review_count + 1))`

**æ•°æ®æ¥æº**:
- `reviews` è¡¨ï¼šç”¨æˆ·æ”¶åˆ°çš„è¯„ä»·
- `users` è¡¨ï¼šç”¨æˆ·åŸºæœ¬ä¿¡æ¯
- `task_experts` è¡¨ï¼šä»»åŠ¡è¾¾äººä¿¡æ¯ï¼ˆå¯é€‰ç­›é€‰ï¼‰

**APIç«¯ç‚¹**: `/api/tasks/leaderboard/expert-rating`

**è¿”å›å­—æ®µ**:
```json
{
  "period": "all",
  "users": [
    {
      "user": {
        "id": "string",
        "name": "string",
        "avatar": "string"
      },
      "avg_rating": 4.8,
      "review_count": 150,
      "score": 4.85
    }
  ]
}
```

#### 1.2 ä»»åŠ¡æˆåŠŸç‡æ¦œï¼ˆTask Success Rate Leaderboardï¼‰

**æè¿°**: åŸºäºç”¨æˆ·å®Œæˆä»»åŠ¡çš„æˆåŠŸç‡ï¼Œå±•ç¤ºæœ€å¯é çš„ä»»åŠ¡æ‰§è¡Œè€…ã€‚

**æ’åºè§„åˆ™**:
- æˆåŠŸç‡ = å·²å®Œæˆä»»åŠ¡æ•° / (å·²å®Œæˆä»»åŠ¡æ•° + è¢«å–æ¶ˆä»»åŠ¡æ•°)
- æœ€ä½ä»»åŠ¡æ•°è¦æ±‚ï¼šè‡³å°‘å®Œæˆ5ä¸ªä»»åŠ¡æ‰å‚ä¸æ’å
- è®¡ç®—å…¬å¼ï¼š`score = success_rate * (1 + log(completed_count + 1))`

**æ•°æ®æ¥æº**:
- `tasks` è¡¨ï¼šä»»åŠ¡çŠ¶æ€ï¼ˆ`status = 'completed'` æˆ– `status = 'cancelled'`ï¼‰
- `users` è¡¨ï¼šç”¨æˆ·åŸºæœ¬ä¿¡æ¯

**APIç«¯ç‚¹**: `/api/tasks/leaderboard/success-rate`

**è¿”å›å­—æ®µ**:
```json
{
  "period": "all",
  "users": [
    {
      "user": {
        "id": "string",
        "name": "string",
        "avatar": "string"
      },
      "success_rate": 0.95,
      "completed_count": 100,
      "cancelled_count": 5,
      "score": 0.97
    }
  ]
}
```

#### 1.3 ä»»åŠ¡å®Œæˆæ•°æ¦œï¼ˆTask Completion Leaderboardï¼‰

**æè¿°**: æŒ‰å®Œæˆä»»åŠ¡æ€»æ•°æ’åºï¼Œå±•ç¤ºæœ€æ´»è·ƒçš„ä»»åŠ¡æ‰§è¡Œè€…ã€‚

**æ’åºè§„åˆ™**:
- æŒ‰ `status = 'completed'` çš„ä»»åŠ¡æ•°é‡é™åºæ’åˆ—
- æ”¯æŒæ—¶é—´å‘¨æœŸç­›é€‰

**APIç«¯ç‚¹**: `/api/tasks/leaderboard/completions`

#### 1.4 ä»»åŠ¡å‘å¸ƒæ•°æ¦œï¼ˆTask Posting Leaderboardï¼‰

**æè¿°**: æŒ‰å‘å¸ƒä»»åŠ¡æ€»æ•°æ’åºï¼Œå±•ç¤ºæœ€æ´»è·ƒçš„ä»»åŠ¡å‘å¸ƒè€…ã€‚

**æ’åºè§„åˆ™**:
- æŒ‰ `poster_id` åˆ†ç»„ç»Ÿè®¡ä»»åŠ¡æ•°é‡
- æ”¯æŒæ—¶é—´å‘¨æœŸç­›é€‰

**APIç«¯ç‚¹**: `/api/tasks/leaderboard/postings`

### 2. å•†å®¶åˆ†ç±»æ’è¡Œæ¦œ

#### 2.1 è¶…å¸‚æ’è¡Œæ¦œï¼ˆSupermarket Leaderboardï¼‰

**æè¿°**: é’ˆå¯¹ `task_type = 'supermarket'` çš„ä»»åŠ¡ï¼Œå±•ç¤ºæœ€å—æ¬¢è¿çš„è¶…å¸‚ç›¸å…³æœåŠ¡æä¾›è€…ã€‚

**æ’åºè§„åˆ™**:
- ç­›é€‰æ¡ä»¶ï¼š`task_type = 'supermarket'`
- ç»¼åˆè¯„åˆ†ï¼šå®Œæˆæ•° Ã— 0.4 + å¥½è¯„ç‡ Ã— 0.3 + å¹³å‡è¯„åˆ† Ã— 0.3

**APIç«¯ç‚¹**: `/api/tasks/leaderboard/by-type/supermarket`

#### 2.2 é¤å…æ’è¡Œæ¦œï¼ˆRestaurant Leaderboardï¼‰

**æè¿°**: é’ˆå¯¹ `task_type = 'restaurant'` çš„ä»»åŠ¡ï¼Œå±•ç¤ºæœ€å—æ¬¢è¿çš„é¤å…ç›¸å…³æœåŠ¡æä¾›è€…ã€‚

**æ’åºè§„åˆ™**:
- ç­›é€‰æ¡ä»¶ï¼š`task_type = 'restaurant'`
- ç»¼åˆè¯„åˆ†ï¼šå®Œæˆæ•° Ã— 0.4 + å¥½è¯„ç‡ Ã— 0.3 + å¹³å‡è¯„åˆ† Ã— 0.3

**APIç«¯ç‚¹**: `/api/tasks/leaderboard/by-type/restaurant`

#### 2.3 é€šç”¨åˆ†ç±»æ’è¡Œæ¦œ

**æ”¯æŒçš„ä»»åŠ¡ç±»å‹**:
- `supermarket` - è¶…å¸‚
- `restaurant` - é¤å…
- `delivery` - é…é€
- `shopping` - è´­ç‰©
- `cleaning` - æ¸…æ´
- `tutoring` - è¾…å¯¼
- `translation` - ç¿»è¯‘
- å…¶ä»–è‡ªå®šä¹‰ç±»å‹

**APIç«¯ç‚¹**: `/api/tasks/leaderboard/by-type/{task_type}`

**å‚æ•°**:
- `task_type`: ä»»åŠ¡ç±»å‹ï¼ˆå¿…å¡«ï¼‰
- `period`: æ—¶é—´å‘¨æœŸï¼ˆå¯é€‰ï¼‰
- `limit`: è¿”å›æ•°é‡ï¼ˆå¯é€‰ï¼Œé»˜è®¤10ï¼‰

### 3. ç»¼åˆæ’è¡Œæ¦œ

#### 3.1 ç»¼åˆå®åŠ›æ¦œï¼ˆOverall Performance Leaderboardï¼‰

**æè¿°**: ç»¼åˆå¤šä¸ªç»´åº¦ï¼ˆä»»åŠ¡å®Œæˆæ•°ã€å¥½è¯„ç‡ã€æ”¶å…¥ã€è®ºå›æ´»è·ƒåº¦ç­‰ï¼‰çš„ç»¼åˆæ’åã€‚

**è¯„åˆ†å…¬å¼**:
```
ç»¼åˆå¾—åˆ† = 
  ä»»åŠ¡å®Œæˆæ•°å¾—åˆ† Ã— 0.3 +
  å¥½è¯„ç‡å¾—åˆ† Ã— 0.25 +
  ä»»åŠ¡æ”¶å…¥å¾—åˆ† Ã— 0.2 +
  è®ºå›æ´»è·ƒåº¦å¾—åˆ† Ã— 0.15 +
  ä»»åŠ¡æˆåŠŸç‡å¾—åˆ† Ã— 0.1
```

**APIç«¯ç‚¹**: `/api/leaderboard/overall`

---

## åç«¯å®ç°æŒ‡å—

### æ­¥éª¤1: åˆ›å»ºæ–°çš„APIç«¯ç‚¹

åœ¨ `backend/app/routers.py` æˆ–åˆ›å»ºæ–°æ–‡ä»¶ `backend/app/task_leaderboard_routes.py`ï¼š

```python
from fastapi import APIRouter, Depends, Query, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func, and_, or_
from datetime import datetime, timedelta, timezone
from typing import Optional
from app.database import get_async_db_dependency
from app import models, schemas

router = APIRouter(prefix="/api/tasks/leaderboard", tags=["Task Leaderboard"])

@router.get("/expert-rating")
async def get_expert_rating_leaderboard(
    period: str = Query("all", regex="^(all|today|week|month)$"),
    limit: int = Query(10, ge=1, le=50),
    min_reviews: int = Query(5, ge=1, description="æœ€ä½è¯„ä»·æ•°é‡è¦æ±‚"),
    db: AsyncSession = Depends(get_async_db_dependency),
):
    """è·å–è¾¾äººå¥½è¯„æ¦œ"""
    now = datetime.now(timezone.utc)
    
    # è®¾ç½®æ—¶é—´èŒƒå›´
    if period == "today":
        start_time = datetime(now.year, now.month, now.day, tzinfo=timezone.utc)
    elif period == "week":
        start_time = now - timedelta(days=7)
    elif period == "month":
        start_time = now - timedelta(days=30)
    else:
        start_time = None
    
    # æ„å»ºæŸ¥è¯¢ï¼šç»Ÿè®¡æ¯ä¸ªç”¨æˆ·çš„å¹³å‡è¯„åˆ†å’Œè¯„ä»·æ•°é‡
    query = select(
        models.Review.user_id,
        func.avg(models.Review.rating).label("avg_rating"),
        func.count(models.Review.id).label("review_count")
    ).where(
        models.Review.user_id.isnot(None)
    )
    
    if start_time:
        query = query.where(models.Review.created_at >= start_time)
    
    query = query.group_by(models.Review.user_id).having(
        func.count(models.Review.id) >= min_reviews
    )
    
    result = await db.execute(query)
    review_stats = result.all()
    
    # è®¡ç®—ç»¼åˆå¾—åˆ†å¹¶æ’åº
    user_scores = []
    for user_id, avg_rating, review_count in review_stats:
        import math
        score = float(avg_rating) * (1 + math.log(review_count + 1))
        user_scores.append((user_id, float(avg_rating), review_count, score))
    
    # æŒ‰å¾—åˆ†æ’åº
    user_scores.sort(key=lambda x: x[3], reverse=True)
    user_scores = user_scores[:limit]
    
    # è·å–ç”¨æˆ·ä¿¡æ¯
    user_list = []
    for rank, (user_id, avg_rating, review_count, score) in enumerate(user_scores, 1):
        user_result = await db.execute(
            select(models.User).where(models.User.id == user_id)
        )
        user = user_result.scalar_one_or_none()
        if user:
            user_list.append({
                "user": schemas.UserInfo(
                    id=user.id,
                    name=user.name,
                    avatar=user.avatar or None
                ),
                "avg_rating": round(avg_rating, 2),
                "review_count": review_count,
                "score": round(score, 2),
                "rank": rank
            })
    
    return {
        "period": period,
        "users": user_list
    }

@router.get("/success-rate")
async def get_success_rate_leaderboard(
    period: str = Query("all", regex="^(all|today|week|month)$"),
    limit: int = Query(10, ge=1, le=50),
    min_tasks: int = Query(5, ge=1, description="æœ€ä½ä»»åŠ¡æ•°è¦æ±‚"),
    db: AsyncSession = Depends(get_async_db_dependency),
):
    """è·å–ä»»åŠ¡æˆåŠŸç‡æ¦œ"""
    now = datetime.now(timezone.utc)
    
    # è®¾ç½®æ—¶é—´èŒƒå›´
    if period == "today":
        start_time = datetime(now.year, now.month, now.day, tzinfo=timezone.utc)
    elif period == "week":
        start_time = now - timedelta(days=7)
    elif period == "month":
        start_time = now - timedelta(days=30)
    else:
        start_time = None
    
    # ç»Ÿè®¡å·²å®Œæˆä»»åŠ¡
    completed_query = select(
        models.Task.taker_id,
        func.count(models.Task.id).label("completed_count")
    ).where(
        and_(
            models.Task.taker_id.isnot(None),
            models.Task.status == "completed"
        )
    )
    
    if start_time:
        completed_query = completed_query.where(models.Task.completed_at >= start_time)
    
    completed_query = completed_query.group_by(models.Task.taker_id)
    completed_result = await db.execute(completed_query)
    completed_data = {row[0]: row[1] for row in completed_result.all()}
    
    # ç»Ÿè®¡è¢«å–æ¶ˆä»»åŠ¡
    cancelled_query = select(
        models.Task.taker_id,
        func.count(models.Task.id).label("cancelled_count")
    ).where(
        and_(
            models.Task.taker_id.isnot(None),
            models.Task.status == "cancelled"
        )
    )
    
    if start_time:
        cancelled_query = cancelled_query.where(models.Task.updated_at >= start_time)
    
    cancelled_query = cancelled_query.group_by(models.Task.taker_id)
    cancelled_result = await db.execute(cancelled_query)
    cancelled_data = {row[0]: row[1] for row in cancelled_result.all()}
    
    # è®¡ç®—æˆåŠŸç‡
    user_stats = []
    all_user_ids = set(completed_data.keys()) | set(cancelled_data.keys())
    
    for user_id in all_user_ids:
        completed = completed_data.get(user_id, 0)
        cancelled = cancelled_data.get(user_id, 0)
        total = completed + cancelled
        
        if total >= min_tasks:
            success_rate = completed / total if total > 0 else 0
            import math
            score = success_rate * (1 + math.log(completed + 1))
            user_stats.append((user_id, success_rate, completed, cancelled, score))
    
    # æŒ‰å¾—åˆ†æ’åº
    user_stats.sort(key=lambda x: x[4], reverse=True)
    user_stats = user_stats[:limit]
    
    # è·å–ç”¨æˆ·ä¿¡æ¯
    user_list = []
    for rank, (user_id, success_rate, completed, cancelled, score) in enumerate(user_stats, 1):
        user_result = await db.execute(
            select(models.User).where(models.User.id == user_id)
        )
        user = user_result.scalar_one_or_none()
        if user:
            user_list.append({
                "user": schemas.UserInfo(
                    id=user.id,
                    name=user.name,
                    avatar=user.avatar or None
                ),
                "success_rate": round(success_rate, 4),
                "completed_count": completed,
                "cancelled_count": cancelled,
                "score": round(score, 4),
                "rank": rank
            })
    
    return {
        "period": period,
        "users": user_list
    }

@router.get("/by-type/{task_type}")
async def get_task_type_leaderboard(
    task_type: str,
    period: str = Query("all", regex="^(all|today|week|month)$"),
    limit: int = Query(10, ge=1, le=50),
    db: AsyncSession = Depends(get_async_db_dependency),
):
    """è·å–æŒ‡å®šä»»åŠ¡ç±»å‹çš„æ’è¡Œæ¦œ"""
    now = datetime.now(timezone.utc)
    
    # è®¾ç½®æ—¶é—´èŒƒå›´
    if period == "today":
        start_time = datetime(now.year, now.month, now.day, tzinfo=timezone.utc)
    elif period == "week":
        start_time = now - timedelta(days=7)
    elif period == "month":
        start_time = now - timedelta(days=30)
    else:
        start_time = None
    
    # ç»Ÿè®¡æ¯ä¸ªç”¨æˆ·åœ¨è¯¥ä»»åŠ¡ç±»å‹ä¸‹çš„è¡¨ç°
    # 1. å®Œæˆä»»åŠ¡æ•°
    completed_query = select(
        models.Task.taker_id,
        func.count(models.Task.id).label("completed_count")
    ).where(
        and_(
            models.Task.task_type == task_type,
            models.Task.taker_id.isnot(None),
            models.Task.status == "completed"
        )
    )
    
    if start_time:
        completed_query = completed_query.where(models.Task.completed_at >= start_time)
    
    completed_query = completed_query.group_by(models.Task.taker_id)
    completed_result = await db.execute(completed_query)
    completed_data = {row[0]: row[1] for row in completed_result.all()}
    
    # 2. å¹³å‡è¯„åˆ†ï¼ˆä»reviewsè¡¨å…³è”ï¼‰
    rating_query = select(
        models.Task.taker_id,
        func.avg(models.Review.rating).label("avg_rating"),
        func.count(models.Review.id).label("review_count")
    ).join(
        models.Review, models.Review.task_id == models.Task.id
    ).where(
        and_(
            models.Task.task_type == task_type,
            models.Task.taker_id.isnot(None),
            models.Task.status == "completed"
        )
    )
    
    if start_time:
        rating_query = rating_query.where(models.Task.completed_at >= start_time)
    
    rating_query = rating_query.group_by(models.Task.taker_id)
    rating_result = await db.execute(rating_query)
    rating_data = {}
    for row in rating_result.all():
        rating_data[row[0]] = {
            "avg_rating": float(row[1]) if row[1] else 0,
            "review_count": row[2]
        }
    
    # è®¡ç®—ç»¼åˆå¾—åˆ†
    user_scores = []
    all_user_ids = set(completed_data.keys()) | set(rating_data.keys())
    
    for user_id in all_user_ids:
        completed = completed_data.get(user_id, 0)
        rating_info = rating_data.get(user_id, {"avg_rating": 0, "review_count": 0})
        avg_rating = rating_info["avg_rating"]
        review_count = rating_info["review_count"]
        
        # ç»¼åˆè¯„åˆ†å…¬å¼
        import math
        completion_score = completed * 0.4
        rating_score = avg_rating * 0.3
        review_score = (review_count / max(completed, 1)) * 0.3
        
        total_score = completion_score + rating_score + review_score
        user_scores.append((user_id, completed, avg_rating, review_count, total_score))
    
    # æŒ‰å¾—åˆ†æ’åº
    user_scores.sort(key=lambda x: x[4], reverse=True)
    user_scores = user_scores[:limit]
    
    # è·å–ç”¨æˆ·ä¿¡æ¯
    user_list = []
    for rank, (user_id, completed, avg_rating, review_count, score) in enumerate(user_scores, 1):
        user_result = await db.execute(
            select(models.User).where(models.User.id == user_id)
        )
        user = user_result.scalar_one_or_none()
        if user:
            user_list.append({
                "user": schemas.UserInfo(
                    id=user.id,
                    name=user.name,
                    avatar=user.avatar or None
                ),
                "completed_count": completed,
                "avg_rating": round(avg_rating, 2) if avg_rating > 0 else None,
                "review_count": review_count,
                "score": round(score, 2),
                "rank": rank
            })
    
    return {
        "period": period,
        "task_type": task_type,
        "users": user_list
    }
```

### æ­¥éª¤2: æ³¨å†Œè·¯ç”±

åœ¨ `backend/app/main.py` æˆ–ç›¸åº”çš„è·¯ç”±æ³¨å†Œæ–‡ä»¶ä¸­ï¼š

```python
from app.task_leaderboard_routes import router as task_leaderboard_router

app.include_router(task_leaderboard_router)
```

### æ­¥éª¤3: æ·»åŠ æ•°æ®æ¨¡å‹ï¼ˆå¦‚éœ€è¦ï¼‰

å¦‚æœéœ€è¦åœ¨æ•°æ®åº“ä¸­ç¼“å­˜æ’è¡Œæ¦œæ•°æ®ï¼Œå¯ä»¥åˆ›å»ºç¼“å­˜è¡¨ï¼š

```python
class LeaderboardCache(Base):
    __tablename__ = "leaderboard_cache"
    
    id = Column(Integer, primary_key=True)
    leaderboard_type = Column(String(50), nullable=False, index=True)
    period = Column(String(20), nullable=False)
    user_id = Column(String(8), ForeignKey("users.id"), nullable=False)
    rank = Column(Integer, nullable=False)
    score = Column(Float, nullable=True)
    metadata = Column(JSON, nullable=True)  # å­˜å‚¨é¢å¤–ä¿¡æ¯
    cached_at = Column(DateTime(timezone=True), default=datetime.utcnow)
    
    __table_args__ = (
        Index('idx_leaderboard_type_period', 'leaderboard_type', 'period'),
    )
```

---

## å‰ç«¯å®ç°æŒ‡å—

### æ­¥éª¤1: æ·»åŠ APIè°ƒç”¨å‡½æ•°

åœ¨ `frontend/src/api.ts` ä¸­æ·»åŠ ï¼š

```typescript
// ä»»åŠ¡æ’è¡Œæ¦œAPI
export const getTaskLeaderboard = async (
  type: 'expert-rating' | 'success-rate' | 'completions' | 'postings',
  params?: {
    period?: 'all' | 'today' | 'week' | 'month';
    limit?: number;
    min_reviews?: number;
    min_tasks?: number;
  }
) => {
  const res = await api.get(`/api/tasks/leaderboard/${type}`, { params });
  return res.data;
};

// ä»»åŠ¡ç±»å‹æ’è¡Œæ¦œ
export const getTaskTypeLeaderboard = async (
  taskType: string,
  params?: {
    period?: 'all' | 'today' | 'week' | 'month';
    limit?: number;
  }
) => {
  const res = await api.get(`/api/tasks/leaderboard/by-type/${taskType}`, { params });
  return res.data;
};
```

### æ­¥éª¤2: åˆ›å»ºæ’è¡Œæ¦œé¡µé¢ç»„ä»¶

åˆ›å»º `frontend/src/pages/TaskLeaderboard.tsx`ï¼š

```typescript
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { Card, Tabs, Spin, Empty, Select, Avatar, Space } from 'antd';
import { TrophyOutlined, UserOutlined, StarOutlined } from '@ant-design/icons';
import { useLanguage } from '../contexts/LanguageContext';
import { useLocalizedNavigation } from '../hooks/useLocalizedNavigation';
import { getTaskLeaderboard, getTaskTypeLeaderboard } from '../api';
import styles from './TaskLeaderboard.module.css';

const { TabPane } = Tabs;
const { Option } = Select;

interface LeaderboardUser {
  user: {
    id: string;
    name: string;
    avatar?: string;
  };
  rank: number;
  // æ ¹æ®æ’è¡Œæ¦œç±»å‹ï¼Œå¯èƒ½æœ‰ä¸åŒçš„å­—æ®µ
  avg_rating?: number;
  review_count?: number;
  success_rate?: number;
  completed_count?: number;
  cancelled_count?: number;
  total_earnings?: number;
  task_count?: number;
  score?: number;
}

const TaskLeaderboard: React.FC = () => {
  const { t, language } = useLanguage();
  const { navigate } = useLocalizedNavigation();
  const { lang: langParam } = useParams<{ lang: string }>();
  const lang = langParam || language || 'zh';
  
  const [activeTab, setActiveTab] = useState<'expert-rating' | 'success-rate' | 'completions' | 'postings'>('expert-rating');
  const [period, setPeriod] = useState<'all' | 'today' | 'week' | 'month'>('all');
  const [users, setUsers] = useState<LeaderboardUser[]>([]);
  const [loading, setLoading] = useState(false);
  
  useEffect(() => {
    loadLeaderboard();
  }, [activeTab, period]);
  
  const loadLeaderboard = async () => {
    try {
      setLoading(true);
      const response = await getTaskLeaderboard(activeTab, {
        period,
        limit: 50
      });
      setUsers(response.users || []);
    } catch (error: any) {
      console.error('åŠ è½½æ’è¡Œæ¦œå¤±è´¥:', error);
    } finally {
      setLoading(false);
    }
  };
  
  const getRankIcon = (rank: number) => {
    if (rank === 1) return 'ğŸ¥‡';
    if (rank === 2) return 'ğŸ¥ˆ';
    if (rank === 3) return 'ğŸ¥‰';
    return rank;
  };
  
  const getDisplayValue = (user: LeaderboardUser) => {
    switch (activeTab) {
      case 'expert-rating':
        return `${user.avg_rating?.toFixed(1)} â­ (${user.review_count} è¯„ä»·)`;
      case 'success-rate':
        return `${(user.success_rate! * 100).toFixed(1)}% (${user.completed_count}/${user.completed_count! + user.cancelled_count!})`;
      case 'completions':
        return `${user.completed_count} ä¸ªä»»åŠ¡`;
      case 'postings':
        return `${user.task_count} ä¸ªä»»åŠ¡`;
      default:
        return '';
    }
  };
  
  const renderLeaderboardContent = () => {
    if (loading) {
      return <Spin size="large" />;
    }
    
    if (users.length === 0) {
      return <Empty description="æš‚æ— æ•°æ®" />;
    }
    
    const topThree = users.slice(0, 3);
    const restUsers = users.slice(3);
    
    return (
      <>
        {/* å‰ä¸‰åé¢†å¥–å° */}
        {topThree.length > 0 && (
          <div className={styles.podiumContainer}>
            {topThree.map((item, index) => (
              <div
                key={item.user.id}
                className={`${styles.podiumItem} ${styles[`podium${index + 1}`]}`}
                onClick={() => navigate(`/${lang}/user/${item.user.id}`)}
              >
                <Avatar
                  src={item.user.avatar}
                  icon={<UserOutlined />}
                  size={index === 0 ? 100 : 80}
                />
                <div className={styles.podiumName}>{item.user.name}</div>
                <div className={styles.podiumCount}>{getDisplayValue(item)}</div>
                <div className={styles.podiumBase}>
                  <span>{getRankIcon(item.rank)}</span>
                </div>
              </div>
            ))}
          </div>
        )}
        
        {/* å…¶ä½™ç”¨æˆ·åˆ—è¡¨ */}
        {restUsers.length > 0 && (
          <div className={styles.listAfterPodium}>
            {restUsers.map((item) => (
              <div
                key={item.user.id}
                className={styles.listItem}
                onClick={() => navigate(`/${lang}/user/${item.user.id}`)}
              >
                <div className={styles.listRank}>{item.rank}</div>
                <Avatar
                  src={item.user.avatar}
                  icon={<UserOutlined />}
                  size={40}
                />
                <div className={styles.listInfo}>
                  <div className={styles.listName}>{item.user.name}</div>
                </div>
                <div className={styles.listCount}>{getDisplayValue(item)}</div>
              </div>
            ))}
          </div>
        )}
      </>
    );
  };
  
  return (
    <div className={styles.container}>
      <Card>
        <div className={styles.toolbar}>
          <Select
            value={period}
            onChange={setPeriod}
            style={{ width: 150 }}
          >
            <Option value="all">å…¨éƒ¨æ—¶é—´</Option>
            <Option value="today">ä»Šå¤©</Option>
            <Option value="week">æœ¬å‘¨</Option>
            <Option value="month">æœ¬æœˆ</Option>
          </Select>
        </div>
        
        <Tabs activeKey={activeTab} onChange={(key) => setActiveTab(key as any)}>
          <TabPane tab="è¾¾äººå¥½è¯„æ¦œ" key="expert-rating">
            {renderLeaderboardContent()}
          </TabPane>
          <TabPane tab="ä»»åŠ¡æˆåŠŸç‡æ¦œ" key="success-rate">
            {renderLeaderboardContent()}
          </TabPane>
          <TabPane tab="ä»»åŠ¡å®Œæˆæ•°æ¦œ" key="completions">
            {renderLeaderboardContent()}
          </TabPane>
          <TabPane tab="ä»»åŠ¡å‘å¸ƒæ•°æ¦œ" key="postings">
            {renderLeaderboardContent()}
          </TabPane>
        </Tabs>
      </Card>
    </div>
  );
};

export default TaskLeaderboard;
```

### æ­¥éª¤3: åˆ›å»ºä»»åŠ¡ç±»å‹æ’è¡Œæ¦œé¡µé¢

åˆ›å»º `frontend/src/pages/TaskTypeLeaderboard.tsx`ï¼š

```typescript
import React, { useState, useEffect } from 'react';
import { useParams } from 'react-router-dom';
import { Card, Select, Spin, Empty } from 'antd';
import { useLanguage } from '../contexts/LanguageContext';
import { getTaskTypeLeaderboard } from '../api';

const { Option } = Select;

const TASK_TYPES = [
  { value: 'supermarket', label: 'è¶…å¸‚' },
  { value: 'restaurant', label: 'é¤å…' },
  { value: 'delivery', label: 'é…é€' },
  { value: 'shopping', label: 'è´­ç‰©' },
  { value: 'cleaning', label: 'æ¸…æ´' },
  { value: 'tutoring', label: 'è¾…å¯¼' },
  { value: 'translation', label: 'ç¿»è¯‘' },
];

const TaskTypeLeaderboard: React.FC = () => {
  const { t, language } = useLanguage();
  const { taskType: urlTaskType } = useParams<{ taskType: string }>();
  
  const [selectedTaskType, setSelectedTaskType] = useState(urlTaskType || 'supermarket');
  const [period, setPeriod] = useState<'all' | 'today' | 'week' | 'month'>('all');
  const [users, setUsers] = useState<any[]>([]);
  const [loading, setLoading] = useState(false);
  
  useEffect(() => {
    loadLeaderboard();
  }, [selectedTaskType, period]);
  
  const loadLeaderboard = async () => {
    try {
      setLoading(true);
      const response = await getTaskTypeLeaderboard(selectedTaskType, {
        period,
        limit: 50
      });
      setUsers(response.users || []);
    } catch (error: any) {
      console.error('åŠ è½½æ’è¡Œæ¦œå¤±è´¥:', error);
    } finally {
      setLoading(false);
    }
  };
  
  // ... æ¸²æŸ“é€»è¾‘ç±»ä¼¼ä¸Šé¢çš„ç»„ä»¶
};
```

### æ­¥éª¤4: æ·»åŠ è·¯ç”±

åœ¨ `frontend/src/App.tsx` ä¸­æ·»åŠ ï¼š

```typescript
import TaskLeaderboard from './pages/TaskLeaderboard';
import TaskTypeLeaderboard from './pages/TaskTypeLeaderboard';

// åœ¨è·¯ç”±é…ç½®ä¸­æ·»åŠ 
<Route path={`/${lang}/leaderboard/tasks`} element={<TaskLeaderboard />} />
<Route path={`/${lang}/leaderboard/tasks/:taskType`} element={<TaskTypeLeaderboard />} />
```

---

## æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–

### 1. ç´¢å¼•ä¼˜åŒ–

ä¸ºå¸¸ç”¨æŸ¥è¯¢å­—æ®µæ·»åŠ ç´¢å¼•ï¼š

```sql
-- ä»»åŠ¡è¡¨ç´¢å¼•
CREATE INDEX idx_task_taker_status ON tasks(taker_id, status);
CREATE INDEX idx_task_poster_created ON tasks(poster_id, created_at);
CREATE INDEX idx_task_type_status ON tasks(task_type, status);
CREATE INDEX idx_task_completed_at ON tasks(completed_at) WHERE status = 'completed';

-- è¯„ä»·è¡¨ç´¢å¼•
CREATE INDEX idx_review_user_rating ON reviews(user_id, rating);
CREATE INDEX idx_review_created ON reviews(created_at);

-- å¤åˆç´¢å¼•ç”¨äºæ’è¡Œæ¦œæŸ¥è¯¢
CREATE INDEX idx_task_leaderboard ON tasks(taker_id, task_type, status, completed_at);
```

### 2. ç¼“å­˜ç­–ç•¥

**Redisç¼“å­˜æ–¹æ¡ˆ**:

```python
import redis
import json
from datetime import timedelta

redis_client = redis.Redis(host='localhost', port=6379, db=0)

async def get_cached_leaderboard(leaderboard_type: str, period: str):
    cache_key = f"leaderboard:{leaderboard_type}:{period}"
    cached_data = redis_client.get(cache_key)
    
    if cached_data:
        return json.loads(cached_data)
    return None

async def cache_leaderboard(leaderboard_type: str, period: str, data: dict, ttl: int = 300):
    cache_key = f"leaderboard:{leaderboard_type}:{period}"
    redis_client.setex(
        cache_key,
        ttl,
        json.dumps(data)
    )
```

**ä½¿ç”¨ç¤ºä¾‹**:

```python
@router.get("/expert-rating")
async def get_expert_rating_leaderboard(...):
    # å°è¯•ä»ç¼“å­˜è·å–
    cached = await get_cached_leaderboard("expert-rating", period)
    if cached:
        return cached
    
    # è®¡ç®—æ’è¡Œæ¦œ
    result = await calculate_leaderboard(...)
    
    # ç¼“å­˜ç»“æœï¼ˆ5åˆ†é’Ÿï¼‰
    await cache_leaderboard("expert-rating", period, result, ttl=300)
    
    return result
```

### 3. ç‰©åŒ–è§†å›¾ï¼ˆPostgreSQLï¼‰

å¯¹äºå¤æ‚çš„æ’è¡Œæ¦œæŸ¥è¯¢ï¼Œå¯ä»¥è€ƒè™‘ä½¿ç”¨ç‰©åŒ–è§†å›¾ï¼š

```sql
CREATE MATERIALIZED VIEW mv_user_task_stats AS
SELECT
    u.id as user_id,
    COUNT(CASE WHEN t.status = 'completed' THEN 1 END) as completed_count,
    COUNT(CASE WHEN t.status = 'cancelled' THEN 1 END) as cancelled_count,
    AVG(r.rating) as avg_rating,
    COUNT(r.id) as review_count
FROM users u
LEFT JOIN tasks t ON t.taker_id = u.id
LEFT JOIN reviews r ON r.user_id = u.id
GROUP BY u.id;

CREATE UNIQUE INDEX ON mv_user_task_stats(user_id);

-- å®šæœŸåˆ·æ–°
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_user_task_stats;
```

---

## APIè®¾è®¡è§„èŒƒ

### ç»Ÿä¸€å“åº”æ ¼å¼

æ‰€æœ‰æ’è¡Œæ¦œAPIåº”éµå¾ªä»¥ä¸‹å“åº”æ ¼å¼ï¼š

```json
{
  "period": "all",
  "leaderboard_type": "expert-rating",
  "users": [
    {
      "user": {
        "id": "string",
        "name": "string",
        "avatar": "string | null"
      },
      "rank": 1,
      "score": 4.85,
      "metadata": {
        // æ’è¡Œæ¦œç‰¹å®šçš„é¢å¤–æ•°æ®
        "avg_rating": 4.8,
        "review_count": 150
      }
    }
  ],
  "total": 50,
  "limit": 10,
  "cached": false,
  "cache_expires_at": "2024-01-01T12:00:00Z"
}
```

### é”™è¯¯å¤„ç†

```json
{
  "error": {
    "code": "LEADERBOARD_ERROR",
    "message": "æ— æ³•è®¡ç®—æ’è¡Œæ¦œ",
    "details": {
      "leaderboard_type": "expert-rating",
      "period": "all"
    }
  }
}
```

### åˆ†é¡µæ”¯æŒï¼ˆå¯é€‰ï¼‰

å¯¹äºå¤§å‹æ’è¡Œæ¦œï¼Œå¯ä»¥æ·»åŠ åˆ†é¡µï¼š

```python
@router.get("/expert-rating")
async def get_expert_rating_leaderboard(
    period: str = Query("all"),
    limit: int = Query(10, ge=1, le=100),
    offset: int = Query(0, ge=0),
    db: AsyncSession = Depends(get_async_db_dependency),
):
    # ... æŸ¥è¯¢é€»è¾‘
    
    return {
        "period": period,
        "users": user_list,
        "pagination": {
            "limit": limit,
            "offset": offset,
            "total": total_count,
            "has_more": offset + limit < total_count
        }
    }
```

---

## å®æ–½è®¡åˆ’

### é˜¶æ®µ1: åŸºç¡€ä»»åŠ¡æ’è¡Œæ¦œï¼ˆ2å‘¨ï¼‰

**ä¼˜å…ˆçº§**: é«˜

1. **è¾¾äººå¥½è¯„æ¦œ**
   - åç«¯APIå®ç°
   - å‰ç«¯é¡µé¢é›†æˆ
   - æµ‹è¯•å’Œä¼˜åŒ–

2. **ä»»åŠ¡æˆåŠŸç‡æ¦œ**
   - åç«¯APIå®ç°
   - å‰ç«¯é¡µé¢é›†æˆ
   - æµ‹è¯•å’Œä¼˜åŒ–

3. **ä»»åŠ¡å®Œæˆæ•°æ¦œ**
   - åç«¯APIå®ç°
   - å‰ç«¯é¡µé¢é›†æˆ

### é˜¶æ®µ2: å•†å®¶åˆ†ç±»æ’è¡Œæ¦œï¼ˆ2å‘¨ï¼‰

**ä¼˜å…ˆçº§**: ä¸­

1. **è¶…å¸‚æ’è¡Œæ¦œ**
   - åç«¯APIå®ç°
   - å‰ç«¯é¡µé¢é›†æˆ

2. **é¤å…æ’è¡Œæ¦œ**
   - åç«¯APIå®ç°
   - å‰ç«¯é¡µé¢é›†æˆ

3. **é€šç”¨åˆ†ç±»æ’è¡Œæ¦œæ¡†æ¶**
   - å¯é…ç½®çš„ä»»åŠ¡ç±»å‹æ”¯æŒ
   - åŠ¨æ€è·¯ç”±ç”Ÿæˆ

### é˜¶æ®µ3: é«˜çº§åŠŸèƒ½ï¼ˆ2å‘¨ï¼‰

**ä¼˜å…ˆçº§**: ä½

1. **ç»¼åˆå®åŠ›æ¦œ**
   - å¤šç»´åº¦è¯„åˆ†ç®—æ³•
   - æƒé‡é…ç½®

3. **ç¼“å­˜ä¼˜åŒ–**
   - Redisé›†æˆ
   - ç¼“å­˜ç­–ç•¥å®æ–½

### é˜¶æ®µ4: æ€§èƒ½ä¼˜åŒ–ï¼ˆ1å‘¨ï¼‰

**ä¼˜å…ˆçº§**: ä¸­

1. **æ•°æ®åº“ä¼˜åŒ–**
   - ç´¢å¼•æ·»åŠ 
   - æŸ¥è¯¢ä¼˜åŒ–

2. **å‰ç«¯ä¼˜åŒ–**
   - æ‡’åŠ è½½
   - è™šæ‹Ÿæ»šåŠ¨ï¼ˆå¦‚éœ€è¦ï¼‰

---

## æµ‹è¯•æ¸…å•

### åç«¯æµ‹è¯•

- [ ] å•å…ƒæµ‹è¯•ï¼šå„ä¸ªæ’è¡Œæ¦œè®¡ç®—é€»è¾‘
- [ ] é›†æˆæµ‹è¯•ï¼šAPIç«¯ç‚¹å“åº”
- [ ] æ€§èƒ½æµ‹è¯•ï¼šæŸ¥è¯¢å“åº”æ—¶é—´
- [ ] è¾¹ç•Œæµ‹è¯•ï¼šç©ºæ•°æ®ã€å•ç”¨æˆ·ç­‰æƒ…å†µ

### å‰ç«¯æµ‹è¯•

- [ ] ç»„ä»¶æ¸²æŸ“æµ‹è¯•
- [ ] äº¤äº’æµ‹è¯•ï¼šTabåˆ‡æ¢ã€å‘¨æœŸé€‰æ‹©
- [ ] è·¯ç”±æµ‹è¯•ï¼šç”¨æˆ·è·³è½¬
- [ ] å“åº”å¼æµ‹è¯•ï¼šç§»åŠ¨ç«¯é€‚é…

### æ•°æ®å‡†ç¡®æ€§æµ‹è¯•

- [ ] éªŒè¯æ’è¡Œæ¦œæ•°æ®å‡†ç¡®æ€§
- [ ] éªŒè¯æ—¶é—´å‘¨æœŸç­›é€‰æ­£ç¡®æ€§
- [ ] éªŒè¯æ’åºé€»è¾‘æ­£ç¡®æ€§

---

## æ³¨æ„äº‹é¡¹

1. **æ•°æ®éšç§**: ç¡®ä¿æ’è¡Œæ¦œä¸æ³„éœ²æ•æ„Ÿç”¨æˆ·ä¿¡æ¯
2. **æ€§èƒ½è€ƒè™‘**: å¤§å‹æ’è¡Œæ¦œæŸ¥è¯¢å¯èƒ½è¾ƒæ…¢ï¼Œéœ€è¦ä¼˜åŒ–å’Œç¼“å­˜
3. **å…¬å¹³æ€§**: ç¡®ä¿æ’è¡Œæ¦œç®—æ³•å…¬å¹³ï¼Œé¿å…åˆ·æ¦œè¡Œä¸º
4. **å¯æ‰©å±•æ€§**: è®¾è®¡æ—¶è€ƒè™‘æœªæ¥æ–°å¢æ’è¡Œæ¦œç±»å‹çš„ä¾¿åˆ©æ€§
5. **å›½é™…åŒ–**: æ‰€æœ‰æ–‡æœ¬éœ€è¦æ”¯æŒå¤šè¯­è¨€

---

## å‚è€ƒèµ„æ–™

- ç°æœ‰æ’è¡Œæ¦œå®ç°ï¼š`backend/app/forum_routes.py` (line 3789-3985)
- å‰ç«¯æ’è¡Œæ¦œç»„ä»¶ï¼š`frontend/src/pages/ForumLeaderboard.tsx`
- æ•°æ®åº“æ¨¡å‹ï¼š`backend/app/models.py`
- APIæ–‡æ¡£ï¼šSwagger UI (`/docs`)

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0  
**æœ€åæ›´æ–°**: 2024-01-XX  
**ç»´æŠ¤è€…**: LinkUå¼€å‘å›¢é˜Ÿ

