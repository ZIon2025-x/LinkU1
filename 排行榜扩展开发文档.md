# 排行榜扩展开发文档

## 目录
1. [概述](#概述)
2. [现有排行榜架构](#现有排行榜架构)
3. [用户驱动排行榜系统设计](#用户驱动排行榜系统设计)
4. [数据库设计](#数据库设计)
5. [后端实现指南](#后端实现指南)
6. [前端实现指南](#前端实现指南)
7. [审核流程](#审核流程)
8. [投票系统](#投票系统)
9. [排序算法](#排序算法)
10. [API设计规范](#api设计规范)
11. [实施计划](#实施计划)
12. [API端点完整列表](#api端点完整列表)
13. [性能优化建议](#性能优化建议)
14. [部署注意事项](#部署注意事项)
15. [常见问题解答](#常见问题解答)
16. [开发调试技巧](#开发调试技巧)

---

## 概述

本文档描述了如何扩展LinkU平台的排行榜功能，实现一个**用户驱动的动态排行榜系统**。用户可以申请创建自定义排行榜（如"London中餐榜"），在榜单中新增竞品（如各种中餐厅），并通过投票机制决定排序。

### 核心特性

- **用户申请创建榜单**：用户可以申请创建新的排行榜（如"London中餐榜"、"Manchester超市榜"等）
- **后台审核机制**：管理员审核用户申请的榜单，审核通过后在前端显示
- **地区筛选**：支持按地区（城市）筛选和创建榜单
- **新增竞品**：用户可以在榜单中新增竞品（如餐厅、商店等）
- **投票排序**：用户投票决定榜单排序，支持点赞/点踩机制
- **动态展示**：榜单根据投票结果实时更新排序

### 现有排行榜功能

当前系统已实现以下论坛排行榜：
- **发帖排行榜** (`/api/forum/leaderboard/posts`) - 按发帖数量排序
- **回复排行榜** (`/api/forum/leaderboard/replies`) - 按回复数量排序
- **获赞排行榜** (`/api/forum/leaderboard/likes`) - 按获得点赞数排序
- **其它排行榜** (新增) - 用户驱动的动态排行榜系统

**注意**：时间周期筛选仅适用于论坛排行榜（发帖榜、回复榜、获赞榜）。**其它排行榜（自定义排行榜）不使用时间周期筛选**，始终显示全部数据。

---

## 现有排行榜架构

### 后端架构

**文件位置**: `backend/app/forum_routes.py`

**基本结构**:
```python
@router.get("/leaderboard/{type}")
async def get_leaderboard(
    period: str = Query("all", regex="^(all|today|week|month)$"),
    limit: int = Query(10, ge=1, le=50),
    db: AsyncSession = Depends(get_async_db_dependency),
):
    # 1. 设置时间范围
    # 2. 构建查询（聚合、分组、排序）
    # 3. 获取用户信息
    # 4. 返回格式化数据
```

### 前端架构

**文件位置**: `frontend/src/pages/ForumLeaderboard.tsx`

**关键组件**:
- Tab切换不同排行榜类型
- 时间周期选择器
- 前三名领奖台展示
- 其余用户列表展示

---

## 用户驱动排行榜系统设计

### 系统流程

```
1. 用户申请创建榜单
   ↓
2. 后台管理员审核
   ↓
3. 审核通过，榜单在前端显示
   ↓
4. 用户在榜单中新增竞品
   ↓
5. 其他用户对竞品投票（点赞/点踩）
   ↓
6. 系统根据投票结果实时排序
```

### 功能模块

#### 1. 榜单申请模块
- 用户填写榜单信息（名称、地区、描述等）
- 提交申请，等待审核

#### 2. 榜单审核模块（后台）
- 管理员查看待审核榜单
- 审核通过/拒绝
- 设置榜单状态（活跃/暂停/关闭）

#### 3. 榜单展示模块（前端）
- 显示所有已审核通过的榜单
- 按地区筛选
- **搜索功能**：支持按榜单名称、描述进行关键词搜索，方便用户快速找到感兴趣的榜单

#### 4. 新增竞品模块
- 用户在榜单中新增竞品
- 填写竞品信息（名称、地址、描述、图片等）
- **V1版本：竞品自动通过，无需审核**（未来可扩展为需要审核）

#### 5. 投票模块
- 用户对竞品进行投票（点赞/点踩）
- 显示投票统计
- 防止重复投票：每个用户对每个竞品只能投一票（通过数据库唯一约束实现）
- 支持取消投票：再次点击相同类型的投票按钮可取消
- **防刷票机制**：当前版本仅通过"用户维度唯一 + 登录限制"防刷，IP限制/验证码属于后续增强项

#### 6. 排序模块
- 根据投票结果实时计算排序
- 支持多种排序算法（按点赞数、按净赞数、按热度等）

---

## 数据库设计

### 1. 自定义排行榜表 (custom_leaderboards)

```python
class CustomLeaderboard(Base):
    __tablename__ = "custom_leaderboards"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(100), nullable=False)  # 榜单名称，如"London中餐榜"
    location = Column(String(100), nullable=False)  # 地区，如"London", "Manchester"
    description = Column(Text, nullable=True)  # 榜单描述
    cover_image = Column(String(500), nullable=True)  # 封面图片
    
    # 申请信息
    applicant_id = Column(String(8), ForeignKey("users.id"), nullable=False)  # 申请人ID
    application_reason = Column(Text, nullable=True)  # 申请理由
    
    # 审核信息
    status = Column(String(20), default="pending")  # pending: 待审核, active: 已激活, rejected: 已拒绝
    reviewed_by = Column(String(36), ForeignKey("admin_users.id"), nullable=True)  # 审核人
    reviewed_at = Column(DateTime(timezone=True), nullable=True)  # 审核时间
    review_comment = Column(Text, nullable=True)  # 审核意见
    
    # 统计信息
    item_count = Column(Integer, default=0)  # 竞品数量
    vote_count = Column(Integer, default=0)  # 历史累计投票数（按用户对竞品去重，用于统计参与度）
    view_count = Column(Integer, default=0)  # 浏览量
    
    # 时间戳（使用项目统一的时间函数get_utc_time）
    created_at = Column(DateTime(timezone=True), default=get_utc_time)
    updated_at = Column(DateTime(timezone=True), default=get_utc_time, onupdate=get_utc_time)
    
    # 关系
    applicant = relationship("User", foreign_keys=[applicant_id])
    reviewer = relationship("AdminUser", foreign_keys=[reviewed_by])
    items = relationship("LeaderboardItem", back_populates="leaderboard", cascade="all, delete-orphan")
    
    __table_args__ = (
        UniqueConstraint('name', 'location', name='uq_leaderboard_name_location'),  # 防止同名同地区重复
        Index('idx_leaderboard_status', 'status'),
        Index('idx_leaderboard_location', 'location'),
        Index('idx_leaderboard_vote_count', 'vote_count'),  # ★★★☆☆ 热门榜单排序优化
    )
```

### 2. 排行榜竞品表 (leaderboard_items)

```python
from app.utils.time_utils import get_utc_time

class LeaderboardItem(Base):
    __tablename__ = "leaderboard_items"
    
    id = Column(Integer, primary_key=True, index=True)
    leaderboard_id = Column(Integer, ForeignKey("custom_leaderboards.id"), nullable=False)
    name = Column(String(200), nullable=False)  # 竞品名称，如"海底捞"
    description = Column(Text, nullable=True)  # 竞品描述
    address = Column(String(500), nullable=True)  # 地址
    phone = Column(String(50), nullable=True)  # 电话
    website = Column(String(500), nullable=True)  # 网站
    images = Column(Text, nullable=True)  # 图片（JSON字符串，存储为List[str]的序列化结果）
    
    # 提交信息
    submitted_by = Column(String(8), ForeignKey("users.id"), nullable=False)  # 提交人
    status = Column(String(20), default="approved")  # approved: 已通过（当前版本竞品自动通过，无需审核）
    
    # 投票统计
    upvotes = Column(Integer, default=0)  # 点赞数
    downvotes = Column(Integer, default=0)  # 点踩数
    net_votes = Column(Integer, default=0)  # 净赞数 = upvotes - downvotes
    vote_score = Column(Float, default=0.0)  # 综合得分（用于排序）
    
    # 时间戳（使用项目统一的时间函数get_utc_time）
    created_at = Column(DateTime(timezone=True), default=get_utc_time)
    updated_at = Column(DateTime(timezone=True), default=get_utc_time, onupdate=get_utc_time)
    
    # 关系
    leaderboard = relationship("CustomLeaderboard", back_populates="items")
    submitter = relationship("User", foreign_keys=[submitted_by])
    votes = relationship("LeaderboardVote", back_populates="item", cascade="all, delete-orphan")
    
    __table_args__ = (
        UniqueConstraint('leaderboard_id', 'name', name='uq_item_leaderboard_name'),  # 防止同一榜单下重复名称
        Index('idx_item_leaderboard', 'leaderboard_id'),
        Index('idx_item_vote_score', 'vote_score'),
        Index('idx_item_status', 'status'),
    )
```

### 3. 投票记录表 (leaderboard_votes)

```python
from sqlalchemy import Column, Integer, String, Text, Boolean, DateTime, ForeignKey
from app.utils.time_utils import get_utc_time

class LeaderboardVote(Base):
    __tablename__ = "leaderboard_votes"
    
    id = Column(Integer, primary_key=True, index=True)
    item_id = Column(Integer, ForeignKey("leaderboard_items.id"), nullable=False)
    user_id = Column(String(8), ForeignKey("users.id"), nullable=False)
    vote_type = Column(String(10), nullable=False)  # upvote, downvote
    comment = Column(Text, nullable=True)  # 投票留言（可选，最多500字）
    is_anonymous = Column(Boolean, default=False, nullable=False)  # 是否匿名投票/留言（v2.3新增）
    created_at = Column(DateTime(timezone=True), default=get_utc_time)
    updated_at = Column(DateTime(timezone=True), default=get_utc_time, onupdate=get_utc_time)
    
    # 关系
    item = relationship("LeaderboardItem", back_populates="votes")
    user = relationship("User")
    
    __table_args__ = (
        UniqueConstraint('item_id', 'user_id', name='uq_item_user_vote'),  # 每个用户对每个竞品只能投一票
        Index('idx_vote_item_user', 'item_id', 'user_id'),
        CheckConstraint('LENGTH(comment) <= 500', name='ck_vote_comment_length'),  # 留言长度限制（★★★★☆）
    )
```

### 4. 数据库迁移

创建迁移文件：

```python
# alembic/versions/xxxx_add_custom_leaderboards.py

def upgrade():
    # 创建custom_leaderboards表
    op.create_table(
        'custom_leaderboards',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('name', sa.String(100), nullable=False),
        sa.Column('location', sa.String(100), nullable=False),
        sa.Column('description', sa.Text(), nullable=True),
        sa.Column('cover_image', sa.String(500), nullable=True),
        sa.Column('applicant_id', sa.String(8), nullable=False),
        sa.Column('application_reason', sa.Text(), nullable=True),
        sa.Column('status', sa.String(20), server_default='pending'),  # pending, active, rejected
        sa.Column('reviewed_by', sa.String(36), nullable=True),
        sa.Column('reviewed_at', sa.DateTime(timezone=True), nullable=True),
        sa.Column('review_comment', sa.Text(), nullable=True),
        sa.Column('item_count', sa.Integer(), server_default='0'),
        sa.Column('vote_count', sa.Integer(), server_default='0'),
        sa.Column('view_count', sa.Integer(), server_default='0'),
        sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()')),
        sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('now()')),
        sa.ForeignKeyConstraint(['applicant_id'], ['users.id']),
        sa.ForeignKeyConstraint(['reviewed_by'], ['admin_users.id']),
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint('name', 'location', name='uq_leaderboard_name_location')
    )
    op.create_index('idx_leaderboard_status', 'custom_leaderboards', ['status'])
    op.create_index('idx_leaderboard_location', 'custom_leaderboards', ['location'])
    op.create_index('idx_leaderboard_vote_count', 'custom_leaderboards', ['vote_count'])  # 热门榜单排序优化
    
    # 创建leaderboard_items表
    op.create_table(
        'leaderboard_items',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('leaderboard_id', sa.Integer(), nullable=False),
        sa.Column('name', sa.String(200), nullable=False),
        sa.Column('description', sa.Text(), nullable=True),
        sa.Column('address', sa.String(500), nullable=True),
        sa.Column('phone', sa.String(50), nullable=True),
        sa.Column('website', sa.String(500), nullable=True),
        sa.Column('images', sa.Text(), nullable=True),
        sa.Column('submitted_by', sa.String(8), nullable=False),
        sa.Column('status', sa.String(20), server_default='approved'),  # V1版本：竞品自动通过
        sa.Column('upvotes', sa.Integer(), server_default='0'),
        sa.Column('downvotes', sa.Integer(), server_default='0'),
        sa.Column('net_votes', sa.Integer(), server_default='0'),
        sa.Column('vote_score', sa.Float(), server_default='0.0'),
        sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()')),
        sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('now()')),
        sa.ForeignKeyConstraint(['leaderboard_id'], ['custom_leaderboards.id']),
        sa.ForeignKeyConstraint(['submitted_by'], ['users.id']),
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint('leaderboard_id', 'name', name='uq_item_leaderboard_name'),
        sa.CheckConstraint('upvotes >= 0', name='ck_item_upvotes_non_negative'),
        sa.CheckConstraint('downvotes >= 0', name='ck_item_downvotes_non_negative')
    )
    op.create_index('idx_item_leaderboard', 'leaderboard_items', ['leaderboard_id'])
    op.create_index('idx_item_vote_score', 'leaderboard_items', ['vote_score'])
    op.create_index('idx_item_status', 'leaderboard_items', ['status'])
    
    # 创建leaderboard_votes表
    op.create_table(
        'leaderboard_votes',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('item_id', sa.Integer(), nullable=False),
        sa.Column('user_id', sa.String(8), nullable=False),
        sa.Column('vote_type', sa.String(10), nullable=False),
        sa.Column('comment', sa.Text(), nullable=True),  # 投票留言（可选，最多500字）
        sa.Column('is_anonymous', sa.Boolean(), server_default='false', nullable=False),  # 是否匿名投票/留言
        sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()')),
        sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('now()')),
        sa.ForeignKeyConstraint(['item_id'], ['leaderboard_items.id']),
        sa.ForeignKeyConstraint(['user_id'], ['users.id']),
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint('item_id', 'user_id', name='uq_item_user_vote'),
        sa.CheckConstraint('LENGTH(comment) <= 500', name='ck_vote_comment_length')  # 留言长度限制
    )
    op.create_index('idx_vote_item_user', 'leaderboard_votes', ['item_id', 'user_id'])

def downgrade():
    """
    ⚠️ 警告：此downgrade函数会删除所有数据！
    
    生产环境禁止使用此函数，否则会导致所有用户创建的榜单和投票记录永久丢失。
    
    如需回滚，请：
    1. 仅回滚后端代码版本（保留数据库结构）
    2. 通过特性开关关闭前端入口
    3. 如需真正删除表，请先备份数据后再手动执行DROP TABLE
    
    此函数仅用于开发环境测试。
    """
    # 生产环境请注释掉以下代码，避免误操作导致数据丢失
    # op.drop_table('leaderboard_votes')
    # op.drop_table('leaderboard_items')
    # op.drop_table('custom_leaderboards')
    pass  # 开发环境如需使用，取消上面的注释
```

---

## 时间处理说明

### 后端时间处理

**统一使用项目的时间工具函数**：

```python
from app.utils.time_utils import get_utc_time

# 在模型中使用
created_at = Column(DateTime(timezone=True), default=get_utc_time)
updated_at = Column(DateTime(timezone=True), default=get_utc_time, onupdate=get_utc_time)

# 在路由中使用
leaderboard.reviewed_at = get_utc_time()
item.updated_at = get_utc_time()
```

**重要说明**：
- `get_utc_time()` 定义在 `backend/app/utils/time_utils.py`
- 返回 `datetime.now(timezone.utc)`，确保是timezone-aware的UTC时间
- **禁止使用** `datetime.utcnow()`（返回naive时间）或 `datetime.now()`（不带时区）
- 所有时间字段统一使用 `DateTime(timezone=True)` 存储UTC时间

### 前端时间显示

**统一使用项目的时间工具类**：

```typescript
import { TimeHandlerV2 } from '../utils/timeUtils';

// 格式化UTC时间为用户本地时间
const displayTime = TimeHandlerV2.formatUtcToLocal(
  item.created_at, 
  'YYYY-MM-DD HH:mm',
  'Europe/London'  // 可选，默认自动检测用户时区
);
```

**重要说明**：
- `TimeHandlerV2` 定义在 `frontend/src/utils/timeUtils.ts`
- 使用 `dayjs` 库处理时间转换
- 自动处理UTC到用户本地时区的转换
- 支持多种时间格式（ISO格式、数据库格式等）

### 数据库时间存储

- **存储格式**：统一使用 `TIMESTAMPTZ`（PostgreSQL）或 `DateTime(timezone=True)`（SQLAlchemy）
- **存储值**：UTC时间（带时区信息）
- **默认值**：
  - 模型层：使用 `default=get_utc_time`（Python侧生成UTC时间）
  - 迁移层：使用 `server_default=sa.text('now()')`（数据库侧生成）
  - **重要**：生产环境数据库必须配置为 `timezone = 'UTC'`，以保证 `now()` 返回UTC时间
  - 如果数据库时区不是UTC，纯SQL插入（绕过ORM）会产生时区不一致问题

---

## 后端实现指南

### 步骤1: 创建数据模型

在 `backend/app/models.py` 中添加：

```python
from app.utils.time_utils import get_utc_time

class CustomLeaderboard(Base):
    __tablename__ = "custom_leaderboards"
    # ... 见上面的数据库设计
    # 注意：时间字段使用 default=get_utc_time

class LeaderboardItem(Base):
    __tablename__ = "leaderboard_items"
    # ... 见上面的数据库设计
    # 注意：时间字段使用 default=get_utc_time

class LeaderboardVote(Base):
    __tablename__ = "leaderboard_votes"
    # ... 见上面的数据库设计
    # 注意：时间字段使用 default=get_utc_time
```

**重要**：确保在文件顶部导入 `get_utc_time`：
```python
from app.utils.time_utils import get_utc_time
```

### 步骤2: 创建Schema定义

在 `backend/app/schemas.py` 中添加：

```python
class CustomLeaderboardBase(BaseModel):
    name: str
    location: str
    description: Optional[str] = None
    cover_image: Optional[str] = None
    application_reason: Optional[str] = None

class CustomLeaderboardCreate(CustomLeaderboardBase):
    pass

class CustomLeaderboardOut(CustomLeaderboardBase):
    id: int
    applicant_id: str
    status: str
    item_count: int
    vote_count: int
    view_count: int
    created_at: datetime
    updated_at: datetime
    
    class Config:
        from_attributes = True

class LeaderboardItemBase(BaseModel):
    name: str
    description: Optional[str] = None
    address: Optional[str] = None
    phone: Optional[str] = None
    website: Optional[str] = None
    images: Optional[List[str]] = None  # 注意：数据库存储为JSON字符串，返回时需要解析

class LeaderboardItemCreate(LeaderboardItemBase):
    leaderboard_id: int

class LeaderboardItemOut(LeaderboardItemBase):
    id: int
    leaderboard_id: int
    submitted_by: str
    status: str
    upvotes: int
    downvotes: int
    net_votes: int
    vote_score: float
    user_vote: Optional[str] = None  # 当前用户的投票类型：upvote, downvote, 或 None
    user_vote_comment: Optional[str] = None  # 当前用户的投票留言
    user_vote_is_anonymous: Optional[bool] = None  # 当前用户的投票是否匿名
    created_at: datetime
    updated_at: datetime
    
    class Config:
        from_attributes = True

class LeaderboardVoteCreate(BaseModel):
    item_id: int
    vote_type: str  # "upvote" or "downvote"
    comment: Optional[str] = None  # 投票留言（可选）
    is_anonymous: bool = False  # 是否匿名投票/留言

class LeaderboardVoteOut(BaseModel):
    id: int
    item_id: int
    user_id: Optional[str] = None  # 匿名投票时不返回user_id（管理员接口始终返回）
    vote_type: str
    comment: Optional[str] = None  # 投票留言
    is_anonymous: bool  # 是否匿名
    created_at: datetime
    updated_at: datetime
    
    class Config:
        from_attributes = True

class LeaderboardVoteAdminOut(BaseModel):
    """管理员专用：查看投票记录（始终返回user_id，用于审计）"""
    id: int
    item_id: int
    user_id: str  # 管理员接口始终返回user_id（即使匿名）
    vote_type: str
    comment: Optional[str] = None  # 投票留言
    is_anonymous: bool  # 是否匿名标识
    created_at: datetime
    updated_at: datetime
    
    class Config:
        from_attributes = True
```

### 步骤3: 创建API路由

创建新文件 `backend/app/custom_leaderboard_routes.py`：

```python
import json
from fastapi import APIRouter, Depends, Query, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func, and_, or_, update
from sqlalchemy.exc import IntegrityError
from typing import Optional, List
from app.database import get_async_db_dependency
from app import models, schemas
from app.auth import get_current_user_secure_async_csrf, get_current_admin_async, get_current_user_optional
from app.utils.time_utils import get_utc_time

router = APIRouter(prefix="/api/custom-leaderboards", tags=["Custom Leaderboards"])

# ==================== 管理员专用接口（查看所有状态的榜单） ====================

@router.get("/admin/all", response_model=List[schemas.CustomLeaderboardOut])
async def get_all_leaderboards_admin(
    location: Optional[str] = Query(None, description="地区筛选"),
    status: Optional[str] = Query("all", description="状态筛选：active, pending, rejected, all"),
    limit: int = Query(20, ge=1, le=100),
    offset: int = Query(0, ge=0),
    current_admin: models.AdminUser = Depends(get_current_admin_async),
    db: AsyncSession = Depends(get_async_db_dependency),
):
    """管理员专用：获取所有状态的榜单列表"""
    query = select(models.CustomLeaderboard)
    
    if status == "active":
        query = query.where(models.CustomLeaderboard.status == "active")
    elif status == "pending":
        query = query.where(models.CustomLeaderboard.status == "pending")
    elif status == "rejected":
        query = query.where(models.CustomLeaderboard.status == "rejected")
    # status == "all" 时显示所有
    
    if location:
        query = query.where(models.CustomLeaderboard.location == location)
    
    query = query.order_by(models.CustomLeaderboard.created_at.desc())
    query = query.offset(offset).limit(limit)
    
    result = await db.execute(query)
    leaderboards = result.scalars().all()
    
    return leaderboards

# ==================== 管理员查看投票记录 ====================

@router.get("/admin/votes", response_model=List[schemas.LeaderboardVoteAdminOut])
async def get_votes_admin(
    item_id: Optional[int] = Query(None, description="竞品ID筛选"),
    leaderboard_id: Optional[int] = Query(None, description="榜单ID筛选"),
    is_anonymous: Optional[bool] = Query(None, description="是否匿名筛选"),
    keyword: Optional[str] = Query(None, description="关键词搜索（用户名/留言内容）"),  # ★★☆☆☆ 搜索优化
    limit: int = Query(50, ge=1, le=200),
    offset: int = Query(0, ge=0),
    current_admin: models.AdminUser = Depends(get_current_admin_async),
    db: AsyncSession = Depends(get_async_db_dependency),
):
    """管理员专用：查看投票记录列表（包含匿名标识，用于审计）"""
    query = select(models.LeaderboardVote)
    
    if item_id:
        query = query.where(models.LeaderboardVote.item_id == item_id)
    
    if leaderboard_id:
        # 需要通过leaderboard_items表关联查询
        query = query.join(
            models.LeaderboardItem,
            models.LeaderboardItem.id == models.LeaderboardVote.item_id
        ).where(models.LeaderboardItem.leaderboard_id == leaderboard_id)
    
    if is_anonymous is not None:
        query = query.where(models.LeaderboardVote.is_anonymous == is_anonymous)
    
    # ★★☆☆☆ 关键词搜索（用户名/留言内容）
    if keyword:
        keyword_pattern = f"%{keyword}%"
        # 搜索留言内容和user_id
        query = query.where(
            or_(
                models.LeaderboardVote.comment.ilike(keyword_pattern),
                models.LeaderboardVote.user_id.ilike(keyword_pattern)
            )
        )
    
    query = query.order_by(models.LeaderboardVote.created_at.desc())
    query = query.offset(offset).limit(limit)
    
    result = await db.execute(query)
    votes = result.scalars().all()
    
    # 管理员接口始终返回user_id（即使匿名），方便审计
    votes_out = []
    for vote in votes:
        vote_dict = {
            "id": vote.id,
            "item_id": vote.item_id,
            "user_id": vote.user_id,  # 管理员可以看到真实user_id
            "vote_type": vote.vote_type,
            "comment": vote.comment,
            "is_anonymous": vote.is_anonymous,  # 是否匿名标识
            "created_at": vote.created_at,
            "updated_at": vote.updated_at
        }
        votes_out.append(vote_dict)
    
    return votes_out

# ==================== 榜单申请 ====================

@router.post("/apply", response_model=schemas.CustomLeaderboardOut)
async def apply_leaderboard(
    leaderboard_data: schemas.CustomLeaderboardCreate,
    current_user: models.User = Depends(get_current_user_secure_async_csrf),
    db: AsyncSession = Depends(get_async_db_dependency),
):
    """用户申请创建新榜单"""
    # 检查是否已有相同名称和地区的榜单
    existing = await db.execute(
        select(models.CustomLeaderboard).where(
            and_(
                models.CustomLeaderboard.name == leaderboard_data.name,
                models.CustomLeaderboard.location == leaderboard_data.location,
                models.CustomLeaderboard.status.in_(["pending", "active"])  # 只检查待审核和已激活的
            )
        )
    )
    if existing.scalar_one_or_none():
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="该地区已存在相同名称的榜单申请或已激活榜单"
        )
    
    # 注意：数据库层有UniqueConstraint('name', 'location')作为兜底，防止并发插入重复数据
    # 如果发生唯一约束冲突，会抛出IntegrityError，需要捕获并返回400错误
    
    # 创建新榜单申请
    new_leaderboard = models.CustomLeaderboard(
        name=leaderboard_data.name,
        location=leaderboard_data.location,
        description=leaderboard_data.description,
        cover_image=leaderboard_data.cover_image,
        application_reason=leaderboard_data.application_reason,
        applicant_id=current_user.id,
        status="pending"
    )
    
    db.add(new_leaderboard)
    
    # 标准错误处理：捕获唯一约束异常
    try:
        await db.commit()
    except IntegrityError:
        await db.rollback()
        # 业务层已做检查，这里主要是兜底并发情况
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="该地区已存在相同名称的榜单申请或已激活榜单"
        )
    
    await db.refresh(new_leaderboard)
    return new_leaderboard

# ==================== 榜单列表 ====================

@router.get("/", response_model=List[schemas.CustomLeaderboardOut])
async def get_leaderboards(
    location: Optional[str] = Query(None, description="地区筛选"),
    status: Optional[str] = Query("active", description="状态筛选：active（公开接口仅支持active）"),
    keyword: Optional[str] = Query(None, description="关键词搜索（榜单名称、描述）"),
    limit: int = Query(20, ge=1, le=100),
    offset: int = Query(0, ge=0),
    db: AsyncSession = Depends(get_async_db_dependency),
):
    """获取榜单列表（前端显示，仅返回active状态的榜单）"""
    query = select(models.CustomLeaderboard)
    
    # ⚠️ 安全修复：公开接口强制只返回active状态的榜单，防止隐私泄露
    # 如需查看pending/rejected榜单，请使用管理员专用接口 /admin/custom-leaderboards
    if status and status != "active":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="公开接口仅支持查看active状态的榜单，如需查看其他状态请使用管理员接口"
        )
    
    query = query.where(models.CustomLeaderboard.status == "active")
    
    if location:
        query = query.where(models.CustomLeaderboard.location == location)
    
    # 关键词搜索：支持按榜单名称、描述搜索
    if keyword:
        keyword_pattern = f"%{keyword}%"
        query = query.where(
            or_(
                models.CustomLeaderboard.name.ilike(keyword_pattern),
                models.CustomLeaderboard.description.ilike(keyword_pattern)
            )
        )
    
    query = query.order_by(models.CustomLeaderboard.created_at.desc())
    query = query.offset(offset).limit(limit)
    
    result = await db.execute(query)
    leaderboards = result.scalars().all()
    
    return leaderboards

# ==================== 榜单详情 ====================

@router.get("/{leaderboard_id}", response_model=schemas.CustomLeaderboardOut)
async def get_leaderboard_detail(
    leaderboard_id: int,
    db: AsyncSession = Depends(get_async_db_dependency),
):
    """获取榜单详情"""
    leaderboard = await db.get(models.CustomLeaderboard, leaderboard_id)
    
    # ⚠️ 安全修复：公开接口仅允许访问active状态的榜单，防止隐私泄露
    if not leaderboard or leaderboard.status != "active":
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="榜单不存在或未激活"
        )
    
    # 增加浏览量
    leaderboard.view_count += 1
    await db.commit()
    
    return leaderboard

# ==================== 榜单审核（管理员） ====================

@router.post("/{leaderboard_id}/review")
async def review_leaderboard(
    leaderboard_id: int,
    action: str = Query(..., regex="^(approve|reject)$"),
    comment: Optional[str] = None,
    current_admin: models.AdminUser = Depends(get_current_admin_async),
    db: AsyncSession = Depends(get_async_db_dependency),
):
    """管理员审核榜单"""
    result = await db.execute(
        select(models.CustomLeaderboard).where(models.CustomLeaderboard.id == leaderboard_id)
    )
    leaderboard = result.scalar_one_or_none()
    
    if not leaderboard:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="榜单不存在"
        )
    
    if leaderboard.status != "pending":
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="该榜单已审核"
        )
    
    if action == "approve":
        leaderboard.status = "active"
    else:
        leaderboard.status = "rejected"
    
    leaderboard.reviewed_by = current_admin.id
    leaderboard.reviewed_at = get_utc_time()  # 使用项目统一的时间函数
    leaderboard.review_comment = comment
    
    await db.commit()
    
    return {"message": f"榜单已{action}"}

# ==================== 新增竞品 ====================

@router.post("/items", response_model=schemas.LeaderboardItemOut)
async def submit_item(
    item_data: schemas.LeaderboardItemCreate,
    current_user: models.User = Depends(get_current_user_secure_async_csrf),
    db: AsyncSession = Depends(get_async_db_dependency),
):
    """用户在榜单中新增竞品"""
    # 检查榜单是否存在且为active状态
    leaderboard = await db.get(models.CustomLeaderboard, item_data.leaderboard_id)
    
    # ⚠️ 安全修复：公开接口仅允许向active状态的榜单新增竞品
    if not leaderboard or leaderboard.status != "active":
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="榜单不存在或未激活"
        )
    
    # 检查是否已存在相同名称的竞品（业务层检查）
    existing = await db.execute(
        select(models.LeaderboardItem).where(
            and_(
                models.LeaderboardItem.leaderboard_id == item_data.leaderboard_id,
                models.LeaderboardItem.name == item_data.name,
                models.LeaderboardItem.status == "approved"  # 当前版本竞品自动通过，只检查已通过的
            )
        )
    )
    if existing.scalar_one_or_none():
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="该榜单中已存在相同名称的竞品"
        )
    
    # 注意：数据库层有UniqueConstraint('leaderboard_id', 'name')作为兜底，防止并发插入重复数据
    
    # 创建竞品（当前版本：竞品自动通过，无需审核）
    new_item = models.LeaderboardItem(
        leaderboard_id=item_data.leaderboard_id,
        name=item_data.name,
        description=item_data.description,
        address=item_data.address,
        phone=item_data.phone,
        website=item_data.website,
        images=json.dumps(item_data.images) if item_data.images else None,
        submitted_by=current_user.id,
        status="approved"  # V1版本：竞品自动通过，未来可改为"pending"并添加审核流程
    )
    
    db.add(new_item)
    
    # 更新榜单统计
    leaderboard.item_count += 1
    
    # 标准错误处理：捕获唯一约束异常
    try:
        await db.commit()
    except IntegrityError:
        await db.rollback()
        # 业务层已做检查，这里主要是兜底并发情况
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="该榜单中已存在相同名称的竞品"
        )
    
    await db.refresh(new_item)
    return new_item

# ==================== 获取榜单中的竞品列表 ====================

@router.get("/{leaderboard_id}/items", response_model=List[schemas.LeaderboardItemOut])
async def get_leaderboard_items(
    leaderboard_id: int,
    sort: str = Query("vote_score", regex="^(vote_score|net_votes|upvotes|created_at)$"),
    limit: int = Query(50, ge=1, le=200),
    offset: int = Query(0, ge=0),
    db: AsyncSession = Depends(get_async_db_dependency),
    current_user: Optional[models.User] = Depends(get_current_user_optional),
):
    """获取榜单中的竞品列表（按投票排序）"""
    # 检查榜单是否存在且为active状态
    leaderboard = await db.get(models.CustomLeaderboard, leaderboard_id)
    
    # ⚠️ 安全修复：公开接口仅允许访问active状态的榜单，防止隐私泄露
    if not leaderboard or leaderboard.status != "active":
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="榜单不存在或未激活"
        )
    
    # 构建查询
    query = select(models.LeaderboardItem).where(
        and_(
            models.LeaderboardItem.leaderboard_id == leaderboard_id,
            models.LeaderboardItem.status == "approved"
        )
    )
    
    # 排序
    if sort == "vote_score":
        query = query.order_by(models.LeaderboardItem.vote_score.desc())
    elif sort == "net_votes":
        query = query.order_by(models.LeaderboardItem.net_votes.desc())
    elif sort == "upvotes":
        query = query.order_by(models.LeaderboardItem.upvotes.desc())
    elif sort == "created_at":
        query = query.order_by(models.LeaderboardItem.created_at.desc())
    
    query = query.offset(offset).limit(limit)
    
    result = await db.execute(query)
    items = result.scalars().all()
    
    # 查询当前用户的投票记录（如果已登录）
    user_votes = {}
    user_vote_comments = {}
    user_vote_is_anonymous = {}
    if current_user:
        item_ids = [item.id for item in items]
        if item_ids:
            vote_result = await db.execute(
                select(models.LeaderboardVote).where(
                    and_(
                        models.LeaderboardVote.item_id.in_(item_ids),
                        models.LeaderboardVote.user_id == current_user.id
                    )
                )
            )
            # 同时获取投票类型、留言和匿名状态
            for vote in vote_result.scalars().all():
                user_votes[vote.item_id] = vote.vote_type
                user_vote_is_anonymous[vote.item_id] = vote.is_anonymous
                if vote.comment:
                    user_vote_comments[vote.item_id] = vote.comment
    
    # 构建返回数据，包含user_vote字段，并解析images字段
    items_out = []
    for item in items:
        # 解析images字段（从JSON字符串转为List）
        images_list = None
        if item.images:
            try:
                images_list = json.loads(item.images)
            except Exception:
                images_list = None
        
        item_dict = {
            "id": item.id,
            "leaderboard_id": item.leaderboard_id,
            "name": item.name,
            "description": item.description,
            "address": item.address,
            "phone": item.phone,
            "website": item.website,
            "images": images_list,
            "submitted_by": item.submitted_by,
            "status": item.status,
            "upvotes": item.upvotes,
            "downvotes": item.downvotes,
            "net_votes": item.net_votes,
            "vote_score": item.vote_score,
            "user_vote": user_votes.get(item.id),  # 当前用户的投票类型
            "user_vote_comment": user_vote_comments.get(item.id),  # 当前用户的投票留言
            "user_vote_is_anonymous": user_vote_is_anonymous.get(item.id) if item.id in user_vote_is_anonymous else None,  # 当前用户的投票是否匿名（未投票时为None）
            "created_at": item.created_at,
            "updated_at": item.updated_at
        }
        items_out.append(item_dict)
    
    return items_out

# ==================== 投票 ====================

@router.post("/items/{item_id}/vote")
async def vote_item(
    item_id: int,
    vote_type: str = Query(..., regex="^(upvote|downvote|remove)$"),
    comment: Optional[str] = Query(None, max_length=500, description="投票留言（可选，最多500字）"),
    is_anonymous: bool = Query(False, description="是否匿名投票/留言"),
    current_user: models.User = Depends(get_current_user_secure_async_csrf),
    db: AsyncSession = Depends(get_async_db_dependency),
):
    """用户对竞品投票（可附带留言）"""
    # ★★★★☆ 投票留言清洗（防止XSS和数据库炸）
    if comment:
        import bleach
        # 剥离所有HTML标签，防止XSS
        comment = bleach.clean(comment, tags=[], strip=True)
        # 长度检查（前端已限制，这里作为兜底）
        if len(comment) > 500:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="留言最多500字"
            )
    
    # 检查竞品是否存在
    item = await db.get(models.LeaderboardItem, item_id)
    if not item:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="竞品不存在"
        )
    
    # 检查榜单是否存在
    leaderboard = await db.get(models.CustomLeaderboard, item.leaderboard_id)
    if not leaderboard:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="榜单不存在"
        )
    
    # ⚠️ 必须校验榜单状态和竞品状态（v2.1修复）
    if leaderboard.status != "active" or item.status != "approved":
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="榜单或竞品不可投票"
        )
    
    # 检查是否已投票
    existing_vote = await db.execute(
        select(models.LeaderboardVote).where(
            and_(
                models.LeaderboardVote.item_id == item_id,
                models.LeaderboardVote.user_id == current_user.id
            )
        )
    )
    existing = existing_vote.scalar_one_or_none()
    
    if vote_type == "remove":
        # 取消投票
        if not existing:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="您尚未投票"
            )
        
        # 更新竞品统计
        if existing.vote_type == "upvote":
            item.upvotes -= 1
        else:
            item.downvotes -= 1
        # 防止负数（防御式编程）
        item.upvotes = max(0, item.upvotes)
        item.downvotes = max(0, item.downvotes)
        item.net_votes = item.upvotes - item.downvotes
        calculate_vote_score(item)  # 不在这里commit
        
        # 注意：此分支不更新vote_count（保持历史累计语义，只有新增投票时才+1）
        await db.delete(existing)
        await db.commit()
        
        return {
            "message": "投票已取消",
            "upvotes": item.upvotes,
            "downvotes": item.downvotes,
            "net_votes": item.net_votes,
            "vote_score": item.vote_score
        }
    
    if existing:
        # 修改投票
        if existing.vote_type == vote_type:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="您已经投过相同的票"
            )
        
        # 更新旧投票的统计
        if existing.vote_type == "upvote":
            item.upvotes -= 1
        else:
            item.downvotes -= 1
        
        # 更新新投票的统计
        if vote_type == "upvote":
            item.upvotes += 1
        else:
            item.downvotes += 1
        
        # 防止负数（防御式编程）
        item.upvotes = max(0, item.upvotes)
        item.downvotes = max(0, item.downvotes)
        
        existing.vote_type = vote_type
        existing.comment = comment  # 更新留言（如果提供）
        existing.is_anonymous = is_anonymous  # 更新匿名状态
        existing.updated_at = get_utc_time()  # 使用项目统一的时间函数
    else:
        # 新投票
        new_vote = models.LeaderboardVote(
            item_id=item_id,
            user_id=current_user.id,
            vote_type=vote_type,
            comment=comment,  # 保存留言（如果提供）
            is_anonymous=is_anonymous  # 保存匿名状态
        )
        db.add(new_vote)
        
        if vote_type == "upvote":
            item.upvotes += 1
        else:
            item.downvotes += 1
    
    # 防止负数（防御式编程）
    item.upvotes = max(0, item.upvotes)
    item.downvotes = max(0, item.downvotes)
    
    # 更新净赞数和得分
    item.net_votes = item.upvotes - item.downvotes
    calculate_vote_score(item)  # 纯计算函数，不执行commit
    
    # 更新榜单总投票数（历史累计投票数，按用户对竞品去重，用于统计参与度）
    # 注意：只有新增投票时才+1，修改投票或取消投票不改变vote_count
    # 注意：leaderboard已在前面查询过，直接使用即可，无需重复查询
    if not existing:  # 只有新投票（该用户第一次给该item投票）才增加计数
        leaderboard.vote_count += 1
    
    # 统一提交事务
    await db.commit()
    
    return {
        "message": "投票成功",
        "upvotes": item.upvotes,
        "downvotes": item.downvotes,
        "net_votes": item.net_votes,
        "vote_score": item.vote_score
    }

# ==================== 投票得分计算 ====================

def calculate_vote_score(item: models.LeaderboardItem):
    """
    计算竞品的投票得分（用于排序）
    注意：这是一个纯计算函数，不执行数据库操作，由调用方负责commit
    """
    import math
    from app.utils.time_utils import get_utc_time
    
    total_votes = item.upvotes + item.downvotes
    
    if total_votes == 0:
        item.vote_score = 0.0
        return
    
    # Wilson Score Lower Bound算法
    # 公式: (p + z²/2n - z√((p(1-p) + z²/4n)/n)) / (1 + z²/n)
    # 其中 p = upvotes/total_votes, z = 1.96 (95%置信度), n = total_votes
    
    z = 1.96
    p = item.upvotes / total_votes
    n = total_votes
    
    denominator = 1 + (z * z / n)
    numerator = p + (z * z / (2 * n)) - z * math.sqrt((p * (1 - p) + z * z / (4 * n)) / n)
    wilson_score = numerator / denominator
    
    # 考虑时间衰减（可选）
    # 新添加的竞品给予一定的时间加成，避免老竞品长期占据榜首
    # 注意：item.created_at必须是timezone-aware的datetime（已在模型层统一为get_utc_time()）
    # 边界保护：防止created_at大于当前时间（时钟漂移/手动改数据）导致负数
    days_since_created = max(0, (get_utc_time() - item.created_at).days)
    time_factor = 1.0 / (1.0 + days_since_created * 0.01)  # 每天衰减1%
    
    item.vote_score = wilson_score * 100 * time_factor  # 乘以100便于排序
    # 注意：不在这里commit，由调用方统一提交事务
```

### 步骤4: 注册路由

在 `backend/app/main.py` 中：

```python
from app.custom_leaderboard_routes import router as custom_leaderboard_router

app.include_router(custom_leaderboard_router)
```

---

## 前端实现指南

### 步骤1: 添加API调用函数

在 `frontend/src/api.ts` 中添加：

```typescript
// 自定义排行榜API
export const applyCustomLeaderboard = async (data: {
  name: string;
  location: string;
  description?: string;
  cover_image?: string;
  application_reason?: string;
}) => {
  const token = await getCSRFToken();
  const res = await api.post('/api/custom-leaderboards/apply', data, {
    headers: { 'X-CSRF-Token': token }
  });
  return res.data;
};

export const getCustomLeaderboards = async (params?: {
  location?: string;
  status?: string;
  keyword?: string;  // 关键词搜索
  limit?: number;
  offset?: number;
}) => {
  const res = await api.get('/api/custom-leaderboards', { params });
  return res.data;
};

export const getCustomLeaderboardDetail = async (leaderboardId: number) => {
  const res = await api.get(`/api/custom-leaderboards/${leaderboardId}`);
  return res.data;
};

export const submitLeaderboardItem = async (data: {
  leaderboard_id: number;
  name: string;
  description?: string;
  address?: string;
  phone?: string;
  website?: string;
  images?: string[];
}) => {
  const token = await getCSRFToken();
  const res = await api.post('/api/custom-leaderboards/items', data, {
    headers: { 'X-CSRF-Token': token }
  });
  return res.data;
};

export const getLeaderboardItems = async (
  leaderboardId: number,
  params?: {
    sort?: 'vote_score' | 'net_votes' | 'upvotes' | 'created_at';
    limit?: number;
    offset?: number;
  }
) => {
  const res = await api.get(`/api/custom-leaderboards/${leaderboardId}/items`, { params });
  return res.data;
};

export const voteLeaderboardItem = async (
  itemId: number,
  voteType: 'upvote' | 'downvote' | 'remove',
  comment?: string,  // 投票留言（可选）
  isAnonymous: boolean = false  // 是否匿名投票/留言
) => {
  const token = await getCSRFToken();
  const params: any = { vote_type: voteType };
  if (comment) {
    params.comment = comment;
  }
  if (isAnonymous) {
    params.is_anonymous = true;
  }
  const res = await api.post(
    `/api/custom-leaderboards/items/${itemId}/vote`,
    null,
    {
      params,
      headers: { 'X-CSRF-Token': token }
    }
  );
  return res.data;
};
```

### 步骤2: 更新论坛排行榜页面

修改 `frontend/src/pages/ForumLeaderboard.tsx`，添加"其它排行榜"Tab：

```typescript
const [activeTab, setActiveTab] = useState<'posts' | 'replies' | 'likes' | 'custom'>('posts');

// ⚠️ 重要：自定义排行榜不使用时间周期筛选
// 当切换到"其它排行榜"Tab时，应该隐藏时间周期选择器
<div className={styles.toolbar}>
  {activeTab !== 'custom' && (
    <Select
      value={period}
      onChange={setPeriod}
      style={{ width: 150 }}
    >
      <Option value="all">{t('forum.periodAll')}</Option>
      <Option value="today">{t('forum.periodToday')}</Option>
      <Option value="week">{t('forum.periodWeek')}</Option>
      <Option value="month">{t('forum.periodMonth')}</Option>
    </Select>
  )}
</div>

<Tabs activeKey={activeTab} onChange={(key) => setActiveTab(key as any)}>
  {/* ... 其他Tab ... */}
  
  <TabPane tab="其它排行榜" key="custom">
    <CustomLeaderboardsTab />
  </TabPane>
</Tabs>
```

**重要说明**：
- **时间周期选择器仅对论坛排行榜（发帖榜、回复榜、获赞榜）有效**
- **"其它排行榜"Tab不使用时间周期筛选，始终显示全部数据**
- 切换到"其它排行榜"Tab时，应隐藏时间周期选择器，避免用户困惑

### 步骤3: 创建自定义排行榜组件

创建 `frontend/src/components/CustomLeaderboardsTab.tsx`：

```typescript
import React, { useState, useEffect } from 'react';
import { Card, Button, Select, Modal, Form, message, Empty, Tag, Input } from 'antd';
import { PlusOutlined, TrophyOutlined } from '@ant-design/icons';
import { useLanguage } from '../contexts/LanguageContext';
import { useLocalizedNavigation } from '../hooks/useLocalizedNavigation';
import {
  applyCustomLeaderboard,
  getCustomLeaderboards
} from '../api';
import { fetchCurrentUser } from '../api';
import { LOCATIONS } from '../constants/leaderboard';  // 统一常量管理

const { Option } = Select;

const CustomLeaderboardsTab: React.FC = () => {
  // 注意：t和language暂时未使用，后续多语言化时会用到
  const { t, language } = useLanguage();
  const { navigate } = useLocalizedNavigation();
  const [leaderboards, setLeaderboards] = useState<any[]>([]);
  const [loading, setLoading] = useState(false);
  const [showApplyModal, setShowApplyModal] = useState(false);
  const [selectedLocation, setSelectedLocation] = useState<string>('');
  const [searchKeyword, setSearchKeyword] = useState<string>('');  // 搜索关键词
  const [user, setUser] = useState<any>(null);
  const [form] = Form.useForm();

  useEffect(() => {
    loadLeaderboards();
    fetchCurrentUser().then(setUser).catch(() => setUser(null));
  }, [selectedLocation, searchKeyword]);

  const loadLeaderboards = async () => {
    try {
      setLoading(true);
      const response = await getCustomLeaderboards({
        location: selectedLocation || undefined,
        keyword: searchKeyword || undefined,  // 传递搜索关键词
        status: 'active',
        limit: 50
      });
      setLeaderboards(response || []);
    } catch (error: any) {
      console.error('加载排行榜失败:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleApply = async (values: any) => {
    try {
      await applyCustomLeaderboard(values);
      message.success('榜单申请已提交，等待审核');
      setShowApplyModal(false);
      form.resetFields();
      loadLeaderboards();
    } catch (error: any) {
      message.error(error.response?.data?.detail || '申请失败');
    }
  };

  return (
    <div>
      {/* 筛选、搜索和申请按钮 */}
      <div style={{ marginBottom: 16, display: 'flex', gap: 12, alignItems: 'center' }}>
        <Select
          placeholder="选择地区"
          style={{ width: 150 }}
          allowClear
          value={selectedLocation}
          onChange={setSelectedLocation}
        >
          {LOCATIONS.map(loc => (
            <Option key={loc} value={loc}>{loc}</Option>
          ))}
        </Select>
        
        <Input.Search
          placeholder="搜索榜单名称或描述"
          style={{ flex: 1, maxWidth: 400 }}
          value={searchKeyword}
          onChange={(e) => setSearchKeyword(e.target.value)}
          onSearch={loadLeaderboards}
          allowClear
        />
        
        <Button
          type="primary"
          icon={<PlusOutlined />}
          onClick={() => {
            if (!user) {
              message.warning('请先登录');
              return;
            }
            setShowApplyModal(true);
          }}
        >
          申请新榜单
        </Button>
      </div>

      {/* 榜单列表 */}
      {loading ? (
        <div>加载中...</div>
      ) : leaderboards.length === 0 ? (
        <Empty description="暂无榜单" />
      ) : (
        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))', gap: 16 }}>
          {leaderboards.map(leaderboard => (
            <Card
              key={leaderboard.id}
              hoverable
              onClick={() => {
                const lang = language || 'zh';
                navigate(`/${lang}/leaderboard/custom/${leaderboard.id}`);
              }}
              cover={leaderboard.cover_image ? (
                <img alt={leaderboard.name} src={leaderboard.cover_image} style={{ height: 150, objectFit: 'cover' }} />
              ) : null}
            >
              <Card.Meta
                title={
                  <div>
                    <TrophyOutlined style={{ marginRight: 8 }} />
                    {leaderboard.name}
                  </div>
                }
                description={
                  <div>
                    <Tag color="blue">{leaderboard.location}</Tag>
                    <div style={{ marginTop: 8, fontSize: 12, color: '#999' }}>
                      {leaderboard.item_count} 个竞品 · {leaderboard.vote_count} 票
                    </div>
                  </div>
                }
              />
            </Card>
          ))}
        </div>
      )}

      {/* 申请榜单弹窗 */}
      <Modal
        title="申请新榜单"
        open={showApplyModal}
        onCancel={() => {
          setShowApplyModal(false);
          form.resetFields();
        }}
        onOk={() => form.submit()}
        width={600}
      >
        <Form
          form={form}
          layout="vertical"
          onFinish={handleApply}
        >
          <Form.Item
            name="name"
            label="榜单名称"
            rules={[{ required: true, message: '请输入榜单名称' }]}
          >
            <Input placeholder="例如：London中餐榜" />
          </Form.Item>
          
          <Form.Item
            label="榜单类型"
            rules={[{ required: true, message: '请选择榜单类型' }]}
          >
            <Select placeholder="选择类型">
              {CATEGORIES.map(cat => (
                <Option key={cat.value} value={cat.value}>{cat.label}</Option>
              ))}
            </Select>
          </Form.Item>
          
          <Form.Item
            name="location"
            label="地区"
            rules={[{ required: true, message: '请选择地区' }]}
          >
            <Select placeholder="选择地区">
              {LOCATIONS.map(loc => (
                <Option key={loc} value={loc}>{loc}</Option>
              ))}
            </Select>
          </Form.Item>
          
          <Form.Item
            name="description"
            label="榜单描述"
          >
            <Input.TextArea rows={4} placeholder="描述这个榜单的目的和范围" />
          </Form.Item>
          
          <Form.Item
            name="application_reason"
            label="申请理由"
            rules={[{ required: true, message: '请说明申请理由' }]}
          >
            <Input.TextArea rows={3} placeholder="为什么需要创建这个榜单？" />
          </Form.Item>
        </Form>
      </Modal>
    </div>
  );
};

export default CustomLeaderboardsTab;
```

### 步骤5: 创建榜单详情页面

创建 `frontend/src/pages/CustomLeaderboardDetail.tsx`：

```typescript
import React, { useState, useEffect } from 'react';
import { useParams } from 'react-router-dom';
import { Card, Button, Input, Space, Tag, Spin, Empty, Modal, Form, message, Checkbox } from 'antd';
import { LikeOutlined, DislikeOutlined, PlusOutlined } from '@ant-design/icons';
import { useLanguage } from '../contexts/LanguageContext';
import { TimeHandlerV2 } from '../utils/timeUtils';
import {
  getCustomLeaderboardDetail,
  getLeaderboardItems,
  submitLeaderboardItem,
  voteLeaderboardItem
} from '../api';
import { fetchCurrentUser } from '../api';
import { LOCATIONS } from '../constants/leaderboard';  // 统一常量管理

const CustomLeaderboardDetail: React.FC = () => {
  const { leaderboardId } = useParams<{ leaderboardId: string }>();
  // 注意：t和language暂时未使用，后续多语言化时会用到
  const { t, language } = useLanguage();
  const [leaderboard, setLeaderboard] = useState<any>(null);
  const [items, setItems] = useState<any[]>([]);
  const [loading, setLoading] = useState(false);
  const [showSubmitModal, setShowSubmitModal] = useState(false);
  const [showVoteModal, setShowVoteModal] = useState(false);
  const [currentVoteItemId, setCurrentVoteItemId] = useState<number | null>(null);
  const [currentVoteType, setCurrentVoteType] = useState<'upvote' | 'downvote' | null>(null);
  const [user, setUser] = useState<any>(null);
  const [form] = Form.useForm();
  const [voteForm] = Form.useForm();

  useEffect(() => {
    if (leaderboardId) {
      loadData();
      fetchCurrentUser().then(setUser).catch(() => setUser(null));
    }
  }, [leaderboardId]);

  const loadData = async () => {
    try {
      setLoading(true);
      const [leaderboardData, itemsData] = await Promise.all([
        getCustomLeaderboardDetail(Number(leaderboardId)),
        getLeaderboardItems(Number(leaderboardId), { sort: 'vote_score', limit: 100 })
      ]);
      setLeaderboard(leaderboardData);
      setItems(itemsData || []);
    } catch (error: any) {
      console.error('加载失败:', error);
      message.error('加载失败，请稍后重试');
    } finally {
      setLoading(false);
    }
  };

  const handleVote = async (itemId: number, voteType: 'upvote' | 'downvote') => {
    if (!user) {
      message.warning('请先登录');
      return;
    }

    // 检查当前用户是否已投票，如果已投相同类型的票，则取消投票
    const item = items.find(i => i.id === itemId);
    if (item && item.user_vote === voteType) {
      // 已投相同类型的票，取消投票（不需要留言）
      try {
        await voteLeaderboardItem(itemId, 'remove');
        message.success('投票已取消');
        loadData();
      } catch (error: any) {
        message.error(error.response?.data?.detail || '取消投票失败');
      }
    } else {
      // 新投票或修改投票，弹出留言输入框
      setCurrentVoteItemId(itemId);
      setCurrentVoteType(voteType);
      setShowVoteModal(true);
      voteForm.resetFields();
    }
  };

  const handleVoteSubmit = async (values: { comment?: string; is_anonymous?: boolean }) => {
    if (!currentVoteItemId || !currentVoteType) return;

    try {
      // ⚠️ 性能优化：使用返回的统计值局部更新，避免全量刷新
      const res = await voteLeaderboardItem(
        currentVoteItemId, 
        currentVoteType, 
        values.comment,
        values.is_anonymous || false
      );
      message.success('投票成功');
      setShowVoteModal(false);
      voteForm.resetFields();
      
      // 局部更新：只更新对应item的状态，不重新请求全部数据
      setItems(prev => prev.map(i => 
        i.id === currentVoteItemId ? {
          ...i,
          upvotes: res.upvotes,
          downvotes: res.downvotes,
          net_votes: res.net_votes,
          vote_score: res.vote_score,
          user_vote: currentVoteType,
          user_vote_comment: values.comment || null,
          user_vote_is_anonymous: values.is_anonymous || false,
        } : i
      ));
      
      // 可选：如果需要重新排序，可以调用loadData()，但会重新请求全部数据
      // loadData();
    } catch (error: any) {
      message.error(error.response?.data?.detail || '投票失败');
    }
  };

  const handleSubmitItem = async (values: any) => {
    try {
      await submitLeaderboardItem({
        leaderboard_id: Number(leaderboardId),
        ...values
      });
      message.success('竞品新增成功');
      setShowSubmitModal(false);
      form.resetFields();
      loadData();
    } catch (error: any) {
      message.error(error.response?.data?.detail || '提交失败');
    }
  };

  if (loading) {
    return <Spin size="large" />;
  }

  if (!leaderboard) {
    return <Empty description="榜单不存在" />;
  }

  return (
    <div style={{ maxWidth: 1200, margin: '0 auto', padding: '20px' }}>
      {/* 榜单头部 */}
      <Card style={{ marginBottom: 24 }}>
        <h1>{leaderboard.name}</h1>
        <Space>
          <Tag color="blue">{leaderboard.location}</Tag>
        </Space>
        {leaderboard.description && (
          <p style={{ marginTop: 16 }}>{leaderboard.description}</p>
        )}
        <div style={{ marginTop: 16 }}>
          <Button
            type="primary"
            icon={<PlusOutlined />}
            onClick={() => {
              if (!user) {
                message.warning('请先登录');
                return;
              }
              setShowSubmitModal(true);
            }}
          >
            新增竞品
          </Button>
        </div>
      </Card>

      {/* 竞品列表 */}
      <div style={{ display: 'flex', flexDirection: 'column', gap: 16 }}>
        {items.map((item, index) => (
          <Card key={item.id}>
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'start' }}>
              <div style={{ flex: 1 }}>
                <div style={{ display: 'flex', alignItems: 'center', gap: 12, marginBottom: 8 }}>
                  <span style={{ fontSize: 24, fontWeight: 'bold', color: index < 3 ? '#ffc107' : '#666' }}>
                    #{index + 1}
                  </span>
                  <h2 style={{ margin: 0 }}>{item.name}</h2>
                </div>
                {item.description && (
                  <p style={{ color: '#666', marginBottom: 8 }}>{item.description}</p>
                )}
                {item.address && (
                  <p style={{ fontSize: 12, color: '#999' }}>📍 {item.address}</p>
                )}
              </div>
              
              <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: 8 }}>
                <Button
                  type={item.user_vote === 'upvote' ? 'primary' : 'default'}
                  icon={<LikeOutlined />}
                  onClick={() => handleVote(item.id, 'upvote')}
                >
                  {item.upvotes}
                </Button>
                <Button
                  danger={item.user_vote === 'downvote'}
                  type={item.user_vote === 'downvote' ? 'primary' : 'default'}
                  icon={<DislikeOutlined />}
                  onClick={() => handleVote(item.id, 'downvote')}
                >
                  {item.downvotes}
                </Button>
                <div style={{ fontSize: 12, color: '#999' }}>
                  净赞: {item.net_votes}
                </div>
              </div>
            </div>
            {/* 显示用户自己的投票留言 */}
            {item.user_vote_comment && (
              <div style={{
                marginTop: 12,
                padding: 12,
                background: '#f5f5f5',
                borderRadius: 8,
                fontSize: 14,
                color: '#666'
              }}>
                <div style={{ fontWeight: 600, marginBottom: 4 }}>
                  {item.user_vote === 'upvote' ? '👍 你的留言' : '👎 你的留言'}：
                  {/* 可选：显示匿名标识 */}
                  {item.user_vote_is_anonymous && (
                    <Tag color="default" style={{ marginLeft: 8, fontSize: 12 }}>匿名</Tag>
                  )}
                </div>
                <div>{item.user_vote_comment}</div>
              </div>
            )}
            
            {/* 后续优化：显示所有留言（包括匿名留言的楼层式展示） */}
            {/* 
            {item.votes && item.votes.length > 0 && (
              <div style={{ marginTop: 16 }}>
                <div style={{ fontWeight: 600, marginBottom: 8 }}>留言区：</div>
                {item.votes.map((vote, voteIndex) => (
                  <div key={vote.id} style={{
                    padding: 8,
                    marginBottom: 8,
                    background: '#fafafa',
                    borderRadius: 4,
                    fontSize: 13
                  }}>
                    <div style={{ color: '#999', marginBottom: 4 }}>
                      {vote.is_anonymous 
                        ? `匿名用户 · ${TimeHandlerV2.formatUtcToLocal(vote.created_at, 'relative')}`
                        : `${vote.user_name} · ${TimeHandlerV2.formatUtcToLocal(vote.created_at, 'relative')}`
                      }
                    </div>
                    <div>{vote.comment}</div>
                  </div>
                ))}
              </div>
            )}
            */}
          </Card>
        ))}
      </div>

      {/* 新增竞品弹窗 */}
      <Modal
        title="新增竞品"
        open={showSubmitModal}
        onCancel={() => {
          setShowSubmitModal(false);
          form.resetFields();
        }}
        onOk={() => form.submit()}
        width={600}
      >
        <Form
          form={form}
          layout="vertical"
          onFinish={handleSubmitItem}
        >
          <Form.Item
            name="name"
            label="竞品名称"
            rules={[{ required: true, message: '请输入竞品名称' }]}
          >
            <Input placeholder="例如：海底捞" />
          </Form.Item>
          
          <Form.Item
            name="description"
            label="描述"
          >
            <Input.TextArea rows={4} placeholder="描述这个竞品的特点" />
          </Form.Item>
          
          <Form.Item
            name="address"
            label="地址"
          >
            <Input placeholder="详细地址" />
          </Form.Item>
          
          <Form.Item
            name="phone"
            label="电话"
          >
            <Input placeholder="联系电话" />
          </Form.Item>
          
          <Form.Item
            name="website"
            label="网站"
          >
            <Input placeholder="官方网站" />
          </Form.Item>
          {/* V1版本：暂不支持图片上传，后续版本可添加 */}
          {/* <Form.Item
            name="images"
            label="图片"
          >
            <Input.TextArea 
              placeholder="图片URL列表（每行一个URL）" 
              rows={3}
            />
          </Form.Item> */}
        </Form>
      </Modal>

      {/* 投票留言弹窗 */}
      <Modal
        title={currentVoteType === 'upvote' ? '点赞并留言' : '点踩并留言'}
        open={showVoteModal}
        onCancel={() => {
          setShowVoteModal(false);
          voteForm.resetFields();
        }}
        onOk={() => voteForm.submit()}
        width={500}
      >
        <Form
          form={voteForm}
          layout="vertical"
          onFinish={handleVoteSubmit}
        >
          <Form.Item
            name="comment"
            label="留言（可选）"
            rules={[{ max: 500, message: '留言最多500字' }]}
          >
            <Input.TextArea
              rows={4}
              placeholder={currentVoteType === 'upvote' 
                ? '分享你的使用体验，例如：物美价廉，服务人员很暖心' 
                : '请说明原因，帮助其他用户了解'}
              showCount
              maxLength={500}
            />
          </Form.Item>
          <Form.Item
            name="is_anonymous"
            valuePropName="checked"
          >
            <Checkbox>匿名投票/留言</Checkbox>
          </Form.Item>
        </Form>
      </Modal>
    </div>
  );
};

export default CustomLeaderboardDetail;
```

### 步骤6: 添加路由

在 `frontend/src/App.tsx` 中添加：

```typescript
import CustomLeaderboardDetail from './pages/CustomLeaderboardDetail';

// 在路由配置中添加
<Route path={`/${lang}/leaderboard/custom/:leaderboardId`} element={<CustomLeaderboardDetail />} />
```

---

## 审核流程

### 后台审核界面

在管理员后台添加榜单审核功能：

```python
# backend/app/admin_routes.py

@router.get("/admin/custom-leaderboards/pending")
async def get_pending_leaderboards(
    current_admin: models.AdminUser = Depends(get_current_admin_async),
    db: AsyncSession = Depends(get_async_db_dependency),
):
    """获取待审核榜单列表"""
    result = await db.execute(
        select(models.CustomLeaderboard)
        .where(models.CustomLeaderboard.status == "pending")
        .order_by(models.CustomLeaderboard.created_at.desc())
    )
    return result.scalars().all()
```

前端管理员页面显示待审核榜单，可以：
- 查看申请详情
- 审核通过/拒绝
- 添加审核意见

### 投票记录审计

管理员可以通过 `/api/custom-leaderboards/admin/votes` 接口查看所有投票记录，用于审计：

**接口功能**：
- 查看所有投票记录（包括匿名投票）
- 支持按竞品ID、榜单ID、是否匿名筛选
- **重要**：管理员接口始终返回`user_id`（即使匿名），方便审计
- 返回数据包含`is_anonymous`字段，标识是否匿名

**前端实现建议**：
- 在管理员后台添加"投票记录"页面
- 表格列包含：投票ID、竞品名称、用户ID、投票类型、留言、**是否匿名**、创建时间
- 支持筛选和搜索功能

### 审核接口说明

**权限要求**：
- 审核接口 `/api/custom-leaderboards/{id}/review` 需要管理员权限（`get_current_admin_async`）
- 只有 `pending` 状态的榜单可以被审核
- 审核后状态变为 `active` 或 `rejected`，不能重复审核

**幂等性说明**：
- 审核接口是**非幂等的**，重复点击会返回"该榜单已审核"的 400 错误
- 前端应在提交后禁用按钮或做一次状态刷新，避免误触重复提交

**审核操作日志（后续优化）**：
- 当前已有 `reviewed_by`、`reviewed_at`、`review_comment` 字段，可记录基本审核信息
- 如需更详细的操作审计（例如记录 IP、UA、原始请求体），可在后续增加专用的 `admin_audit_logs` 表
- 此为增强项，V1版本暂不实现

---

## 投票系统

### 投票规则

1. **每个用户对每个竞品只能投一票**
   - 可以通过修改投票来改变投票类型（点赞改为点踩）
   - 可以取消投票

2. **投票统计**
   - `upvotes`: 点赞数
   - `downvotes`: 点踩数
   - `net_votes`: 净赞数 = upvotes - downvotes
   - `vote_score`: 综合得分（用于排序）

3. **防刷票机制**
   - 每个用户ID只能投一票（数据库唯一约束）
   - 可以添加IP限制（可选）
   - 可以添加验证码（可选）

---

## 排序算法

### Wilson Score算法

使用Wilson Score Lower Bound算法计算投票得分，既考虑投票比例，也考虑投票总数：

```python
def calculate_wilson_score(upvotes: int, downvotes: int) -> float:
    """计算Wilson Score"""
    total = upvotes + downvotes
    if total == 0:
        return 0.0
    
    z = 1.96  # 95%置信度
    p = upvotes / total
    n = total
    
    denominator = 1 + (z * z / n)
    numerator = p + (z * z / (2 * n)) - z * math.sqrt((p * (1 - p) + z * z / (4 * n)) / n)
    
    return numerator / denominator
```

### 时间衰减因子（可选）

为新添加的竞品给予一定的时间加成，避免老竞品长期占据榜首：

```python
def calculate_vote_score_with_time(item: LeaderboardItem) -> float:
    """计算带时间衰减的投票得分"""
    from app.utils.time_utils import get_utc_time
    
    wilson_score = calculate_wilson_score(item.upvotes, item.downvotes)
    
    # 时间衰减：每天衰减1%
    # 注意：item.created_at必须是timezone-aware的datetime（已在模型层统一为get_utc_time()）
    # 边界保护：防止created_at大于当前时间（时钟漂移/手动改数据）导致负数
    days_since_created = max(0, (get_utc_time() - item.created_at).days)
    time_factor = 1.0 / (1.0 + days_since_created * 0.01)
    
    return wilson_score * 100 * time_factor
```

### 排序算法扩展（可选增强）

**极少票但分数很高的"冷门项"处理**：

Wilson Score 已经在一定程度上解决了"小样本高分虚高"的问题，但如果希望"至少 X 票之后才可以排到很前面"，可以添加最小票数限制：

```python
# 可选：票数少于3时打折扣系数
if total_votes < 3:
    item.vote_score *= 0.8  # 例如，票数少于3时打个系数
```

**说明**：这是产品策略层面的调整，V1版本暂不实现，可根据实际使用情况在后续版本中调参。

---

## API设计规范

### 统一响应示例（成功）

```json
{
  "id": 1,
  "name": "London中餐榜",
  "location": "London",
  "status": "active",
  "item_count": 25,
  "vote_count": 150,
  "view_count": 500
}
```

**注意**：以上为成功响应的示例格式，不同接口的具体字段可能有所不同。

### 分页响应格式

**V1版本**：列表接口只返回数据数组，不包含分页元信息：

```json
[
  {
    "id": 1,
    "name": "London中餐榜",
    ...
  },
  {
    "id": 2,
    "name": "Manchester超市榜",
    ...
  }
]
```

**未来版本**：当数据规模增大且前端需要更复杂分页时，可升级为统一分页结构：

```json
{
  "items": [ ... ],
  "total": 137,
  "limit": 20,
  "offset": 40
}
```

**说明**：
- V1版本列表接口（榜单列表、竞品列表）使用 `limit` + `offset` 参数
- 返回纯数组，适合当前"最多50/100条直接展示"的用法
- 当榜单/竞品数量达到几百、几千时，可升级为带 `total` 的分页结构，支持页码跳转和总数量显示

### 错误处理

当前实现使用FastAPI默认的错误响应格式：

```json
{
  "detail": "榜单不存在"
}
```

**重要说明**：
- 自定义排行榜API当前使用FastAPI默认错误格式
- 文档中提到的统一错误格式（包含`code`、`message`、`details`字段）属于未来规划
- **如果未来切换为统一错误格式**：需要实现全局异常处理器，自定义排行榜API也会同步变更
- 前端看到文档时，不要误以为现在已经有统一错误结构

---

## 性能优化建议

### 1. 数据库优化
- 添加必要的索引（已在数据库设计中包含）
- 使用连接池优化数据库连接
- 考虑使用Redis缓存热门榜单数据

### 2. 查询优化
- 使用`selectinload`避免N+1查询问题
- 对大量数据的查询使用分页
- 考虑使用物化视图（PostgreSQL）缓存复杂查询结果

### 3. 缓存策略
- 热门榜单列表可以缓存5-10分钟
- 投票统计可以实时更新，但列表查询可以缓存
- 使用Redis存储缓存数据

### 4. 异步处理
- 对于非实时性要求高的操作，可以考虑异步处理
- 投票得分计算（如果数据量大）
- 统计数据更新
- 通知发送

### 5. 并发投票优化（★★★★★ 高优先级，生产环境必须）

**问题严重性**：当前实现使用"读-改-写"模式，在高并发下会出现"丢票"问题：
- 两个请求几乎同时读到同一个item（upvotes=10）
- A: +1 → 11，B: +1 → 11
- 最后结果只加了1，丢失了1票
- **生产环境一旦出现热门榜单（如"伦敦最佳中餐"），极大概率丢票**

**推荐方案：使用数据库原子更新（只需改10行代码）**

在投票接口中，使用数据库层面的原子更新替代读-改-写模式：

```python
# 在 vote_item 接口中，替换原有的 item.upvotes += 1 逻辑

if vote_type == "upvote":
    # 使用原子更新，避免并发丢票
    await db.execute(
        update(models.LeaderboardItem)
        .where(models.LeaderboardItem.id == item_id)
        .values(upvotes=models.LeaderboardItem.upvotes + 1)
    )
    # 重新查询获取最新值
    await db.refresh(item)
else:  # downvote
    await db.execute(
        update(models.LeaderboardItem)
        .where(models.LeaderboardItem.id == item_id)
        .values(downvotes=models.LeaderboardItem.downvotes + 1)
    )
    await db.refresh(item)

# 更新净赞数和得分（使用刷新后的值）
item.net_votes = item.upvotes - item.downvotes
calculate_vote_score(item)
```

**方案2：使用行级锁（备选）**
```python
item_result = await db.execute(
    select(models.LeaderboardItem)
    .where(models.LeaderboardItem.id == item_id)
    .with_for_update()  # 行级锁（PostgreSQL支持）
)
item = item_result.scalar_one()
# 然后进行读-改-写操作
```

**建议**：优先使用方案1（原子更新），性能更好，代码更简洁。

### 6. 微优化建议

**减少重复查询**：
- 投票接口中更新`leaderboard.vote_count`时，可以通过`item.leaderboard`关系直接获取（需注意lazy load）
- 或在一开始join时同时select leaderboard，避免额外查询
- 这个只是"微优化"，V1版本可以暂时不做

### 7. 前端优化建议

**7.1 投票后局部更新（可选/后续）**

当前实现：投票后调用`loadData()`重新请求榜单详情和全量竞品列表，会有明显的"闪一下"。

**优化方案**：投票接口已返回更新后的统计值，前端可以只更新对应item的本地状态：

```typescript
const res = await voteLeaderboardItem(itemId, voteType);
setItems(prev => prev.map(i => i.id === itemId ? {
  ...i,
  upvotes: res.upvotes,
  downvotes: res.downvotes,
  net_votes: res.net_votes,
  vote_score: res.vote_score,
  user_vote: nextUserVote, // 根据当前行为算出来
} : i));
```

**说明**：V1版本可以保持当前实现，等数据量增大或体验要求提高时再优化。

**7.2 统一常量管理**

**问题**：`CustomLeaderboardsTab`和`CustomLeaderboardDetail`都各自定义了`LOCATIONS`。

**建议**：抽到单独文件统一维护：

创建 `frontend/src/constants/leaderboard.ts`：

```typescript
export const LOCATIONS = [
  'Online', 'London', 'Edinburgh', 'Manchester', 'Birmingham', 'Glasgow', 'Bristol', 'Sheffield', 'Leeds', 'Nottingham', 'Newcastle', 'Southampton', 'Liverpool', 'Cardiff', 'Coventry', 'Exeter', 'Leicester', 'York', 'Aberdeen', 'Bath', 'Dundee', 'Reading', 'St Andrews', 'Belfast', 'Brighton', 'Durham', 'Norwich', 'Swansea', 'Loughborough', 'Lancaster', 'Warwick', 'Cambridge', 'Oxford', 'Other'
];
```

两个组件统一从这里import，将来做多语言时只改这一处。

**代码规范**：自定义排行榜使用的`LOCATIONS`常量需统一维护在`constants/leaderboard.ts`中，避免多处重复定义导致标签不一致。

---

## 实施计划

### 阶段1: 数据库和基础API（1周）

**优先级**: 高

1. **数据库设计**
   - 创建数据模型
   - 编写迁移文件
   - 执行数据库迁移

2. **基础API实现**
   - 榜单申请API
   - 榜单列表API
   - 榜单详情API

### 阶段2: 审核系统（1周）

**优先级**: 高

1. **后台审核功能**
   - 管理员审核界面
   - 审核API实现
   - 状态管理

2. **前端申请功能**
   - 申请表单
   - 申请状态查看

### 阶段3: 竞品和投票系统（2周）

**优先级**: 高

1. **新增竞品功能**
   - 新增API
   - 前端新增表单
   - 竞品列表展示

2. **投票系统**
   - 投票API
   - 投票统计
   - 防刷票机制

3. **排序算法**
   - Wilson Score实现
   - 实时排序更新

### 阶段4: 前端集成（1周）

**优先级**: 中

1. **论坛排行榜集成**
   - 添加"其它排行榜"Tab
   - **重要**：切换到"其它排行榜"Tab时，隐藏时间周期选择器（自定义排行榜不使用时间周期筛选，始终显示全部数据）
   - 榜单列表展示
   - 地区筛选
   - **搜索功能**：支持按榜单名称、描述进行关键词搜索

2. **榜单详情页**
   - 竞品列表
   - 投票功能
   - 新增竞品功能

### 阶段5: 优化和测试（1周）

**优先级**: 中

1. **性能优化**
   - 数据库索引优化
   - 查询优化
   - 缓存策略

2. **测试**
   - 功能测试
   - 性能测试
   - 安全测试

---

## 测试清单

### 1. 榜单申请 & 审核

- [ ] **未登录用户调用 `/apply`** → 返回 401
- [ ] **已登录用户正常申请新榜单** → 返回 `pending` 状态
- [ ] **同一用户对同名+同地区重复申请** → 业务层拦截，返回 400
- [ ] **两个并发请求同时申请相同 name+location** → 至少有一个会触发唯一约束，返回 400
- [ ] **管理员审核一个 pending 榜单为 active** → 前端"其它排行榜"Tab 可见
- [ ] **管理员再次审核同一榜单** → 返回 400"该榜单已审核"
- [ ] **审核接口幂等性** → 重复点击返回 400，前端应禁用按钮

### 2. 新增竞品

- [ ] **在 active 榜单中新增竞品** → 新 item `status=approved`，`item_count +1`
- [ ] **向不存在的榜单新增** → 返回 404
- [ ] **向 pending 或 rejected 榜单新增** → 返回 404（"榜单不存在或未激活"）
- [ ] **同榜单同名竞品二次新增** → 返回 400
- [ ] **并发新增同名竞品** → 其中一个触发唯一约束，返回 400

### 3. 投票行为

- [ ] **用户首次点赞** → `upvotes+1`，`net_votes` 更新，`vote_score > 0`，`vote_count+1`
- [ ] **用户首次点踩** → `downvotes+1`，`vote_count+1`
- [ ] **用户投票时添加留言** → 留言保存成功，前端显示留言
- [ ] **用户修改投票时更新留言** → 留言更新成功，旧留言被新留言替换
- [ ] **用户投票时不填写留言** → 投票成功，comment字段为null
- [ ] **用户从赞改踩** → `upvotes-1`, `downvotes+1`，`vote_count` 不变，留言保留
- [ ] **用户取消已有投票** → 对应计数减 1，`vote_count` 不变，留言删除
- [ ] **同一用户多次重复点赞（不改 vote_type）** → 返回 400"您已经投过相同的票"
- [ ] **对不存在/未激活榜单下的竞品投票** → 返回 404

### 3.1 匿名投票行为（v2.3新增）

- [ ] **用户匿名投票** → `is_anonymous=true`，`user_id`仍记录，前端显示已投票状态
- [ ] **用户匿名投票后不能再次投票** → 即使匿名，数据库唯一约束防止重复投票
- [ ] **用户匿名投票后前端能识别已投票** → `user_vote`字段正确返回，按钮高亮显示
- [ ] **用户匿名投票后能看到自己的留言** → 即使匿名，用户自己能看到留言
- [ ] **其他用户看不到匿名投票者信息** → 匿名投票的`user_id`不返回给其他用户
- [ ] **修改投票时可以切换匿名/非匿名** → `is_anonymous`字段可以更新
- [ ] **取消匿名投票后可以重新选择是否匿名** → 取消投票后，再次投票可重新选择
- [ ] **匿名投票的留言也匿名** → 匿名投票时，留言也标记为匿名

### 4. 排序 & 列表

- [ ] **无任何投票时，按 vote_score 排序** → 与 `created_at` 降序一致（或至少不抛错）
- [ ] **多个 item 各有不同投票，检查排序** → 是否与 `vote_score` 计算器期望一致
- [ ] **sort=net_votes/upvotes/created_at 各种组合** → 返回顺序正确
- [ ] **时间衰减边界情况** → `created_at` 大于当前时间时不产生负数

### 5. 权限 & 安全

- [ ] **普通用户调用审核接口 `/review`** → 返回 403
- [ ] **游客调用投票、新增竞品、申请榜单接口** → 返回 401
- [ ] **CSRF token 缺失或错误** → 所有 POST 类接口返回 403（按照现有的 CSRF 中间件策略）
- [ ] **XSS 防护** → 用户输入字段正确转义，不执行恶意脚本

### 6. 前端测试

- [ ] **申请表单** → 表单验证、提交成功/失败提示
- [ ] **榜单列表展示（地区筛选）** → 筛选功能正常，列表正确显示
- [ ] **榜单搜索功能** → 输入关键词后能正确搜索榜单名称和描述，搜索结果准确
- [ ] **搜索与筛选组合** → 同时使用地区筛选和关键词搜索时，结果正确
- [ ] **搜索清空功能** → 清空搜索框后，列表恢复显示所有榜单
- [ ] **榜单详情页** → 详情信息正确显示，竞品列表正确加载
- [ ] **投票交互（点赞/点踩/取消）** → 按钮点击响应正确，状态更新及时
- [ ] **投票按钮状态正确显示（基于user_vote）** → 已投票按钮高亮显示
- [ ] **新增竞品功能** → 表单新增、成功提示、列表刷新
- [ ] **错误处理和用户提示** → 各种错误场景都有友好提示
- [ ] **未使用导入清理** → 代码中无未使用的导入
- [ ] **图片上传和展示功能** → 后续版本，V1暂不支持

### 7. 数据准确性测试

- [ ] **投票统计准确性** → `upvotes`、`downvotes`、`net_votes` 计算正确
- [ ] **排序结果正确性** → 按 `vote_score` 排序与预期一致
- [ ] **时间衰减计算正确性** → 新竞品有加成，老竞品有衰减
- [ ] **vote_count 语义** → 只有新增投票时+1，修改/取消投票不变

---

## 注意事项

1. **数据隐私**: 
   - 确保不泄露用户敏感信息
   - **已修复**：`get_leaderboards`接口已强制只返回active状态的榜单，非active状态会返回403错误
   - 如需查看pending/rejected榜单，请使用管理员专用接口 `/admin/all`
2. **防刷票**: 实施有效的防刷票机制
3. **审核标准**: 制定清晰的榜单审核标准
4. **性能考虑**: 大量投票时需要考虑查询性能
5. **公平性**: 确保排序算法公平，避免被操纵
6. **国际化**: 
   - 当前版本主要使用中文文案，多语言支持将在后续版本中通过`useLanguage`逐步替换文案实现
   - 所有用户可见文本最终需要支持多语言
7. **images字段处理**: 
   - **重要**：`LeaderboardItemOut.images`的类型是`List[str]`，所以任何返回这个schema的接口，都必须遵守这个约定
   - 所有返回`LeaderboardItemOut`的接口，都需要把`images`从JSON字符串解析成`List[str]`再返回
   - 当前在`get_leaderboard_items`中已实现，后续新增类似接口（如`GET /items/{id}`、搜索竞品等）时也要记得同样处理
   - 确保同一个Schema在不同接口中的实际返回类型保持一致
   - **检查清单**：新增返回`LeaderboardItemOut`的接口时，必须确认images已从JSON解析为数组再返回
8. **接口权限说明**: 
   - `get_leaderboards`接口强制只返回active状态的榜单，如果传入`status!=active`会返回403错误
   - 如需查看pending/rejected榜单，请使用管理员专用接口 `/admin/all`
   - 前端用户默认只请求`status=active`，管理员后台使用`/admin/all`查看全部状态
   - **已修复**：榜单详情接口（`GET /{leaderboard_id}`）已限制仅允许访问active状态的榜单，非active状态返回404
   - **已修复**：竞品列表接口（`GET /{leaderboard_id}/items`）已限制仅允许访问active状态的榜单，非active状态返回404
   - **已修复**：新增竞品接口（`POST /items`）已限制仅允许向active状态的榜单新增，非active状态返回404
9. **唯一性约束与错误处理**: 
   - 数据库层添加了`UniqueConstraint('name', 'location')`和`UniqueConstraint('leaderboard_id', 'name')`
   - 业务层保留现有检查，数据库层作为兜底，防止并发插入重复数据
   - **标准错误处理模板**：
     ```python
     from sqlalchemy.exc import IntegrityError
     
     db.add(new_object)
     try:
         await db.commit()
     except IntegrityError:
         await db.rollback()
         raise HTTPException(
             status_code=status.HTTP_400_BAD_REQUEST,
             detail="具体错误信息"
         )
     ```
   - 业务层检查负责用户友好提示，DB层约束负责兜底，发生竞态时不会返回500错误
10. **时间字段时区统一**: 
   - **后端**：所有时间字段使用项目统一的`get_utc_time()`函数（定义在`app.utils.time_utils`）
   - 该函数返回`datetime.now(timezone.utc)`，确保timezone-aware
   - 避免naive/aware混用导致的告警和错误
   - **前端时间显示**：使用`TimeHandlerV2.formatUtcToLocal()`将UTC时间转换为用户本地时间显示
   - **数据库存储**：统一使用`DateTime(timezone=True)`存储UTC时间
   - **迁移文件**：使用`server_default=sa.text('now()')`，数据库端自动生成UTC时间
   - **重要**：生产环境数据库必须配置为`timezone = 'UTC'`，以保证`now()`返回UTC时间
11. **计数字段边界保护**: 
   - 投票逻辑中添加`max(0, x)`保护，防止upvotes/downvotes变成负数
   - 数据库层添加CHECK约束确保非负
12. **并发投票优化（可选/后续）**: 
   - 当前实现可能存在高并发下的"丢更新"问题（读-改-写模式）
   - 建议使用数据库层面的原子更新或行级锁（`with_for_update()`）
   - V1版本可先忽略，等数据量/并发上来再优化
13. **vote_count 语义与删除行为**: 
   - `vote_count` 是"历史累计投票数（按用户对竞品去重，用于统计参与度）"
   - 只有新投票时+1，修改/取消投票都不变
   - **删除竞品**：删除`LeaderboardItem`会级联删除所有`LeaderboardVote`，但`vote_count`不会回滚
   - 该字段用于统计历史参与度，而非当前有效投票数，因此删除行为是合理的
   - **删除榜单**：级联删除所有item和vote，`vote_count`字段随记录一起删除
14. **XSS防护与内容审核**: 
   - 当前前端使用普通`<Input.TextArea>` + React默认转义渲染，XSS风险较低
   - **建议**：后端在保存前做HTML标签剥离/清洗，或约定所有用户输入字段只作为纯文本显示
   - 防止未来在后台/admin页面用富文本渲染或HTML邮件时直接插值导致XSS
   - 具体实现可留待后续阶段，文档层面给出约束即可
15. **前端代码规范**: 
   - 自定义排行榜使用的`LOCATIONS`常量需统一维护在`constants/leaderboard.ts`中
   - 避免多处重复定义导致标签不一致，将来做多语言时只需改一处
   - 参考"性能优化建议"章节中的"前端优化建议"部分

16. **匿名投票功能（v2.3）**: 
   - **重要**：即使匿名投票，数据库层面仍记录`user_id`，用于唯一约束防重复投票
   - 前端通过`user_vote`字段判断是否已投票，不会因为匿名而无法识别
   - 匿名投票时，`user_vote_is_anonymous`字段为`true`，前端可据此判断是否匿名
   - 匿名投票的留言也标记为匿名，其他用户看不到投票者信息
   - 修改投票时可以切换匿名/非匿名状态
   - **安全保证**：数据库唯一约束`uq_item_user_vote`确保每个用户对每个竞品只能投一票，即使匿名也不会出现重复投票的bug

---

## 部署注意事项

### 1. 特性开关（Feature Flag）

**建议**：拆成三个细化开关（★★☆☆☆ 优化建议）：

```python
# config.py 或环境变量
CUSTOM_LEADERBOARD_ENABLED = os.getenv("CUSTOM_LEADERBOARD_ENABLED", "true") == "true"
CUSTOM_LEADERBOARD_ANONYMOUS_VOTE_ENABLED = os.getenv("CUSTOM_LEADERBOARD_ANONYMOUS_VOTE_ENABLED", "true") == "true"
CUSTOM_LEADERBOARD_ITEM_IMAGE_ENABLED = os.getenv("CUSTOM_LEADERBOARD_ITEM_IMAGE_ENABLED", "false") == "true"
```

**使用场景**：
- `CUSTOM_LEADERBOARD_ENABLED`：整体开关，控制是否显示"其它排行榜"Tab
- `CUSTOM_LEADERBOARD_ANONYMOUS_VOTE_ENABLED`：匿名投票开关，出问题时可以关闭匿名功能
- `CUSTOM_LEADERBOARD_ITEM_IMAGE_ENABLED`：图片上传开关，V1可以先关闭，V2再开启

**收益**：灰度更灵活，出问题可精准降级，无需下线整个功能

### 2. 迁移顺序 & 回滚方案

**上线顺序推荐**：

1. **部署新后端代码**（但暂不打开前端入口）
2. **运行 Alembic 迁移**，确认三张表创建成功：
   ```bash
   alembic upgrade head
   ```
3. **验证数据库结构**：确认表、索引、约束都已创建
4. **再上线前端 Tab / 详情页**

**回滚注意**：

- 如果表里已经有数据，直接 `downgrade()` 会删除三张表 → **数据会丢失**
- 生产环境一般**不对这三张表做 downgrade**，只做：
  - 前端关闭入口（通过特性开关）
  - 回滚后端版本（保留数据库结构）

### 3. 监控与告警

**建议在部署文档里加上要观测的指标**：

- `/api/custom-leaderboards/apply` 的 5xx 率、QPS
- `/api/custom-leaderboards/items/{id}/vote` 接口的 5xx 率、耗时
- 数据库连接池使用情况
- 投票接口的并发量

**告警阈值建议**：
- 5xx 错误率 > 1%
- 接口平均响应时间 > 500ms
- 数据库连接池使用率 > 80%

方便发现"被刷接口"或 SQL 性能问题。

### 4. 搜索/索引检查

**部署后通过 SQL 手工确认**：

```sql
-- PostgreSQL
\d custom_leaderboards;
\d leaderboard_items;
\d leaderboard_votes;

-- 或查看索引
SELECT indexname, indexdef 
FROM pg_indexes 
WHERE tablename IN ('custom_leaderboards', 'leaderboard_items', 'leaderboard_votes');
```

确认 `idx_leaderboard_status`、`idx_item_vote_score` 等索引真实存在，而不是只写在文档里。

### 5. 数据库时区配置

**重要**：生产环境数据库必须配置为 `timezone = 'UTC'`：

```sql
-- 检查当前时区
SHOW timezone;

-- 如需修改（PostgreSQL）
ALTER DATABASE your_database SET timezone = 'UTC';
```

确保 `server_default=sa.text('now()')` 返回的是 UTC 时间。

---

## 常见问题解答

### Q1: 为什么我用相同名字/地区又申请了一个榜单，却提示"已存在"？

**A**: 因为系统不允许相同地区出现两个相同名称的榜单（包括待审核 + 已激活），避免用户混淆。可以换一个更具体的名称，比如加上品类或区域，例如：
- ❌ "London中餐榜"（已存在）
- ✅ "London中餐榜（东区）"
- ✅ "London川菜榜"

### Q2: 为什么投票数变了，但榜单排序要过几秒才更新？

**A**: 排序是实时计算的，但客户端可能有缓存 / 请求节流。刷新页面后能看到最新排序。未来可能会增加轻量缓存，这会导致数据在几秒内有轻微延迟。

### Q3: 为什么我删了某个竞品，vote_count 统计里看起来没减？

**A**: `vote_count` 统计的是"历史累计参与投票次数"，删除竞品不会回滚这个统计，它主要用于衡量整个榜单的参与度，而不是当前生效投票数量。这是设计上的选择，用于保留历史数据。

### Q4: 非激活（pending/rejected）榜单为什么还能通过 URL 访问？

**A**: **已修复**：当前版本已限制仅允许访问`active`状态的榜单。非active状态的榜单通过URL访问会返回404，防止隐私泄露。管理员可通过管理员接口`/admin/all`查看所有状态的榜单。

### Q5: 为什么审核接口重复点击会报错？

**A**: 审核接口是**非幂等的**，每个榜单只能审核一次。重复点击会返回"该榜单已审核"的 400 错误。前端应在提交后禁用按钮或做一次状态刷新，避免误触重复提交。

### Q6: 投票得分是如何计算的？

**A**: 使用 Wilson Score Lower Bound 算法 + 时间衰减因子：
- Wilson Score 考虑投票比例和投票总数，避免小样本高分虚高
- 时间衰减：新添加的竞品给予一定加成，每天约衰减 1%
- 最终得分 = `wilson_score * 100 * time_factor`

### Q7: 如何防止刷票？

**A**: 当前实现：
- 每个用户对每个竞品只能投一票（数据库唯一约束）
- 需要登录才能投票（防止匿名刷票）

未来可增强：
- IP 限制
- 验证码
- 频率限制（N 秒内最多 M 次投票）

### Q8: 投票留言功能如何使用？

**A**: 
- 用户投票时可以选择添加留言（最多500字），分享使用体验或说明原因
- 留言是可选的，不填写也可以投票
- 修改投票时可以更新留言
- 取消投票时留言也会被删除
- 用户可以在竞品详情中看到自己的投票留言

---

## 参考资料

- 现有排行榜实现：`backend/app/forum_routes.py`
- 前端排行榜组件：`frontend/src/pages/ForumLeaderboard.tsx`
- 数据库模型：`backend/app/models.py`
- Wilson Score算法：https://en.wikipedia.org/wiki/Binomial_proportion_confidence_interval#Wilson_score_interval

---

## 重要修复说明（v2.1）

根据代码审查反馈，已修复以下问题：

### 1. 状态字段统一
- **榜单状态**：`pending`（待审核）→ `active`（已激活）/ `rejected`（已拒绝），不再使用`approved`状态
- **竞品状态**：`approved`（已通过，V1版本自动通过，无需审核）
- 修复了所有状态判断逻辑，榜单相关代码移除对`approved`状态的引用

### 2. 投票事务优化
- `calculate_vote_score`改为纯计算函数，**不执行commit**
- 由调用方（`vote_item`）统一提交事务
- 避免事务边界混乱和多次提交问题

### 3. user_vote字段支持
- 在`LeaderboardItemOut` Schema中添加`user_vote`字段
- 在`get_leaderboard_items`中查询并返回当前用户的投票状态
- 前端可以正确显示用户已投票的按钮状态

### 4. images字段序列化
- 在`get_leaderboard_items`返回前将JSON字符串解析为`List[str]`
- 确保前端收到的是数组而不是字符串
- 采用路由层手动解析方案（在构造返回数据时统一处理）

### 5. 状态校验增强（已实现）
- **榜单详情接口**：合并检查 `if not leaderboard or leaderboard.status != "active"`，非active榜单完全不可见
- **竞品列表接口**：合并检查 `if not leaderboard or leaderboard.status != "active"`，非active榜单的竞品列表不可访问
- **投票接口**：明确校验 `if leaderboard.status != "active" or item.status != "approved"`，防止对已关闭榜单或已驳回竞品进行投票
- 确保"非active榜单完全不可见、不可投票、不可新增竞品"

### 6. vote_count语义明确
- 明确为"历史累计投票数"（按用户对竞品去重，用于统计参与度）
- 只有新增投票（该用户第一次给该item投票）时才+1，修改投票或取消投票不改变`vote_count`

### 7. 前端交互优化
- 支持点击相同按钮取消投票（调用`vote_type="remove"`）
- 完善错误处理和用户提示
- 移除未使用的导入（`Search`, `getCustomLeaderboardDetail`等）
- **注意**：`useLocalizedNavigation`在代码中实际有使用，不应移除

### 8. 代码清理
- 添加缺失的导入（`get_current_user_optional`）
- 移除未使用的代码和导入
- 统一代码风格和注释

### 9. 文档同步更新
- 明确V1版本的实际行为：只对"榜单"做审核，"竞品"自动通过
- 明确防刷票机制的当前实现和未来增强项
- 更新测试清单，包含所有修复点

---

## 新功能说明（v2.3）

### 匿名投票功能

**功能描述**：
- 用户投票和留言时可以选择匿名
- 匿名投票时，前端不显示用户名，但系统仍记录user_id用于防重复投票
- 前端能正确识别用户是否已投票（即使匿名），防止重复投票

**实现要点**：

1. **数据库层面**：
   - `leaderboard_votes`表增加`is_anonymous`字段（Boolean，默认false）
   - **重要**：即使匿名，仍然记录`user_id`，用于数据库唯一约束防重复投票
   - 数据库迁移需要添加`is_anonymous`列

2. **后端实现**：
   - 投票接口接收`is_anonymous`参数（Query参数，默认false）
   - 创建/更新投票记录时保存`is_anonymous`状态
   - 竞品列表接口返回`user_vote_is_anonymous`字段，前端可据此判断是否匿名

3. **前端实现**：
   - 投票表单增加"匿名投票/留言"复选框
   - 前端API函数`voteLeaderboardItem`增加`isAnonymous`参数
   - 前端能正确识别用户是否已投票（通过`user_vote`字段），即使匿名也能防止重复投票

4. **安全保证**：
   - 数据库唯一约束`uq_item_user_vote`确保每个用户对每个竞品只能投一票
   - 即使匿名，后端仍通过`user_id`检查是否已投票
   - 前端通过`user_vote`字段判断是否已投票，不会因为匿名而无法识别

**数据库迁移**：

如果已有`leaderboard_votes`表，需要添加迁移：

```python
# alembic/versions/xxxx_add_vote_anonymous.py

def upgrade():
    op.add_column('leaderboard_votes', 
        sa.Column('is_anonymous', sa.Boolean(), server_default='false', nullable=False)
    )

def downgrade():
    op.drop_column('leaderboard_votes', 'is_anonymous')
```

**测试要点**：
- [ ] 用户匿名投票后，前端能正确显示已投票状态（按钮高亮）
- [ ] 用户匿名投票后，不能再次投票（即使匿名）
- [ ] 用户匿名投票后，能看到自己的留言（即使匿名）
- [ ] 用户匿名投票后，其他用户看不到投票者信息
- [ ] 修改投票时，可以切换匿名/非匿名状态
- [ ] 取消投票后，再次投票可以重新选择是否匿名

**管理员审计功能**：
- [ ] 管理员可以通过`/admin/votes`接口查看所有投票记录
- [ ] 管理员接口始终返回`user_id`（即使匿名），方便审计
- [ ] 投票记录列表包含`is_anonymous`字段，标识是否匿名
- [ ] 支持按竞品ID、榜单ID、是否匿名筛选

**后续优化建议**：

1. **匿名留言楼层式展示**（可选/后续）：
   - 为匿名留言添加"楼层"式展示，提升阅读体验
   - 显示格式：`"匿名用户 · 3小时前"` 或 `"匿名用户 #123 · 3小时前"`
   - 可以按时间顺序给匿名留言编号（如#1, #2, #3），方便引用和讨论
   - 实现方式：
     - 前端在显示留言时，如果是匿名且`is_anonymous=true`，显示"匿名用户"而不是用户名
     - 使用`TimeHandlerV2.formatUtcToLocal()`格式化时间，显示相对时间（如"3小时前"）
     - 可选：为匿名留言添加序号，按创建时间排序后分配编号

2. **投票记录管理界面**（可选/后续）：
   - 在管理员后台添加完整的投票记录管理页面
   - 支持表格展示、筛选、搜索、导出等功能
   - 显示匿名标识，方便审计和数据分析

---

## 优先级优化建议

### ★★★★★ 投票高并发"丢票"问题（生产环境必须）

**问题**：当前实现使用"读-改-写"模式，热门榜单高并发时极大概率丢票。

**解决方案**：已在"性能优化建议"章节第5节详细说明，使用数据库原子更新。

**实施优先级**：**生产环境上线前必须修复**

---

### ★★★★☆ 投票留言长度限制 + 后端清洗

**已实现**：
- ✅ 数据库层：添加 `CheckConstraint('LENGTH(comment) <= 500')`
- ✅ 后端清洗：使用 `bleach.clean(comment, tags=[], strip=True)` 剥离所有HTML
- ✅ 前端限制：`max_length=500` 和 `maxLength={500}`

**依赖**：需要安装 `bleach` 库：
```bash
pip install bleach
```

---

### ★★★★☆ 竞品图片上传（V2必须品）

**当前状态**：`images` 字段已预留，但缺少上传流程说明。

**实现建议**：

1. **使用现有文件上传服务**（复用 `/upload/public-image` 接口）
   - 竞品图片属于公开图片，使用公开图片存储
   - 路径规则：`uploads/public/images/leaderboard_items/{item_id}/{filename}`
   - **重要**：与现有逻辑保持一致，方便自动化清理

2. **存储路径规则**（与现有逻辑一致）：
   ```python
   # 本地开发环境
   base_dir = Path("uploads/public/images")
   # Railway环境
   base_dir = Path("/data/uploads/public/images")
   
   # 竞品图片存储路径
   image_dir = base_dir / "leaderboard_items" / str(item_id)
   # 完整路径：uploads/public/images/leaderboard_items/{item_id}/{filename}
   ```

3. **文件名规则**（与现有逻辑一致）：
   ```python
   # 使用前缀+UUID，便于后续清理
   filename_prefix = "leaderboard_item_"
   unique_filename = f"{filename_prefix}{uuid.uuid4()}{file_extension}"
   # 示例：leaderboard_item_550e8400-e29b-41d4-a716-446655440000.jpg
   ```

4. **URL生成规则**（与现有逻辑一致）：
   ```python
   from app.config import Config
   base_url = Config.FRONTEND_URL.rstrip('/')
   image_url = f"{base_url}/uploads/images/leaderboard_items/{item_id}/{unique_filename}"
   ```

5. **新增竞品接口支持 multipart/form-data**（推荐方案：复用 `/upload/public-image` 接口）：

   **方案1：扩展 `/upload/public-image` 接口支持 `leaderboard_item` category**
   
   需要修改 `backend/app/routers.py` 中的 `/upload/public-image` 接口：
   ```python
   # 在 category 判断中添加
   elif category == "leaderboard_item":  # 注意：这里的category是图片上传接口的参数，不是榜单类型
       sub_dir = "leaderboard_items"
       filename_prefix = "leaderboard_item_"
       resource_subdir = str(resource_id)  # item_id
   ```
   
   然后前端可以这样使用：
   ```typescript
   // 前端：先创建item获取item_id，再上传图片
   const item = await submitLeaderboardItem({
     leaderboard_id: leaderboardId,
     name: values.name,
     // 先不传images
   });
   
   // 然后上传图片（使用item.id作为resource_id）
   const imageUrls = [];
   for (const file of files) {
     const formData = new FormData();
     formData.append('image', file);
     formData.append('category', 'leaderboard_item');
     formData.append('resource_id', item.id.toString());
     
     const res = await api.post('/api/upload/public-image', formData, {
       headers: { 'X-CSRF-Token': token }
     });
     imageUrls.push(res.url);
   }
   
   // 更新item的images字段
   await updateLeaderboardItem(item.id, { images: imageUrls });
   ```
   
   **注意**：此方案需要先创建item再上传图片，流程稍复杂。

   **方案2：后端直接处理 multipart/form-data**（如果需要在后端统一处理）
   ```python
   from fastapi import File, UploadFile, Form
   import uuid
   import os
   from pathlib import Path
   from app.config import Config
   from app.file_utils import get_file_extension_from_upload
   
   # 复用现有的常量
   ALLOWED_EXTENSIONS = {".jpg", ".jpeg", ".png", ".gif", ".webp"}
   MAX_FILE_SIZE = 5 * 1024 * 1024  # 5MB
   
   @router.post("/items", response_model=schemas.LeaderboardItemOut)
   async def submit_item(
       leaderboard_id: int = Form(...),
       name: str = Form(...),
       description: Optional[str] = Form(None),
       address: Optional[str] = Form(None),
       phone: Optional[str] = Form(None),
       website: Optional[str] = Form(None),
       images: Optional[List[UploadFile]] = File(None),
       current_user: models.User = Depends(get_current_user_secure_async_csrf),
       db: AsyncSession = Depends(get_async_db_dependency),
   ):
       # 1. 检查榜单是否存在且为active状态
       leaderboard = await db.get(models.CustomLeaderboard, leaderboard_id)
       if not leaderboard or leaderboard.status != "active":
           raise HTTPException(status_code=404, detail="榜单不存在或未激活")
       
       # 2. 先创建竞品记录（获取item_id）
       new_item = models.LeaderboardItem(
           leaderboard_id=leaderboard_id,
           name=name,
           description=description,
           address=address,
           phone=phone,
           website=website,
           submitted_by=current_user.id,
           status="approved"
       )
       
       db.add(new_item)
       leaderboard.item_count += 1
       
       try:
           await db.commit()
           await db.refresh(new_item)
       except IntegrityError:
           await db.rollback()
           raise HTTPException(400, "该榜单中已存在相同名称的竞品")
       
       # 3. 上传图片到正式目录（使用item_id）
       image_urls = []
       if images:
           # 检测部署环境
           RAILWAY_ENVIRONMENT = os.getenv("RAILWAY_ENVIRONMENT")
           if RAILWAY_ENVIRONMENT:
               base_dir = Path("/data/uploads/public/images")
           else:
               base_dir = Path("uploads/public/images")
           
           sub_dir = "leaderboard_items"
           item_dir = base_dir / sub_dir / str(new_item.id)
           item_dir.mkdir(parents=True, exist_ok=True)
           
           for image in images:
               content = await image.read()
               
               # 验证文件类型和大小
               file_extension = get_file_extension_from_upload(image, content=content)
               if file_extension not in ALLOWED_EXTENSIONS:
                   raise HTTPException(400, f"不支持的文件类型: {file_extension}")
               if len(content) > MAX_FILE_SIZE:
                   raise HTTPException(400, f"文件过大，最大允许: {MAX_FILE_SIZE // (1024*1024)}MB")
               
               # 生成唯一文件名（与现有逻辑一致）
               unique_filename = f"leaderboard_item_{uuid.uuid4()}{file_extension}"
               file_path = item_dir / unique_filename
               
               # 保存文件
               with open(file_path, "wb") as f:
                   f.write(content)
               
               # 生成URL（与现有逻辑一致）
               base_url = Config.FRONTEND_URL.rstrip('/')
               image_url = f"{base_url}/uploads/images/{sub_dir}/{new_item.id}/{unique_filename}"
               image_urls.append(image_url)
           
           # 更新数据库中的images字段
           new_item.images = json.dumps(image_urls)
           await db.commit()
       
       return new_item
   ```

6. **前端实现**（方案2：后端统一处理）：
   ```typescript
   // 使用FormData上传（包含图片文件）
   const formData = new FormData();
   formData.append('leaderboard_id', leaderboardId.toString());
   formData.append('name', values.name);
   if (values.description) formData.append('description', values.description);
   if (values.address) formData.append('address', values.address);
   if (values.phone) formData.append('phone', values.phone);
   if (values.website) formData.append('website', values.website);
   
   // 添加图片文件
   if (values.images && values.images.length > 0) {
     values.images.forEach((file: File) => {
       formData.append('images', file);
     });
   }
   
   const res = await api.post('/api/custom-leaderboards/items', formData, {
     headers: { 
       'X-CSRF-Token': token,
       // 注意：不要手动设置 Content-Type，让浏览器自动设置（包含boundary）
     }
   });
   ```

7. **目录初始化**（在 `backend/app/main.py` 中添加）：
   ```python
   # Railway环境
   if RAILWAY_ENVIRONMENT:
       (UPLOAD_DIR / "public" / "images" / "leaderboard_items").mkdir(parents=True, exist_ok=True)
   else:
       # 本地开发环境
       (UPLOAD_DIR / "public" / "images" / "leaderboard_items").mkdir(parents=True, exist_ok=True)
   ```

8. **自动化清理**（与现有逻辑一致，方便统一清理）：
   - 路径规则：`uploads/public/images/leaderboard_items/{item_id}/`
   - 删除竞品时，可以按目录批量清理图片：
     ```python
     # 删除竞品时清理图片
     if item.images:
         import json
         import os
         from pathlib import Path
         
         image_urls = json.loads(item.images)
         for url in image_urls:
             # 从URL提取路径：/uploads/images/leaderboard_items/{item_id}/{filename}
             # 或直接删除整个目录
             item_dir = base_dir / "leaderboard_items" / str(item.id)
             if item_dir.exists():
                 import shutil
                 shutil.rmtree(item_dir)  # 删除整个目录
     ```
   - 清理脚本可以统一处理所有 `leaderboard_items` 目录下的图片
   - **重要**：路径规则与现有逻辑（如跳蚤市场、公开图片）保持一致，便于统一管理和清理

**用户最期待的功能之一，不做会严重影响使用率**

---

### ★★★★☆ 榜单/竞品举报功能

**必要性**：必然会出现恶意榜单、虚假餐厅、刷票等，需要社区自净机制。

**数据库设计**：

```python
# 榜单举报表
class LeaderboardReport(Base):
    __tablename__ = "leaderboard_reports"
    
    id = Column(Integer, primary_key=True)
    leaderboard_id = Column(Integer, ForeignKey("custom_leaderboards.id"), nullable=False)
    reporter_id = Column(String(8), ForeignKey("users.id"), nullable=False)
    reason = Column(String(500), nullable=False)  # 举报原因
    status = Column(String(20), default="pending")  # pending, reviewed, dismissed
    reviewed_by = Column(String(36), ForeignKey("admin_users.id"), nullable=True)
    reviewed_at = Column(DateTime(timezone=True), nullable=True)
    created_at = Column(DateTime(timezone=True), default=get_utc_time)
    
    __table_args__ = (
        UniqueConstraint('leaderboard_id', 'reporter_id', name='uq_leaderboard_report'),  # 每个用户对每个榜单只能举报一次
    )

# 竞品举报表
class ItemReport(Base):
    __tablename__ = "item_reports"
    
    id = Column(Integer, primary_key=True)
    item_id = Column(Integer, ForeignKey("leaderboard_items.id"), nullable=False)
    reporter_id = Column(String(8), ForeignKey("users.id"), nullable=False)
    reason = Column(String(500), nullable=False)
    status = Column(String(20), default="pending")
    reviewed_by = Column(String(36), ForeignKey("admin_users.id"), nullable=True)
    reviewed_at = Column(DateTime(timezone=True), nullable=True)
    created_at = Column(DateTime(timezone=True), default=get_utc_time)
    
    __table_args__ = (
        UniqueConstraint('item_id', 'reporter_id', name='uq_item_report'),
    )
```

**接口设计**：
- `POST /api/custom-leaderboards/{id}/report` - 举报榜单
- `POST /api/custom-leaderboards/items/{id}/report` - 举报竞品
- `GET /api/custom-leaderboards/admin/reports` - 管理员查看举报列表

**社区自净必备，否则管理员累死**

---

### ★★★☆☆ 投票记录分页 + 匿名留言楼层展示

**当前状态**：文档只说"能看到自己的留言"，但没说其他用户怎么看投票留言。

**推荐实现**：

1. **竞品详情页增加"查看投票留言"Tab**
   - 显示所有投票留言（包括匿名）
   - 支持分页（每页20条）

2. **匿名留言楼层式展示**
   - 显示格式：`"匿名用户 · 3小时前"` 或 `"匿名用户 #7 · 刚刚"`
   - 按时间降序 + 匿名序号（#1, #2, #3...）

3. **接口设计**：
   ```python
   @router.get("/items/{item_id}/votes", response_model=List[schemas.VoteCommentOut])
   async def get_item_votes(
       item_id: int,
       limit: int = Query(20, ge=1, le=100),
       offset: int = Query(0, ge=0),
       db: AsyncSession = Depends(get_async_db_dependency),
   ):
       """获取竞品的投票留言列表（分页）"""
       # 查询所有有留言的投票
       query = select(models.LeaderboardVote).where(
           and_(
               models.LeaderboardVote.item_id == item_id,
               models.LeaderboardVote.comment.isnot(None)
           )
       ).order_by(models.LeaderboardVote.created_at.desc())
       
       query = query.offset(offset).limit(limit)
       result = await db.execute(query)
       votes = result.scalars().all()
       
       # 为匿名留言分配序号
       anonymous_count = 0
       votes_out = []
       for vote in votes:
           if vote.is_anonymous:
               anonymous_count += 1
               display_name = f"匿名用户 #{anonymous_count}"
           else:
               display_name = vote.user.username  # 需要join User表
           
           votes_out.append({
               "id": vote.id,
               "display_name": display_name,
               "comment": vote.comment,
               "is_anonymous": vote.is_anonymous,
               "created_at": vote.created_at,
               "relative_time": format_relative_time(vote.created_at)  # "3小时前"
           })
       
       return votes_out
   ```

**极大提升互动感和社区氛围**

---

### ★★★☆☆ vote_count 统计字段加索引

**已实现**：已在数据库设计中添加 `Index('idx_leaderboard_vote_count', 'vote_count')`

**收益**：热门榜单按投票数排序时查询更快。

---

### ★★☆☆☆ 管理员后台投票记录搜索优化

**已实现**：已在 `/admin/votes` 接口中添加 `keyword` 参数，支持模糊搜索用户名/留言。

**收益**：人工审计时能快速定位刷票。

---

### ★★☆☆☆ 特性开关细化

**当前状态**：只有一个大开关 `FEATURE_CUSTOM_LEADERBOARD_ENABLED`。

**建议拆成三个**：

```python
# config.py
CUSTOM_LEADERBOARD_ENABLED = os.getenv("CUSTOM_LEADERBOARD_ENABLED", "true") == "true"
CUSTOM_LEADERBOARD_ANONYMOUS_VOTE_ENABLED = os.getenv("CUSTOM_LEADERBOARD_ANONYMOUS_VOTE_ENABLED", "true") == "true"
CUSTOM_LEADERBOARD_ITEM_IMAGE_ENABLED = os.getenv("CUSTOM_LEADERBOARD_ITEM_IMAGE_ENABLED", "false") == "true"
```

**收益**：灰度更灵活，出问题可精准降级。

---

**文档版本**: 2.3  
**最后更新**: 2024-01-XX  
**维护者**: LinkU开发团队
